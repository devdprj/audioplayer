
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4821      	ldr	r0, [pc, #132]	; (8000248 <endfiniloop+0x4>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	2002      	movs	r0, #2
 80001ca:	f380 8814 	msr	CONTROL, r0
 80001ce:	f3bf 8f6f 	isb	sy
 80001d2:	f000 ff5d 	bl	8001090 <__core_init>
 80001d6:	f001 fcdb 	bl	8001b90 <__early_init>
 80001da:	481c      	ldr	r0, [pc, #112]	; (800024c <endfiniloop+0x8>)
 80001dc:	491c      	ldr	r1, [pc, #112]	; (8000250 <endfiniloop+0xc>)
 80001de:	4a1d      	ldr	r2, [pc, #116]	; (8000254 <endfiniloop+0x10>)

080001e0 <msloop>:
 80001e0:	4291      	cmp	r1, r2
 80001e2:	bf3c      	itt	cc
 80001e4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001e8:	e7fa      	bcc.n	80001e0 <msloop>
 80001ea:	491b      	ldr	r1, [pc, #108]	; (8000258 <endfiniloop+0x14>)
 80001ec:	4a16      	ldr	r2, [pc, #88]	; (8000248 <endfiniloop+0x4>)

080001ee <psloop>:
 80001ee:	4291      	cmp	r1, r2
 80001f0:	bf3c      	itt	cc
 80001f2:	f841 0b04 	strcc.w	r0, [r1], #4
 80001f6:	e7fa      	bcc.n	80001ee <psloop>
 80001f8:	4918      	ldr	r1, [pc, #96]	; (800025c <endfiniloop+0x18>)
 80001fa:	4a19      	ldr	r2, [pc, #100]	; (8000260 <endfiniloop+0x1c>)
 80001fc:	4b19      	ldr	r3, [pc, #100]	; (8000264 <endfiniloop+0x20>)

080001fe <dloop>:
 80001fe:	429a      	cmp	r2, r3
 8000200:	bf3e      	ittt	cc
 8000202:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000206:	f842 0b04 	strcc.w	r0, [r2], #4
 800020a:	e7f8      	bcc.n	80001fe <dloop>
 800020c:	2000      	movs	r0, #0
 800020e:	4916      	ldr	r1, [pc, #88]	; (8000268 <endfiniloop+0x24>)
 8000210:	4a16      	ldr	r2, [pc, #88]	; (800026c <endfiniloop+0x28>)

08000212 <bloop>:
 8000212:	4291      	cmp	r1, r2
 8000214:	bf3c      	itt	cc
 8000216:	f841 0b04 	strcc.w	r0, [r1], #4
 800021a:	e7fa      	bcc.n	8000212 <bloop>
 800021c:	f000 ff30 	bl	8001080 <__late_init>
 8000220:	4c13      	ldr	r4, [pc, #76]	; (8000270 <endfiniloop+0x2c>)
 8000222:	4d14      	ldr	r5, [pc, #80]	; (8000274 <endfiniloop+0x30>)

08000224 <initloop>:
 8000224:	42ac      	cmp	r4, r5
 8000226:	da03      	bge.n	8000230 <endinitloop>
 8000228:	f854 1b04 	ldr.w	r1, [r4], #4
 800022c:	4788      	blx	r1
 800022e:	e7f9      	b.n	8000224 <initloop>

08000230 <endinitloop>:
 8000230:	f002 fa66 	bl	8002700 <main>
 8000234:	4c10      	ldr	r4, [pc, #64]	; (8000278 <endfiniloop+0x34>)
 8000236:	4d11      	ldr	r5, [pc, #68]	; (800027c <endfiniloop+0x38>)

08000238 <finiloop>:
 8000238:	42ac      	cmp	r4, r5
 800023a:	da03      	bge.n	8000244 <endfiniloop>
 800023c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000240:	4788      	blx	r1
 8000242:	e7f9      	b.n	8000238 <finiloop>

08000244 <endfiniloop>:
 8000244:	f000 bf14 	b.w	8001070 <__default_exit>
 8000248:	20000800 	.word	0x20000800
 800024c:	55555555 	.word	0x55555555
 8000250:	20000000 	.word	0x20000000
 8000254:	20000400 	.word	0x20000400
 8000258:	20000400 	.word	0x20000400
 800025c:	080049a0 	.word	0x080049a0
 8000260:	20000800 	.word	0x20000800
 8000264:	20000800 	.word	0x20000800
 8000268:	20000800 	.word	0x20000800
 800026c:	200014dc 	.word	0x200014dc
 8000270:	080001c0 	.word	0x080001c0
 8000274:	080001c0 	.word	0x080001c0
 8000278:	080001c0 	.word	0x080001c0
 800027c:	080001c0 	.word	0x080001c0

08000280 <_port_switch>:
 8000280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000284:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000288:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 800028c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000290 <_port_thread_start>:
 8000290:	2300      	movs	r3, #0
 8000292:	f383 8811 	msr	BASEPRI, r3
 8000296:	4628      	mov	r0, r5
 8000298:	47a0      	blx	r4
 800029a:	2000      	movs	r0, #0
 800029c:	f000 feb8 	bl	8001010 <chThdExit>

080002a0 <_port_switch_from_isr>:
 80002a0:	f000 f9e6 	bl	8000670 <chSchDoReschedule>

080002a4 <_port_exit_from_isr>:
 80002a4:	df00      	svc	0
 80002a6:	e7fe      	b.n	80002a6 <_port_exit_from_isr+0x2>
	...

080002b0 <memcpy>:
 80002b0:	4684      	mov	ip, r0
 80002b2:	ea41 0300 	orr.w	r3, r1, r0
 80002b6:	f013 0303 	ands.w	r3, r3, #3
 80002ba:	d16d      	bne.n	8000398 <memcpy+0xe8>
 80002bc:	3a40      	subs	r2, #64	; 0x40
 80002be:	d341      	bcc.n	8000344 <memcpy+0x94>
 80002c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002c4:	f840 3b04 	str.w	r3, [r0], #4
 80002c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002cc:	f840 3b04 	str.w	r3, [r0], #4
 80002d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002d4:	f840 3b04 	str.w	r3, [r0], #4
 80002d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002dc:	f840 3b04 	str.w	r3, [r0], #4
 80002e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002e4:	f840 3b04 	str.w	r3, [r0], #4
 80002e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002ec:	f840 3b04 	str.w	r3, [r0], #4
 80002f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f4:	f840 3b04 	str.w	r3, [r0], #4
 80002f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002fc:	f840 3b04 	str.w	r3, [r0], #4
 8000300:	f851 3b04 	ldr.w	r3, [r1], #4
 8000304:	f840 3b04 	str.w	r3, [r0], #4
 8000308:	f851 3b04 	ldr.w	r3, [r1], #4
 800030c:	f840 3b04 	str.w	r3, [r0], #4
 8000310:	f851 3b04 	ldr.w	r3, [r1], #4
 8000314:	f840 3b04 	str.w	r3, [r0], #4
 8000318:	f851 3b04 	ldr.w	r3, [r1], #4
 800031c:	f840 3b04 	str.w	r3, [r0], #4
 8000320:	f851 3b04 	ldr.w	r3, [r1], #4
 8000324:	f840 3b04 	str.w	r3, [r0], #4
 8000328:	f851 3b04 	ldr.w	r3, [r1], #4
 800032c:	f840 3b04 	str.w	r3, [r0], #4
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	3a40      	subs	r2, #64	; 0x40
 8000342:	d2bd      	bcs.n	80002c0 <memcpy+0x10>
 8000344:	3230      	adds	r2, #48	; 0x30
 8000346:	d311      	bcc.n	800036c <memcpy+0xbc>
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	3a10      	subs	r2, #16
 800036a:	d2ed      	bcs.n	8000348 <memcpy+0x98>
 800036c:	320c      	adds	r2, #12
 800036e:	d305      	bcc.n	800037c <memcpy+0xcc>
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	3a04      	subs	r2, #4
 800037a:	d2f9      	bcs.n	8000370 <memcpy+0xc0>
 800037c:	3204      	adds	r2, #4
 800037e:	d008      	beq.n	8000392 <memcpy+0xe2>
 8000380:	07d2      	lsls	r2, r2, #31
 8000382:	bf1c      	itt	ne
 8000384:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000388:	f800 3b01 	strbne.w	r3, [r0], #1
 800038c:	d301      	bcc.n	8000392 <memcpy+0xe2>
 800038e:	880b      	ldrh	r3, [r1, #0]
 8000390:	8003      	strh	r3, [r0, #0]
 8000392:	4660      	mov	r0, ip
 8000394:	4770      	bx	lr
 8000396:	bf00      	nop
 8000398:	2a08      	cmp	r2, #8
 800039a:	d313      	bcc.n	80003c4 <memcpy+0x114>
 800039c:	078b      	lsls	r3, r1, #30
 800039e:	d08d      	beq.n	80002bc <memcpy+0xc>
 80003a0:	f010 0303 	ands.w	r3, r0, #3
 80003a4:	d08a      	beq.n	80002bc <memcpy+0xc>
 80003a6:	f1c3 0304 	rsb	r3, r3, #4
 80003aa:	1ad2      	subs	r2, r2, r3
 80003ac:	07db      	lsls	r3, r3, #31
 80003ae:	bf1c      	itt	ne
 80003b0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003b4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003b8:	d380      	bcc.n	80002bc <memcpy+0xc>
 80003ba:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003be:	f820 3b02 	strh.w	r3, [r0], #2
 80003c2:	e77b      	b.n	80002bc <memcpy+0xc>
 80003c4:	3a04      	subs	r2, #4
 80003c6:	d3d9      	bcc.n	800037c <memcpy+0xcc>
 80003c8:	3a01      	subs	r2, #1
 80003ca:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003ce:	f800 3b01 	strb.w	r3, [r0], #1
 80003d2:	d2f9      	bcs.n	80003c8 <memcpy+0x118>
 80003d4:	780b      	ldrb	r3, [r1, #0]
 80003d6:	7003      	strb	r3, [r0, #0]
 80003d8:	784b      	ldrb	r3, [r1, #1]
 80003da:	7043      	strb	r3, [r0, #1]
 80003dc:	788b      	ldrb	r3, [r1, #2]
 80003de:	7083      	strb	r3, [r0, #2]
 80003e0:	4660      	mov	r0, ip
 80003e2:	4770      	bx	lr
	...

080003f0 <_mmcsd_get_slice>:
  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
  startoff = start % 32U;
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 80003f0:	f001 031f 	and.w	r3, r1, #31
 *
 * @notapi
 */
uint32_t _mmcsd_get_slice(const uint32_t *data,
                          uint32_t end,
                          uint32_t start) {
 80003f4:	b430      	push	{r4, r5}

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
  startoff = start % 32U;
  endidx   = end / 32U;
 80003f6:	0949      	lsrs	r1, r1, #5
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 80003f8:	1c5c      	adds	r4, r3, #1
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
 80003fa:	0955      	lsrs	r5, r2, #5
  startoff = start % 32U;
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 80003fc:	2301      	movs	r3, #1
 80003fe:	40a3      	lsls	r3, r4

  /* One or two pieces?*/
  if (startidx < endidx) {
 8000400:	428d      	cmp	r5, r1
  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
  startoff = start % 32U;
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 8000402:	f103 34ff 	add.w	r4, r3, #4294967295
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
  startoff = start % 32U;
 8000406:	f002 021f 	and.w	r2, r2, #31
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
 800040a:	d306      	bcc.n	800041a <_mmcsd_get_slice+0x2a>
    return (data[startidx] >> startoff) |               /* Two pieces case. */
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 800040c:	f850 3025 	ldr.w	r3, [r0, r5, lsl #2]
 8000410:	ea04 0003 	and.w	r0, r4, r3
 8000414:	40d0      	lsrs	r0, r2
}
 8000416:	bc30      	pop	{r4, r5}
 8000418:	4770      	bx	lr
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
           ((data[endidx] & endmask) << (32U - startoff));
 800041a:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 800041e:	f850 3025 	ldr.w	r3, [r0, r5, lsl #2]
           ((data[endidx] & endmask) << (32U - startoff));
 8000422:	ea04 0001 	and.w	r0, r4, r1
 8000426:	f1c2 0120 	rsb	r1, r2, #32
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 800042a:	40d3      	lsrs	r3, r2
           ((data[endidx] & endmask) << (32U - startoff));
 800042c:	4088      	lsls	r0, r1
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 800042e:	4318      	orrs	r0, r3
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
}
 8000430:	bc30      	pop	{r4, r5}
 8000432:	4770      	bx	lr
	...

08000440 <_mmcsd_get_capacity>:
 * @return              The card capacity.
 * @retval 0            CSD format error
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
 8000440:	b570      	push	{r4, r5, r6, lr}
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8000442:	217f      	movs	r1, #127	; 0x7f
 8000444:	227e      	movs	r2, #126	; 0x7e
 * @return              The card capacity.
 * @retval 0            CSD format error
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
 8000446:	4605      	mov	r5, r0
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8000448:	f7ff ffd2 	bl	80003f0 <_mmcsd_get_slice>
 800044c:	b148      	cbz	r0, 8000462 <_mmcsd_get_capacity+0x22>
 800044e:	2801      	cmp	r0, #1
 8000450:	d11f      	bne.n	8000492 <_mmcsd_get_capacity+0x52>
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 8000452:	4628      	mov	r0, r5
 8000454:	2145      	movs	r1, #69	; 0x45
 8000456:	2230      	movs	r2, #48	; 0x30
 8000458:	f7ff ffca 	bl	80003f0 <_mmcsd_get_slice>
 800045c:	3001      	adds	r0, #1
 800045e:	0280      	lsls	r0, r0, #10
 8000460:	bd70      	pop	{r4, r5, r6, pc}
  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 8000462:	4628      	mov	r0, r5
 8000464:	2149      	movs	r1, #73	; 0x49
 8000466:	223e      	movs	r2, #62	; 0x3e
 8000468:	f7ff ffc2 	bl	80003f0 <_mmcsd_get_slice>
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 800046c:	2131      	movs	r1, #49	; 0x31
  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 800046e:	4604      	mov	r4, r0
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 8000470:	222f      	movs	r2, #47	; 0x2f
 8000472:	4628      	mov	r0, r5
 8000474:	f7ff ffbc 	bl	80003f0 <_mmcsd_get_slice>
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 8000478:	2153      	movs	r1, #83	; 0x53

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 800047a:	4606      	mov	r6, r0
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 800047c:	2250      	movs	r2, #80	; 0x50
 800047e:	4628      	mov	r0, r5
 8000480:	f7ff ffb6 	bl	80003f0 <_mmcsd_get_slice>
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 8000484:	3602      	adds	r6, #2
 8000486:	3401      	adds	r4, #1
 8000488:	40b4      	lsls	r4, r6
 800048a:	3809      	subs	r0, #9
 800048c:	fa04 f000 	lsl.w	r0, r4, r0
 8000490:	bd70      	pop	{r4, r5, r6, pc}
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
 8000492:	2000      	movs	r0, #0
}
 8000494:	bd70      	pop	{r4, r5, r6, pc}
 8000496:	bf00      	nop
	...

080004a0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80004a0:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80004a4:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80004a6:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80004aa:	2300      	movs	r3, #0
 80004ac:	f383 8811 	msr	BASEPRI, r3
 80004b0:	4770      	bx	lr
 80004b2:	bf00      	nop
	...

080004c0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 80004c0:	b410      	push	{r4}
 80004c2:	2320      	movs	r3, #32
 80004c4:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80004c8:	4c09      	ldr	r4, [pc, #36]	; (80004f0 <chCoreAlloc+0x30>)
 80004ca:	4b0a      	ldr	r3, [pc, #40]	; (80004f4 <chCoreAlloc+0x34>)
 80004cc:	6822      	ldr	r2, [r4, #0]
 80004ce:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 80004d0:	1dc3      	adds	r3, r0, #7
 80004d2:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80004d6:	1a89      	subs	r1, r1, r2
 80004d8:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 80004da:	bf9d      	ittte	ls
 80004dc:	189b      	addls	r3, r3, r2
 80004de:	6023      	strls	r3, [r4, #0]

  return p;
 80004e0:	4610      	movls	r0, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 80004e2:	2000      	movhi	r0, #0
 80004e4:	2300      	movs	r3, #0
 80004e6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 80004ea:	f85d 4b04 	ldr.w	r4, [sp], #4
 80004ee:	4770      	bx	lr
 80004f0:	20001074 	.word	0x20001074
 80004f4:	20000c30 	.word	0x20000c30
	...

08000500 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000500:	b410      	push	{r4}
 8000502:	2320      	movs	r3, #32
 8000504:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8000508:	7f03      	ldrb	r3, [r0, #28]
 800050a:	2b07      	cmp	r3, #7
 800050c:	d80e      	bhi.n	800052c <wakeup+0x2c>
 800050e:	e8df f003 	tbb	[pc, r3]
 8000512:	0d27      	.short	0x0d27
 8000514:	0408230d 	.word	0x0408230d
 8000518:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800051a:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800051c:	6893      	ldr	r3, [r2, #8]
 800051e:	3301      	adds	r3, #1
 8000520:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000522:	e890 000c 	ldmia.w	r0, {r2, r3}
 8000526:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000528:	6802      	ldr	r2, [r0, #0]
 800052a:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800052c:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000530:	2200      	movs	r2, #0
 8000532:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000534:	4b0d      	ldr	r3, [pc, #52]	; (800056c <wakeup+0x6c>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000536:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000538:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800053a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800053c:	689a      	ldr	r2, [r3, #8]
 800053e:	428a      	cmp	r2, r1
 8000540:	d2fb      	bcs.n	800053a <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000542:	685a      	ldr	r2, [r3, #4]
 8000544:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000546:	6003      	str	r3, [r0, #0]
 8000548:	2100      	movs	r1, #0
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800054a:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 800054c:	6058      	str	r0, [r3, #4]
 800054e:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8000552:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000556:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000558:	6a03      	ldr	r3, [r0, #32]
 800055a:	2200      	movs	r2, #0
 800055c:	601a      	str	r2, [r3, #0]
 800055e:	e7e5      	b.n	800052c <wakeup+0x2c>
 8000560:	2300      	movs	r3, #0
 8000562:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8000566:	f85d 4b04 	ldr.w	r4, [sp], #4
 800056a:	4770      	bx	lr
 800056c:	20001140 	.word	0x20001140

08000570 <_idle_thread.lto_priv.66>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000570:	e7fe      	b.n	8000570 <_idle_thread.lto_priv.66>
 8000572:	bf00      	nop
	...

08000580 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8000580:	4a0d      	ldr	r2, [pc, #52]	; (80005b8 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000582:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000584:	b470      	push	{r4, r5, r6}

  tqp->p_next = tp->p_next;
 8000586:	6803      	ldr	r3, [r0, #0]
  thread_t *otp, *cp;

  otp = currp;
 8000588:	6994      	ldr	r4, [r2, #24]
 800058a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800058c:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 800058e:	2500      	movs	r5, #0
 8000590:	68a1      	ldr	r1, [r4, #8]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000592:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000594:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000596:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8000598:	7725      	strb	r5, [r4, #28]
 800059a:	e000      	b.n	800059e <chSchDoRescheduleAhead+0x1e>
 800059c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800059e:	689a      	ldr	r2, [r3, #8]
 80005a0:	428a      	cmp	r2, r1
 80005a2:	d8fb      	bhi.n	800059c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 80005a4:	685a      	ldr	r2, [r3, #4]
 80005a6:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80005a8:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 80005aa:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
 80005ac:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 80005ae:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
}
 80005b0:	bc70      	pop	{r4, r5, r6}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 80005b2:	f7ff be65 	b.w	8000280 <_port_switch>
 80005b6:	bf00      	nop
 80005b8:	20001140 	.word	0x20001140
 80005bc:	00000000 	.word	0x00000000

080005c0 <_port_irq_epilogue>:
 80005c0:	2320      	movs	r3, #32
 80005c2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80005c6:	4b0f      	ldr	r3, [pc, #60]	; (8000604 <_port_irq_epilogue+0x44>)
 80005c8:	685b      	ldr	r3, [r3, #4]
 80005ca:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80005ce:	d102      	bne.n	80005d6 <_port_irq_epilogue+0x16>
 80005d0:	f383 8811 	msr	BASEPRI, r3
 80005d4:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80005d6:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80005da:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80005de:	f843 2c04 	str.w	r2, [r3, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80005e2:	f1a3 0220 	sub.w	r2, r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80005e6:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 80005ea:	4a07      	ldr	r2, [pc, #28]	; (8000608 <_port_irq_epilogue+0x48>)
 80005ec:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 80005ee:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80005f0:	6889      	ldr	r1, [r1, #8]
 80005f2:	6892      	ldr	r2, [r2, #8]
 80005f4:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80005f6:	bf8c      	ite	hi
 80005f8:	4a04      	ldrhi	r2, [pc, #16]	; (800060c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80005fa:	4a05      	ldrls	r2, [pc, #20]	; (8000610 <_port_irq_epilogue+0x50>)
 80005fc:	f843 2c08 	str.w	r2, [r3, #-8]
 8000600:	4770      	bx	lr
 8000602:	bf00      	nop
 8000604:	e000ed00 	.word	0xe000ed00
 8000608:	20001140 	.word	0x20001140
 800060c:	080002a1 	.word	0x080002a1
 8000610:	080002a4 	.word	0x080002a4
	...

08000620 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000620:	4b0e      	ldr	r3, [pc, #56]	; (800065c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000622:	490f      	ldr	r1, [pc, #60]	; (8000660 <chTMStopMeasurementX+0x40>)
 8000624:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000626:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000628:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800062a:	6f4f      	ldr	r7, [r1, #116]	; 0x74

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800062c:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 800062e:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8000630:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000634:	1ad3      	subs	r3, r2, r3
 8000636:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 8000638:	18e4      	adds	r4, r4, r3
 800063a:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800063e:	3601      	adds	r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8000640:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000642:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8000644:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8000646:	e9c0 4504 	strd	r4, r5, [r0, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 800064a:	d805      	bhi.n	8000658 <chTMStopMeasurementX+0x38>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 800064c:	6802      	ldr	r2, [r0, #0]
 800064e:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 8000650:	bf38      	it	cc
 8000652:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8000654:	bcf0      	pop	{r4, r5, r6, r7}
 8000656:	4770      	bx	lr
  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8000658:	6043      	str	r3, [r0, #4]
 800065a:	e7fb      	b.n	8000654 <chTMStopMeasurementX+0x34>
 800065c:	e0001000 	.word	0xe0001000
 8000660:	20001140 	.word	0x20001140
	...

08000670 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8000670:	f7ff bf86 	b.w	8000580 <chSchDoRescheduleAhead>
	...

08000680 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000680:	4b07      	ldr	r3, [pc, #28]	; (80006a0 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000682:	b430      	push	{r4, r5}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000684:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000686:	6999      	ldr	r1, [r3, #24]

  tqp->p_next = tp->p_next;
 8000688:	6814      	ldr	r4, [r2, #0]
  otp->p_state = newstate;
 800068a:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800068c:	2501      	movs	r5, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 800068e:	6063      	str	r3, [r4, #4]
 8000690:	7715      	strb	r5, [r2, #28]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000692:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 8000694:	4610      	mov	r0, r2
}
 8000696:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000698:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800069a:	f7ff bdf1 	b.w	8000280 <_port_switch>
 800069e:	bf00      	nop
 80006a0:	20001140 	.word	0x20001140
	...

080006b0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80006b0:	b5f0      	push	{r4, r5, r6, r7, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80006b2:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80006b4:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80006b6:	d047      	beq.n	8000748 <chSchGoSleepTimeoutS+0x98>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80006b8:	4c3e      	ldr	r4, [pc, #248]	; (80007b4 <chSchGoSleepTimeoutS+0x104>)

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 80006ba:	4a3f      	ldr	r2, [pc, #252]	; (80007b8 <chSchGoSleepTimeoutS+0x108>)
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 80006bc:	69a3      	ldr	r3, [r4, #24]
 80006be:	9305      	str	r3, [sp, #20]
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80006c0:	4625      	mov	r5, r4
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 80006c2:	2901      	cmp	r1, #1
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80006c4:	f855 3f1c 	ldr.w	r3, [r5, #28]!
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80006c8:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 80006cc:	bf98      	it	ls
 80006ce:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80006d0:	42ab      	cmp	r3, r5
 80006d2:	f8dc 6024 	ldr.w	r6, [ip, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 80006d6:	9204      	str	r2, [sp, #16]
 80006d8:	4686      	mov	lr, r0
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80006da:	d055      	beq.n	8000788 <chSchGoSleepTimeoutS+0xd8>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 80006dc:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    if (delta < ch.vtlist.vt_next->vt_delta) {
 80006de:	6898      	ldr	r0, [r3, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 80006e0:	4431      	add	r1, r6
 80006e2:	1a8a      	subs	r2, r1, r2
    if (delta < ch.vtlist.vt_next->vt_delta) {
 80006e4:	4282      	cmp	r2, r0
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80006e6:	bf38      	it	cc
 80006e8:	f8cc 1034 	strcc.w	r1, [ip, #52]	; 0x34
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 80006ec:	4282      	cmp	r2, r0
 80006ee:	d904      	bls.n	80006fa <chSchGoSleepTimeoutS+0x4a>
    delta -= p->vt_delta;
    p = p->vt_next;
 80006f0:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 80006f2:	1a12      	subs	r2, r2, r0
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 80006f4:	6898      	ldr	r0, [r3, #8]
 80006f6:	4290      	cmp	r0, r2
 80006f8:	d3fa      	bcc.n	80006f0 <chSchGoSleepTimeoutS+0x40>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80006fa:	6859      	ldr	r1, [r3, #4]
 80006fc:	9102      	str	r1, [sp, #8]
  vtp->vt_prev->vt_next = vtp;
 80006fe:	af01      	add	r7, sp, #4
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8000700:	9301      	str	r3, [sp, #4]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 8000702:	600f      	str	r7, [r1, #0]
  p->vt_prev = vtp;
 8000704:	605f      	str	r7, [r3, #4]
  vtp->vt_delta = delta
 8000706:	9203      	str	r2, [sp, #12]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000708:	6899      	ldr	r1, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800070a:	f04f 30ff 	mov.w	r0, #4294967295
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800070e:	1a8a      	subs	r2, r1, r2
 8000710:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000712:	6260      	str	r0, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
 8000714:	4670      	mov	r0, lr
 8000716:	f7ff ffb3 	bl	8000680 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800071a:	9b04      	ldr	r3, [sp, #16]
 800071c:	b183      	cbz	r3, 8000740 <chSchGoSleepTimeoutS+0x90>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 800071e:	69e3      	ldr	r3, [r4, #28]
 8000720:	4a24      	ldr	r2, [pc, #144]	; (80007b4 <chSchGoSleepTimeoutS+0x104>)
 8000722:	42bb      	cmp	r3, r7
 8000724:	d017      	beq.n	8000756 <chSchGoSleepTimeoutS+0xa6>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8000726:	9a02      	ldr	r2, [sp, #8]
 8000728:	9b01      	ldr	r3, [sp, #4]
 800072a:	6013      	str	r3, [r2, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 800072c:	9b01      	ldr	r3, [sp, #4]
    vtp->vt_func = NULL;
 800072e:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8000730:	42ab      	cmp	r3, r5
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8000732:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 8000734:	9104      	str	r1, [sp, #16]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8000736:	d003      	beq.n	8000740 <chSchGoSleepTimeoutS+0x90>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8000738:	6899      	ldr	r1, [r3, #8]
 800073a:	9a03      	ldr	r2, [sp, #12]
 800073c:	440a      	add	r2, r1
 800073e:	609a      	str	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8000740:	69a3      	ldr	r3, [r4, #24]
}
 8000742:	6a18      	ldr	r0, [r3, #32]
 8000744:	b007      	add	sp, #28
 8000746:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000748:	4c1a      	ldr	r4, [pc, #104]	; (80007b4 <chSchGoSleepTimeoutS+0x104>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 800074a:	f7ff ff99 	bl	8000680 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 800074e:	69a3      	ldr	r3, [r4, #24]
}
 8000750:	6a18      	ldr	r0, [r3, #32]
 8000752:	b007      	add	sp, #28
 8000754:	bdf0      	pop	{r4, r5, r6, r7, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8000756:	9901      	ldr	r1, [sp, #4]
 8000758:	61d1      	str	r1, [r2, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 800075a:	2300      	movs	r3, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800075c:	42a9      	cmp	r1, r5
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800075e:	604d      	str	r5, [r1, #4]
  vtp->vt_func = NULL;
 8000760:	9304      	str	r3, [sp, #16]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000762:	d022      	beq.n	80007aa <chSchGoSleepTimeoutS+0xfa>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8000764:	9803      	ldr	r0, [sp, #12]
 8000766:	688b      	ldr	r3, [r1, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8000768:	6a92      	ldr	r2, [r2, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 800076a:	4403      	add	r3, r0
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800076c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000770:	608b      	str	r3, [r1, #8]
 8000772:	6a41      	ldr	r1, [r0, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8000774:	1a8a      	subs	r2, r1, r2

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8000776:	4293      	cmp	r3, r2
 8000778:	d9e2      	bls.n	8000740 <chSchGoSleepTimeoutS+0x90>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 800077a:	1a9b      	subs	r3, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800077c:	2b01      	cmp	r3, #1
 800077e:	bf98      	it	ls
 8000780:	2302      	movls	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8000782:	440b      	add	r3, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000784:	6343      	str	r3, [r0, #52]	; 0x34
 8000786:	e7db      	b.n	8000740 <chSchGoSleepTimeoutS+0x90>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 8000788:	af01      	add	r7, sp, #4
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 800078a:	1988      	adds	r0, r1, r6
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
 800078c:	2200      	movs	r2, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800078e:	2302      	movs	r3, #2
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8000790:	62a6      	str	r6, [r4, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8000792:	9501      	str	r5, [sp, #4]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000794:	9502      	str	r5, [sp, #8]
      vtp->vt_delta = delay;
 8000796:	9103      	str	r1, [sp, #12]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 8000798:	61e7      	str	r7, [r4, #28]
      ch.vtlist.vt_prev = vtp;
 800079a:	6227      	str	r7, [r4, #32]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800079c:	f8cc 0034 	str.w	r0, [ip, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80007a0:	f8cc 2010 	str.w	r2, [ip, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80007a4:	f8cc 300c 	str.w	r3, [ip, #12]
 80007a8:	e7b4      	b.n	8000714 <chSchGoSleepTimeoutS+0x64>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80007aa:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80007ae:	60d3      	str	r3, [r2, #12]
 80007b0:	e7c6      	b.n	8000740 <chSchGoSleepTimeoutS+0x90>
 80007b2:	bf00      	nop
 80007b4:	20001140 	.word	0x20001140
 80007b8:	08000501 	.word	0x08000501
 80007bc:	00000000 	.word	0x00000000

080007c0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 80007c0:	b169      	cbz	r1, 80007de <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80007c2:	4b08      	ldr	r3, [pc, #32]	; (80007e4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80007c4:	b410      	push	{r4}
 80007c6:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80007c8:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80007ca:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80007cc:	2004      	movs	r0, #4
 80007ce:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 80007d2:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 80007d4:	6053      	str	r3, [r2, #4]
}
 80007d6:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80007da:	f7ff bf69 	b.w	80006b0 <chSchGoSleepTimeoutS>
}
 80007de:	f04f 30ff 	mov.w	r0, #4294967295
 80007e2:	4770      	bx	lr
 80007e4:	20001140 	.word	0x20001140
	...

080007f0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 80007f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80007f4:	b083      	sub	sp, #12
 80007f6:	4604      	mov	r4, r0
 80007f8:	468b      	mov	fp, r1
 80007fa:	4615      	mov	r5, r2
 80007fc:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 80007fe:	69c7      	ldr	r7, [r0, #28]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000800:	f04f 0820 	mov.w	r8, #32
 8000804:	f388 8811 	msr	BASEPRI, r8
  size_t w = 0;
 8000808:	2600      	movs	r6, #0
 800080a:	46b1      	mov	r9, r6
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800080c:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800080e:	f10b 0a01 	add.w	sl, fp, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8000812:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8000814:	b1fb      	cbz	r3, 8000856 <chOQWriteTimeout+0x66>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000816:	6962      	ldr	r2, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8000818:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800081a:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800081c:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 800081e:	6161      	str	r1, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8000820:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000822:	f89b 3000 	ldrb.w	r3, [fp]
 8000826:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8000828:	6923      	ldr	r3, [r4, #16]
 800082a:	6962      	ldr	r2, [r4, #20]
 800082c:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 800082e:	bf24      	itt	cs
 8000830:	68e3      	ldrcs	r3, [r4, #12]
 8000832:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 8000834:	b107      	cbz	r7, 8000838 <chOQWriteTimeout+0x48>
      nfy(oqp);
 8000836:	47b8      	blx	r7
 8000838:	f389 8811 	msr	BASEPRI, r9
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 800083c:	3d01      	subs	r5, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 800083e:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8000842:	d012      	beq.n	800086a <chOQWriteTimeout+0x7a>
 8000844:	f388 8811 	msr	BASEPRI, r8
 8000848:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800084a:	46d3      	mov	fp, sl
 800084c:	f10b 0a01 	add.w	sl, fp, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8000850:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8000852:	2b00      	cmp	r3, #0
 8000854:	d1df      	bne.n	8000816 <chOQWriteTimeout+0x26>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8000856:	4620      	mov	r0, r4
 8000858:	9901      	ldr	r1, [sp, #4]
 800085a:	9300      	str	r3, [sp, #0]
 800085c:	f7ff ffb0 	bl	80007c0 <chThdEnqueueTimeoutS>
 8000860:	9b00      	ldr	r3, [sp, #0]
 8000862:	2800      	cmp	r0, #0
 8000864:	d0d2      	beq.n	800080c <chOQWriteTimeout+0x1c>
 8000866:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 800086a:	4630      	mov	r0, r6
 800086c:	b003      	add	sp, #12
 800086e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000872:	bf00      	nop
	...

08000880 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8000880:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000882:	4604      	mov	r4, r0
 8000884:	460f      	mov	r7, r1
 8000886:	4616      	mov	r6, r2
 8000888:	2320      	movs	r3, #32
 800088a:	f383 8811 	msr	BASEPRI, r3
 800088e:	e003      	b.n	8000898 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000890:	f7ff ff96 	bl	80007c0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000894:	2800      	cmp	r0, #0
 8000896:	db19      	blt.n	80008cc <chOQPutTimeout+0x4c>
 8000898:	68a5      	ldr	r5, [r4, #8]
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 800089a:	4620      	mov	r0, r4
 800089c:	4631      	mov	r1, r6
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800089e:	2d00      	cmp	r5, #0
 80008a0:	d0f6      	beq.n	8000890 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 80008a2:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80008a4:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80008a6:	1c51      	adds	r1, r2, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80008a8:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 80008aa:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80008ac:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80008ae:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80008b0:	6923      	ldr	r3, [r4, #16]
 80008b2:	6962      	ldr	r2, [r4, #20]
 80008b4:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 80008b6:	bf24      	itt	cs
 80008b8:	68e3      	ldrcs	r3, [r4, #12]
 80008ba:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 80008bc:	69e3      	ldr	r3, [r4, #28]
 80008be:	b10b      	cbz	r3, 80008c4 <chOQPutTimeout+0x44>
    oqp->q_notify(oqp);
 80008c0:	4620      	mov	r0, r4
 80008c2:	4798      	blx	r3
 80008c4:	2000      	movs	r0, #0
 80008c6:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 80008ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80008cc:	f385 8811 	msr	BASEPRI, r5
 80008d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80008d2:	bf00      	nop
	...

080008e0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 80008e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80008e4:	4604      	mov	r4, r0
 80008e6:	b083      	sub	sp, #12
 80008e8:	4689      	mov	r9, r1
 80008ea:	4693      	mov	fp, r2
 80008ec:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 80008ee:	f8d0 801c 	ldr.w	r8, [r0, #28]
 80008f2:	2720      	movs	r7, #32
 80008f4:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 80008f8:	2600      	movs	r6, #0
 80008fa:	9701      	str	r7, [sp, #4]
 80008fc:	46b2      	mov	sl, r6

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 80008fe:	f1b8 0f00 	cmp.w	r8, #0
 8000902:	d005      	beq.n	8000910 <chIQReadTimeout+0x30>
      nfy(iqp);
 8000904:	4620      	mov	r0, r4
 8000906:	47c0      	blx	r8
 8000908:	e002      	b.n	8000910 <chIQReadTimeout+0x30>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800090a:	f7ff ff59 	bl	80007c0 <chThdEnqueueTimeoutS>
 800090e:	b9e0      	cbnz	r0, 800094a <chIQReadTimeout+0x6a>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8000910:	68a7      	ldr	r7, [r4, #8]
 8000912:	4620      	mov	r0, r4
 8000914:	4629      	mov	r1, r5
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8000916:	2f00      	cmp	r7, #0
 8000918:	d0f7      	beq.n	800090a <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800091a:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800091c:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800091e:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000920:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8000922:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000924:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000926:	7813      	ldrb	r3, [r2, #0]
 8000928:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 800092c:	6923      	ldr	r3, [r4, #16]
 800092e:	69a2      	ldr	r2, [r4, #24]
 8000930:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8000932:	bf24      	itt	cs
 8000934:	68e3      	ldrcs	r3, [r4, #12]
 8000936:	61a3      	strcs	r3, [r4, #24]
 8000938:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 800093c:	3601      	adds	r6, #1
    if (--n == 0U) {
 800093e:	45b3      	cmp	fp, r6
 8000940:	d005      	beq.n	800094e <chIQReadTimeout+0x6e>
 8000942:	9b01      	ldr	r3, [sp, #4]
 8000944:	f383 8811 	msr	BASEPRI, r3
 8000948:	e7d9      	b.n	80008fe <chIQReadTimeout+0x1e>
 800094a:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 800094e:	4630      	mov	r0, r6
 8000950:	b003      	add	sp, #12
 8000952:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000956:	bf00      	nop
	...

08000960 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8000960:	b570      	push	{r4, r5, r6, lr}
 8000962:	2320      	movs	r3, #32
 8000964:	460e      	mov	r6, r1
 8000966:	4604      	mov	r4, r0
 8000968:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 800096c:	69c3      	ldr	r3, [r0, #28]
 800096e:	b12b      	cbz	r3, 800097c <chIQGetTimeout+0x1c>
    iqp->q_notify(iqp);
 8000970:	4798      	blx	r3
 8000972:	e003      	b.n	800097c <chIQGetTimeout+0x1c>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8000974:	f7ff ff24 	bl	80007c0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000978:	2800      	cmp	r0, #0
 800097a:	db15      	blt.n	80009a8 <chIQGetTimeout+0x48>
 800097c:	68a5      	ldr	r5, [r4, #8]
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800097e:	4620      	mov	r0, r4
 8000980:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8000982:	2d00      	cmp	r5, #0
 8000984:	d0f6      	beq.n	8000974 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000986:	69a1      	ldr	r1, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000988:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 800098a:	6925      	ldr	r5, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800098c:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800098e:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8000990:	42aa      	cmp	r2, r5
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000992:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8000994:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8000996:	bf28      	it	cs
 8000998:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800099a:	7808      	ldrb	r0, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800099c:	bf28      	it	cs
 800099e:	61a3      	strcs	r3, [r4, #24]
 80009a0:	2300      	movs	r3, #0
 80009a2:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
 80009a6:	bd70      	pop	{r4, r5, r6, pc}
 80009a8:	f385 8811 	msr	BASEPRI, r5
 80009ac:	bd70      	pop	{r4, r5, r6, pc}
 80009ae:	bf00      	nop

080009b0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80009b0:	b508      	push	{r3, lr}
 80009b2:	4601      	mov	r1, r0
 80009b4:	2320      	movs	r3, #32
 80009b6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80009ba:	2008      	movs	r0, #8
 80009bc:	f7ff fe78 	bl	80006b0 <chSchGoSleepTimeoutS>
 80009c0:	2300      	movs	r3, #0
 80009c2:	f383 8811 	msr	BASEPRI, r3
 80009c6:	bd08      	pop	{r3, pc}
	...

080009d0 <sdcConnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcConnect(SDCDriver *sdcp) {
 80009d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80009d4:	b085      	sub	sp, #20
 * @notapi
 */
void sdc_lld_start_clk(SDCDriver *sdcp) {

  /* Initial clock setting: 400kHz, 1bit mode.*/
  sdcp->sdio->CLKCR  = STM32_SDIO_DIV_LS;
 80009d6:	6c83      	ldr	r3, [r0, #72]	; 0x48
  osalDbgCheck(sdcp != NULL);
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");

  /* Connection procedure in progress.*/
  sdcp->state = BLK_CONNECTING;
 80009d8:	2203      	movs	r2, #3
 80009da:	7102      	strb	r2, [r0, #4]
 80009dc:	2278      	movs	r2, #120	; 0x78
 80009de:	605a      	str	r2, [r3, #4]
  sdcp->sdio->POWER |= SDIO_POWER_PWRCTRL_0 | SDIO_POWER_PWRCTRL_1;
 80009e0:	681a      	ldr	r2, [r3, #0]
 80009e2:	f042 0203 	orr.w	r2, r2, #3
 80009e6:	601a      	str	r2, [r3, #0]
  sdcp->sdio->CLKCR |= SDIO_CLKCR_CLKEN;
 80009e8:	685a      	ldr	r2, [r3, #4]
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcConnect(SDCDriver *sdcp) {
 80009ea:	4605      	mov	r5, r0
 80009ec:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80009f0:	605a      	str	r2, [r3, #4]
 80009f2:	af02      	add	r7, sp, #8
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {

  chThdSleep(time);
 80009f4:	2064      	movs	r0, #100	; 0x64
 80009f6:	f7ff ffdb 	bl	80009b0 <chThdSleep>
 *
 * @notapi
 */
void sdc_lld_send_cmd_none(SDCDriver *sdcp, uint8_t cmd, uint32_t arg) {

  sdcp->sdio->ARG = arg;
 80009fa:	6caa      	ldr	r2, [r5, #72]	; 0x48
 80009fc:	2100      	movs	r1, #0
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_CPSMEN;
 80009fe:	f44f 6380 	mov.w	r3, #1024	; 0x400
 *
 * @notapi
 */
void sdc_lld_send_cmd_none(SDCDriver *sdcp, uint8_t cmd, uint32_t arg) {

  sdcp->sdio->ARG = arg;
 8000a02:	6091      	str	r1, [r2, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_CPSMEN;
 8000a04:	60d3      	str	r3, [r2, #12]
  while ((sdcp->sdio->STA & SDIO_STA_CMDSENT) == 0)
 8000a06:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8000a08:	0618      	lsls	r0, r3, #24
 8000a0a:	d5fc      	bpl.n	8000a06 <sdcConnect+0x36>
    ;
  sdcp->sdio->ICR = SDIO_ICR_CMDSENTC;
 8000a0c:	2380      	movs	r3, #128	; 0x80
 8000a0e:	6393      	str	r3, [r2, #56]	; 0x38
 */
static bool mode_detect(SDCDriver *sdcp) {
  uint32_t resp[1];

  /* V2.0 cards detection.*/
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
 8000a10:	4628      	mov	r0, r5
 8000a12:	1d3b      	adds	r3, r7, #4
 8000a14:	2108      	movs	r1, #8
 8000a16:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 8000a1a:	f001 fbb9 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000a1e:	b998      	cbnz	r0, 8000a48 <sdcConnect+0x78>
                                  MMCSD_CMD8_PATTERN, resp)) {
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 8000a20:	687b      	ldr	r3, [r7, #4]
  uint32_t resp[1];

  /* V2.0 cards detection.*/
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
                                  MMCSD_CMD8_PATTERN, resp)) {
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 8000a22:	2201      	movs	r2, #1
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 8000a24:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8000a28:	4293      	cmp	r3, r2
  uint32_t resp[1];

  /* V2.0 cards detection.*/
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
                                  MMCSD_CMD8_PATTERN, resp)) {
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 8000a2a:	632a      	str	r2, [r5, #48]	; 0x30
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 8000a2c:	f000 80ff 	beq.w	8000c2e <sdcConnect+0x25e>
 8000a30:	6cac      	ldr	r4, [r5, #72]	; 0x48
 *
 * @notapi
 */
void sdc_lld_stop_clk(SDCDriver *sdcp) {

  sdcp->sdio->CLKCR = 0;
 8000a32:	2300      	movs	r3, #0
  return HAL_SUCCESS;

  /* Connection failed, state reset to BLK_ACTIVE.*/
failed:
  sdc_lld_stop_clk(sdcp);
  sdcp->state = BLK_ACTIVE;
 8000a34:	2202      	movs	r2, #2
 8000a36:	6063      	str	r3, [r4, #4]
  return HAL_FAILED;
 8000a38:	2601      	movs	r6, #1
  sdcp->sdio->POWER = 0;
 8000a3a:	6023      	str	r3, [r4, #0]
  return HAL_SUCCESS;

  /* Connection failed, state reset to BLK_ACTIVE.*/
failed:
  sdc_lld_stop_clk(sdcp);
  sdcp->state = BLK_ACTIVE;
 8000a3c:	712a      	strb	r2, [r5, #4]
  return HAL_FAILED;
}
 8000a3e:	4630      	mov	r0, r6
 8000a40:	370c      	adds	r7, #12
 8000a42:	46bd      	mov	sp, r7
 8000a44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      return HAL_FAILED;
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8000a48:	4628      	mov	r0, r5
 8000a4a:	2137      	movs	r1, #55	; 0x37
 8000a4c:	2200      	movs	r2, #0
 8000a4e:	1d3b      	adds	r3, r7, #4
 8000a50:	f001 fb9e 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000a54:	2800      	cmp	r0, #0
 8000a56:	d137      	bne.n	8000ac8 <sdcConnect+0xf8>
        MMCSD_R1_ERROR(resp[0])) {
 8000a58:	687a      	ldr	r2, [r7, #4]
 8000a5a:	4bbb      	ldr	r3, [pc, #748]	; (8000d48 <sdcConnect+0x378>)
 8000a5c:	4013      	ands	r3, r2
      return HAL_FAILED;
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8000a5e:	2b00      	cmp	r3, #0
 8000a60:	d132      	bne.n	8000ac8 <sdcConnect+0xf8>
 *
 * @notapi
 */
void sdc_lld_send_cmd_none(SDCDriver *sdcp, uint8_t cmd, uint32_t arg) {

  sdcp->sdio->ARG = arg;
 8000a62:	6caa      	ldr	r2, [r5, #72]	; 0x48
        MMCSD_R1_ERROR(resp[0])) {
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
    }
    else {
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
 8000a64:	632b      	str	r3, [r5, #48]	; 0x30
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_CPSMEN;
 8000a66:	f44f 6180 	mov.w	r1, #1024	; 0x400
 *
 * @notapi
 */
void sdc_lld_send_cmd_none(SDCDriver *sdcp, uint8_t cmd, uint32_t arg) {

  sdcp->sdio->ARG = arg;
 8000a6a:	6093      	str	r3, [r2, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_CPSMEN;
 8000a6c:	60d1      	str	r1, [r2, #12]
  while ((sdcp->sdio->STA & SDIO_STA_CMDSENT) == 0)
 8000a6e:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8000a70:	0619      	lsls	r1, r3, #24
 8000a72:	d5fc      	bpl.n	8000a6e <sdcConnect+0x9e>
    ;
  sdcp->sdio->ICR = SDIO_ICR_CMDSENTC;
 8000a74:	2380      	movs	r3, #128	; 0x80

  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_SDV20) {
    ocr = 0xC0100000U;
  }
  else {
    ocr = 0x80100000U;
 8000a76:	f8df 82dc 	ldr.w	r8, [pc, #732]	; 8000d54 <sdcConnect+0x384>
 8000a7a:	6393      	str	r3, [r2, #56]	; 0x38
 8000a7c:	2664      	movs	r6, #100	; 0x64
bool sdc_lld_send_cmd_short(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                            uint32_t *resp) {
  uint32_t sta;

  sdcp->sdio->ARG = arg;
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8000a7e:	f240 4969 	movw	r9, #1129	; 0x469
  }

  i = 0;
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8000a82:	4628      	mov	r0, r5
 8000a84:	2137      	movs	r1, #55	; 0x37
 8000a86:	2200      	movs	r2, #0
 8000a88:	1d3b      	adds	r3, r7, #4
 8000a8a:	f001 fb81 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000a8e:	6cac      	ldr	r4, [r5, #72]	; 0x48
 8000a90:	2800      	cmp	r0, #0
 8000a92:	d1ce      	bne.n	8000a32 <sdcConnect+0x62>
        MMCSD_R1_ERROR(resp[0])) {
 8000a94:	687a      	ldr	r2, [r7, #4]
 8000a96:	4bac      	ldr	r3, [pc, #688]	; (8000d48 <sdcConnect+0x378>)
 8000a98:	4013      	ands	r3, r2
    ocr = 0x80100000U;
  }

  i = 0;
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8000a9a:	2b00      	cmp	r3, #0
 8000a9c:	d1c9      	bne.n	8000a32 <sdcConnect+0x62>
 */
bool sdc_lld_send_cmd_short(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                            uint32_t *resp) {
  uint32_t sta;

  sdcp->sdio->ARG = arg;
 8000a9e:	f8c4 8008 	str.w	r8, [r4, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8000aa2:	f8c4 900c 	str.w	r9, [r4, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8000aa6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8000aa8:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8000aac:	d0fb      	beq.n	8000aa6 <sdcConnect+0xd6>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
                           SDIO_STA_CCRCFAIL);
  if ((sta & (SDIO_STA_CTIMEOUT)) != 0) {
 8000aae:	0748      	lsls	r0, r1, #29
  sdcp->sdio->ARG = arg;
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8000ab0:	63a3      	str	r3, [r4, #56]	; 0x38
                           SDIO_STA_CCRCFAIL);
  if ((sta & (SDIO_STA_CTIMEOUT)) != 0) {
 8000ab2:	d425      	bmi.n	8000b00 <sdcConnect+0x130>
    sdc_lld_collect_errors(sdcp, sta);
    return HAL_FAILED;
  }
  *resp = sdcp->sdio->RESP1;
 8000ab4:	6963      	ldr	r3, [r4, #20]
 8000ab6:	607b      	str	r3, [r7, #4]
      return HAL_FAILED;
    }
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_APP_OP_COND, ocr, resp)) {
      return HAL_FAILED;
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 8000ab8:	2b00      	cmp	r3, #0
 8000aba:	db27      	blt.n	8000b0c <sdcConnect+0x13c>
      if ((resp[0] & 0x40000000U) != 0U) {
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
      }
      break;
    }
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8000abc:	3e01      	subs	r6, #1
 8000abe:	d0b8      	beq.n	8000a32 <sdcConnect+0x62>
 8000ac0:	2064      	movs	r0, #100	; 0x64
 8000ac2:	f7ff ff75 	bl	80009b0 <chThdSleep>
 8000ac6:	e7dc      	b.n	8000a82 <sdcConnect+0xb2>
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
 8000ac8:	2302      	movs	r3, #2
 8000aca:	632b      	str	r3, [r5, #48]	; 0x30
 */
bool sdc_lld_send_cmd_short(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                            uint32_t *resp) {
  uint32_t sta;

  sdcp->sdio->ARG = arg;
 8000acc:	f8df 9290 	ldr.w	r9, [pc, #656]	; 8000d60 <sdcConnect+0x390>
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcConnect(SDCDriver *sdcp) {
 8000ad0:	2664      	movs	r6, #100	; 0x64
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8000ad2:	f240 4841 	movw	r8, #1089	; 0x441
 */
bool sdc_lld_send_cmd_short(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                            uint32_t *resp) {
  uint32_t sta;

  sdcp->sdio->ARG = arg;
 8000ad6:	6cac      	ldr	r4, [r5, #72]	; 0x48
 8000ad8:	f8c4 9008 	str.w	r9, [r4, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8000adc:	f8c4 800c 	str.w	r8, [r4, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8000ae0:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8000ae2:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8000ae6:	d0fb      	beq.n	8000ae0 <sdcConnect+0x110>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8000ae8:	63a3      	str	r3, [r4, #56]	; 0x38
                           SDIO_STA_CCRCFAIL);
  if ((sta & (SDIO_STA_CTIMEOUT)) != 0) {
 8000aea:	074b      	lsls	r3, r1, #29
 8000aec:	d408      	bmi.n	8000b00 <sdcConnect+0x130>
    sdc_lld_collect_errors(sdcp, sta);
    return HAL_FAILED;
  }
  *resp = sdcp->sdio->RESP1;
 8000aee:	6963      	ldr	r3, [r4, #20]
  i = 0;
  while (true) {
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_INIT, ocr, resp)) {
      return HAL_FAILED;
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 8000af0:	2b00      	cmp	r3, #0
 8000af2:	db0b      	blt.n	8000b0c <sdcConnect+0x13c>
      if ((resp[0] & 0x40000000U) != 0U) {
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
      }
      break;
    }
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8000af4:	3e01      	subs	r6, #1
 8000af6:	d09c      	beq.n	8000a32 <sdcConnect+0x62>
 8000af8:	2064      	movs	r0, #100	; 0x64
 8000afa:	f7ff ff59 	bl	80009b0 <chThdSleep>
 8000afe:	e7ea      	b.n	8000ad6 <sdcConnect+0x106>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
                           SDIO_STA_CCRCFAIL);
  if ((sta & (SDIO_STA_CTIMEOUT)) != 0) {
    sdc_lld_collect_errors(sdcp, sta);
 8000b00:	f105 0034 	add.w	r0, r5, #52	; 0x34
 8000b04:	f001 fb04 	bl	8002110 <sdc_lld_collect_errors.isra.0.lto_priv.84>
 8000b08:	6cac      	ldr	r4, [r5, #72]	; 0x48
 8000b0a:	e792      	b.n	8000a32 <sdcConnect+0x62>
    }
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_APP_OP_COND, ocr, resp)) {
      return HAL_FAILED;
    }
    if ((resp[0] & 0x80000000U) != 0U) {
      if ((resp[0] & 0x40000000U) != 0U) {
 8000b0c:	005a      	lsls	r2, r3, #1
 8000b0e:	d503      	bpl.n	8000b18 <sdcConnect+0x148>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 8000b10:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000b12:	f043 0310 	orr.w	r3, r3, #16
 8000b16:	632b      	str	r3, [r5, #48]	; 0x30
      goto failed;
    }
  }

  /* Reads CID.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_ALL_SEND_CID, 0, sdcp->cid)) {
 8000b18:	4628      	mov	r0, r5
 8000b1a:	2102      	movs	r1, #2
 8000b1c:	2200      	movs	r2, #0
 8000b1e:	f105 0308 	add.w	r3, r5, #8
 8000b22:	f001 fb15 	bl	8002150 <sdc_lld_send_cmd_long_crc>
 8000b26:	2800      	cmp	r0, #0
 8000b28:	d182      	bne.n	8000a30 <sdcConnect+0x60>
    goto failed;
  }

  /* Asks for the RCA.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_RELATIVE_ADDR,
 8000b2a:	4602      	mov	r2, r0
 8000b2c:	2103      	movs	r1, #3
 8000b2e:	4628      	mov	r0, r5
 8000b30:	f105 0338 	add.w	r3, r5, #56	; 0x38
 8000b34:	f001 fb2c 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000b38:	2800      	cmp	r0, #0
 8000b3a:	f47f af79 	bne.w	8000a30 <sdcConnect+0x60>
    goto failed;
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
                                sdcp->rca, sdcp->csd)) {
 8000b3e:	f105 0618 	add.w	r6, r5, #24
                                 0, &sdcp->rca)) {
    goto failed;
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 8000b42:	4633      	mov	r3, r6
 8000b44:	4628      	mov	r0, r5
 8000b46:	2109      	movs	r1, #9
 8000b48:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8000b4a:	f001 fb01 	bl	8002150 <sdc_lld_send_cmd_long_crc>
 8000b4e:	2800      	cmp	r0, #0
 8000b50:	f47f af6e 	bne.w	8000a30 <sdcConnect+0x60>
                                sdcp->rca, sdcp->csd)) {
    goto failed;
  }

  /* Selects the card for operations.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEL_DESEL_CARD,
 8000b54:	463b      	mov	r3, r7
 8000b56:	4628      	mov	r0, r5
 8000b58:	2107      	movs	r1, #7
 8000b5a:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8000b5c:	f001 fb18 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000b60:	4681      	mov	r9, r0
 8000b62:	2800      	cmp	r0, #0
 8000b64:	f47f af64 	bne.w	8000a30 <sdcConnect+0x60>
 *
 * @notapi
 */
static bool detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {

  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8000b68:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000b6a:	f003 030f 	and.w	r3, r3, #15
 8000b6e:	2b02      	cmp	r3, #2
 8000b70:	f000 80f8 	beq.w	8000d64 <sdcConnect+0x394>
 8000b74:	46e8      	mov	r8, sp
  /* Safe default.*/
  *clk = SDC_CLK_25MHz;

  /* Looks like only "high capacity" cards produce meaningful results during
     this clock detection procedure.*/
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8000b76:	4630      	mov	r0, r6
 * @notapi
 */
static bool sdc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
  uint32_t cmdarg;
  const size_t N = 64;
  uint8_t tmp[N];
 8000b78:	b090      	sub	sp, #64	; 0x40
  /* Safe default.*/
  *clk = SDC_CLK_25MHz;

  /* Looks like only "high capacity" cards produce meaningful results during
     this clock detection procedure.*/
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8000b7a:	217f      	movs	r1, #127	; 0x7f
 8000b7c:	227e      	movs	r2, #126	; 0x7e
 * @notapi
 */
static bool sdc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
  uint32_t cmdarg;
  const size_t N = 64;
  uint8_t tmp[N];
 8000b7e:	ac02      	add	r4, sp, #8
  /* Safe default.*/
  *clk = SDC_CLK_25MHz;

  /* Looks like only "high capacity" cards produce meaningful results during
     this clock detection procedure.*/
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8000b80:	f7ff fc36 	bl	80003f0 <_mmcsd_get_slice>
 8000b84:	2800      	cmp	r0, #0
 8000b86:	f040 80c4 	bne.w	8000d12 <sdcConnect+0x342>
 8000b8a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000b8c:	46c5      	mov	sp, r8
 8000b8e:	f003 030f 	and.w	r3, r3, #15
  else
    sdcp->sdio->CLKCR = (sdcp->sdio->CLKCR & 0xFFFFFF00U) | STM32_SDIO_DIV_HS;
#else
  (void)clk;

  sdcp->sdio->CLKCR = (sdcp->sdio->CLKCR & 0xFFFFFF00U) | STM32_SDIO_DIV_HS;
 8000b92:	6cac      	ldr	r4, [r5, #72]	; 0x48
 8000b94:	6862      	ldr	r2, [r4, #4]
    goto failed;
  }
  sdc_lld_set_data_clk(sdcp, clk);

  /* Reads extended CSD if needed and possible.*/
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8000b96:	2b02      	cmp	r3, #2
 8000b98:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8000b9c:	6062      	str	r2, [r4, #4]

    /* The card is a MMC, checking if it is a large device.*/
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 8000b9e:	4630      	mov	r0, r6
    goto failed;
  }
  sdc_lld_set_data_clk(sdcp, clk);

  /* Reads extended CSD if needed and possible.*/
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8000ba0:	f000 8090 	beq.w	8000cc4 <sdcConnect+0x2f4>
      sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
    }
  }
  else {
    /* The card is an SDC, capacity from the normal CSD.*/
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8000ba4:	f7ff fc4c 	bl	8000440 <_mmcsd_get_capacity>
 8000ba8:	62a8      	str	r0, [r5, #40]	; 0x28
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
 8000baa:	463b      	mov	r3, r7
 8000bac:	4628      	mov	r0, r5
 8000bae:	2110      	movs	r1, #16
 8000bb0:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000bb4:	f001 faec 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000bb8:	4606      	mov	r6, r0
 8000bba:	2800      	cmp	r0, #0
 8000bbc:	f47f af38 	bne.w	8000a30 <sdcConnect+0x60>
                                 MMCSD_BLOCK_SIZE, resp) ||
      MMCSD_R1_ERROR(resp[0])) {
 8000bc0:	683a      	ldr	r2, [r7, #0]
 8000bc2:	4b61      	ldr	r3, [pc, #388]	; (8000d48 <sdcConnect+0x378>)
 8000bc4:	4013      	ands	r3, r2
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
                                 MMCSD_BLOCK_SIZE, resp) ||
 8000bc6:	2b00      	cmp	r3, #0
 8000bc8:	f47f af32 	bne.w	8000a30 <sdcConnect+0x60>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  /* Switches to wide bus mode.*/
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 8000bcc:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000bce:	f003 030f 	and.w	r3, r3, #15
 8000bd2:	2b01      	cmp	r3, #1
 8000bd4:	d950      	bls.n	8000c78 <sdcConnect+0x2a8>
 8000bd6:	2b02      	cmp	r3, #2
 8000bd8:	f47f af2a 	bne.w	8000a30 <sdcConnect+0x60>
 */
static bool mmc_set_bus_width(SDCDriver *sdcp) {
  uint32_t resp[1];
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);

  switch(sdcp->config->bus_width){
 8000bdc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8000bde:	791a      	ldrb	r2, [r3, #4]
 8000be0:	2a01      	cmp	r2, #1
 8000be2:	d040      	beq.n	8000c66 <sdcConnect+0x296>
 8000be4:	d320      	bcc.n	8000c28 <sdcConnect+0x258>
 8000be6:	2a02      	cmp	r2, #2
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 8000be8:	6ca9      	ldr	r1, [r5, #72]	; 0x48
 8000bea:	f000 80d6 	beq.w	8000d9a <sdcConnect+0x3ca>
 8000bee:	684b      	ldr	r3, [r1, #4]

  switch (mode) {
 8000bf0:	2a01      	cmp	r2, #1
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 8000bf2:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800

  switch (mode) {
 8000bf6:	f000 80ce 	beq.w	8000d96 <sdcConnect+0x3c6>
 8000bfa:	f0c0 80c9 	bcc.w	8000d90 <sdcConnect+0x3c0>
 8000bfe:	2a02      	cmp	r2, #2
 8000c00:	f040 80c4 	bne.w	8000d8c <sdcConnect+0x3bc>
 *
 * @notapi
 */
static bool mmc_set_bus_width(SDCDriver *sdcp) {
  uint32_t resp[1];
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);
 8000c04:	4a51      	ldr	r2, [pc, #324]	; (8000d4c <sdcConnect+0x37c>)
    break;
  case SDC_MODE_4BIT:
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_0;
    break;
  case SDC_MODE_8BIT:
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_1;
 8000c06:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000c0a:	604b      	str	r3, [r1, #4]
    osalDbgAssert(false, "unexpected case");
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8000c0c:	1d3b      	adds	r3, r7, #4
 8000c0e:	4628      	mov	r0, r5
 8000c10:	2106      	movs	r1, #6
 8000c12:	f001 fabd 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000c16:	2800      	cmp	r0, #0
 8000c18:	f47f af0a 	bne.w	8000a30 <sdcConnect+0x60>
      MMCSD_R1_ERROR(resp[0])) {
 8000c1c:	687a      	ldr	r2, [r7, #4]
 8000c1e:	4b4a      	ldr	r3, [pc, #296]	; (8000d48 <sdcConnect+0x378>)
 8000c20:	4013      	ands	r3, r2
    osalDbgAssert(false, "unexpected case");
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8000c22:	2b00      	cmp	r3, #0
 8000c24:	f47f af04 	bne.w	8000a30 <sdcConnect+0x60>
    /* Unknown type.*/
    goto failed;
  }

  /* Initialization complete.*/
  sdcp->state = BLK_READY;
 8000c28:	2305      	movs	r3, #5
 8000c2a:	712b      	strb	r3, [r5, #4]
 8000c2c:	e707      	b.n	8000a3e <sdcConnect+0x6e>
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
      return HAL_FAILED;
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8000c2e:	4602      	mov	r2, r0
 8000c30:	2137      	movs	r1, #55	; 0x37
 8000c32:	4628      	mov	r0, r5
 8000c34:	1d3b      	adds	r3, r7, #4
 8000c36:	f001 faab 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000c3a:	2800      	cmp	r0, #0
 8000c3c:	f47f aef8 	bne.w	8000a30 <sdcConnect+0x60>
        MMCSD_R1_ERROR(resp[0])) {
 8000c40:	687a      	ldr	r2, [r7, #4]
 8000c42:	4b41      	ldr	r3, [pc, #260]	; (8000d48 <sdcConnect+0x378>)
 8000c44:	4013      	ands	r3, r2
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
      return HAL_FAILED;
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8000c46:	2b00      	cmp	r3, #0
 8000c48:	f47f aef2 	bne.w	8000a30 <sdcConnect+0x60>
 8000c4c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000c4e:	f003 030f 	and.w	r3, r3, #15
  if (HAL_FAILED == mode_detect(sdcp)) {
    goto failed;
  }

  /* Perform specific initialization procedure.*/
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_MMC) {
 8000c52:	2b02      	cmp	r3, #2
 8000c54:	f43f af3a 	beq.w	8000acc <sdcConnect+0xfc>

  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_SDV20) {
    ocr = 0xC0100000U;
  }
  else {
    ocr = 0x80100000U;
 8000c58:	493d      	ldr	r1, [pc, #244]	; (8000d50 <sdcConnect+0x380>)
 8000c5a:	4a3e      	ldr	r2, [pc, #248]	; (8000d54 <sdcConnect+0x384>)
 8000c5c:	2b01      	cmp	r3, #1
 8000c5e:	bf0c      	ite	eq
 8000c60:	4688      	moveq	r8, r1
 8000c62:	4690      	movne	r8, r2
 8000c64:	e70a      	b.n	8000a7c <sdcConnect+0xac>
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 8000c66:	6ca9      	ldr	r1, [r5, #72]	; 0x48
  switch(sdcp->config->bus_width){
  case SDC_MODE_1BIT:
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
  case SDC_MODE_4BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
 8000c68:	4a3b      	ldr	r2, [pc, #236]	; (8000d58 <sdcConnect+0x388>)
 8000c6a:	684b      	ldr	r3, [r1, #4]
 8000c6c:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
  switch (mode) {
  case SDC_MODE_1BIT:
    sdcp->sdio->CLKCR = clk;
    break;
  case SDC_MODE_4BIT:
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_0;
 8000c70:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000c74:	604b      	str	r3, [r1, #4]
 8000c76:	e7c9      	b.n	8000c0c <sdcConnect+0x23c>
 * @notapi
 */
static bool sdc_set_bus_width(SDCDriver *sdcp) {
  uint32_t resp[1];

  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
 8000c78:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8000c7a:	791b      	ldrb	r3, [r3, #4]
 8000c7c:	2b00      	cmp	r3, #0
 8000c7e:	d0d3      	beq.n	8000c28 <sdcConnect+0x258>
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
 8000c80:	2b01      	cmp	r3, #1
 8000c82:	f47f aed5 	bne.w	8000a30 <sdcConnect+0x60>
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 8000c86:	6ca9      	ldr	r1, [r5, #72]	; 0x48
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8000c88:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8000c8a:	684b      	ldr	r3, [r1, #4]
 8000c8c:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
  switch (mode) {
  case SDC_MODE_1BIT:
    sdcp->sdio->CLKCR = clk;
    break;
  case SDC_MODE_4BIT:
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_0;
 8000c90:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000c94:	604b      	str	r3, [r1, #4]
 8000c96:	4628      	mov	r0, r5
 8000c98:	2137      	movs	r1, #55	; 0x37
 8000c9a:	1d3b      	adds	r3, r7, #4
 8000c9c:	f001 fa78 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000ca0:	2800      	cmp	r0, #0
 8000ca2:	f47f aec5 	bne.w	8000a30 <sdcConnect+0x60>
        MMCSD_R1_ERROR(resp[0])) {
 8000ca6:	687a      	ldr	r2, [r7, #4]
 8000ca8:	4b27      	ldr	r3, [pc, #156]	; (8000d48 <sdcConnect+0x378>)
 8000caa:	4013      	ands	r3, r2
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8000cac:	2b00      	cmp	r3, #0
 8000cae:	f47f aebf 	bne.w	8000a30 <sdcConnect+0x60>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
    }

    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8000cb2:	1d3b      	adds	r3, r7, #4
 8000cb4:	4628      	mov	r0, r5
 8000cb6:	2106      	movs	r1, #6
 8000cb8:	2202      	movs	r2, #2
 8000cba:	f001 fa69 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000cbe:	2800      	cmp	r0, #0
 8000cc0:	d0ac      	beq.n	8000c1c <sdcConnect+0x24c>
 8000cc2:	e6b5      	b.n	8000a30 <sdcConnect+0x60>

  /* Reads extended CSD if needed and possible.*/
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {

    /* The card is a MMC, checking if it is a large device.*/
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 8000cc4:	217f      	movs	r1, #127	; 0x7f
 8000cc6:	227e      	movs	r2, #126	; 0x7e
 8000cc8:	f7ff fb92 	bl	80003f0 <_mmcsd_get_slice>
 8000ccc:	2801      	cmp	r0, #1
 8000cce:	d958      	bls.n	8000d82 <sdcConnect+0x3b2>
      uint8_t *ext_csd = sdcp->config->scratchpad;
 8000cd0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8000cd2:	681e      	ldr	r6, [r3, #0]

      /* Size detection requires the buffer.*/
      if (NULL == ext_csd) {
 8000cd4:	2e00      	cmp	r6, #0
 8000cd6:	f43f aeac 	beq.w	8000a32 <sdcConnect+0x62>
        goto failed;
      }

      if(sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
 8000cda:	2300      	movs	r3, #0
 8000cdc:	9300      	str	r3, [sp, #0]
 8000cde:	4628      	mov	r0, r5
 8000ce0:	4631      	mov	r1, r6
 8000ce2:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000ce6:	2308      	movs	r3, #8
 8000ce8:	f001 fc3a 	bl	8002560 <sdc_lld_read_special>
 8000cec:	2800      	cmp	r0, #0
 8000cee:	f47f ae9f 	bne.w	8000a30 <sdcConnect+0x60>
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
 8000cf2:	f896 10d6 	ldrb.w	r1, [r6, #214]	; 0xd6
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8000cf6:	f896 30d7 	ldrb.w	r3, [r6, #215]	; 0xd7
         ((uint32_t)ext_csd[214] << 16U) +
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
 8000cfa:	f896 20d4 	ldrb.w	r2, [r6, #212]	; 0xd4

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
         ((uint32_t)ext_csd[213] << 8U)  +
 8000cfe:	f896 00d5 	ldrb.w	r0, [r6, #213]	; 0xd5
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
 8000d02:	0409      	lsls	r1, r1, #16
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8000d04:	eb01 6303 	add.w	r3, r1, r3, lsl #24
 8000d08:	4413      	add	r3, r2
 8000d0a:	eb03 2300 	add.w	r3, r3, r0, lsl #8
        goto failed;
      }

      /* Capacity from the EXT_CSD.*/
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
 8000d0e:	62ab      	str	r3, [r5, #40]	; 0x28
 8000d10:	e74b      	b.n	8000baa <sdcConnect+0x1da>
    *clk = SDC_CLK_25MHz;
    return HAL_SUCCESS;
  }

  /* Read switch functions' register.*/
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
 8000d12:	f8cd 9000 	str.w	r9, [sp]
 8000d16:	4628      	mov	r0, r5
 8000d18:	4621      	mov	r1, r4
 8000d1a:	2240      	movs	r2, #64	; 0x40
 8000d1c:	2306      	movs	r3, #6
 8000d1e:	f001 fc1f 	bl	8002560 <sdc_lld_read_special>
 8000d22:	b970      	cbnz	r0, 8000d42 <sdcConnect+0x372>
static uint16_t sdc_cmd6_extract_info(sd_switch_function_t function,
                                      const uint8_t *buf) {

  unsigned start = 12U - ((unsigned)function * 2U);

  return ((uint16_t)buf[start] << 8U) | (uint16_t)buf[start + 1U];
 8000d24:	7b63      	ldrb	r3, [r4, #13]
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
    return HAL_FAILED;
  }

  /* Check card capabilities parsing acquired data.*/
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
 8000d26:	079b      	lsls	r3, r3, #30
 8000d28:	f57f af2f 	bpl.w	8000b8a <sdcConnect+0x1ba>
    /* Construct command to set the bus speed.*/
    cmdarg = sdc_cmd6_construct(SD_SWITCH_SET, SD_SWITCH_FUNCTION_SPEED, 1);

    /* Write constructed command and read operation status in single call.*/
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
 8000d2c:	4b0b      	ldr	r3, [pc, #44]	; (8000d5c <sdcConnect+0x38c>)
 8000d2e:	9300      	str	r3, [sp, #0]
 8000d30:	4621      	mov	r1, r4
 8000d32:	4628      	mov	r0, r5
 8000d34:	2240      	movs	r2, #64	; 0x40
 8000d36:	2306      	movs	r3, #6
 8000d38:	f001 fc12 	bl	8002560 <sdc_lld_read_special>
 8000d3c:	2800      	cmp	r0, #0
 8000d3e:	f43f af24 	beq.w	8000b8a <sdcConnect+0x1ba>
 8000d42:	46c5      	mov	sp, r8
 8000d44:	e674      	b.n	8000a30 <sdcConnect+0x60>
 8000d46:	bf00      	nop
 8000d48:	fdffe008 	.word	0xfdffe008
 8000d4c:	03b70000 	.word	0x03b70000
 8000d50:	c0100000 	.word	0xc0100000
 8000d54:	80100000 	.word	0x80100000
 8000d58:	03b70100 	.word	0x03b70100
 8000d5c:	80fffff1 	.word	0x80fffff1
 8000d60:	c0ff8000 	.word	0xc0ff8000
 * @notapi
 */
static bool mmc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
  uint32_t cmdarg;
  uint32_t resp[1];
  uint8_t *scratchpad = sdcp->config->scratchpad;
 8000d64:	6aea      	ldr	r2, [r5, #44]	; 0x2c

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;

  /* Use safe default when there is no space for data.*/
  if (NULL == scratchpad) {
 8000d66:	6812      	ldr	r2, [r2, #0]
 8000d68:	2a00      	cmp	r2, #0
 8000d6a:	f43f af12 	beq.w	8000b92 <sdcConnect+0x1c2>
    return HAL_SUCCESS;
  }

  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8000d6e:	1d3b      	adds	r3, r7, #4
 8000d70:	4628      	mov	r0, r5
 8000d72:	2106      	movs	r1, #6
 8000d74:	4a0b      	ldr	r2, [pc, #44]	; (8000da4 <sdcConnect+0x3d4>)
 8000d76:	f001 fa0b 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 8000d7a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000d7c:	f003 030f 	and.w	r3, r3, #15
 8000d80:	e707      	b.n	8000b92 <sdcConnect+0x1c2>
      /* Capacity from the EXT_CSD.*/
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
    }
    else {
      /* Capacity from the normal CSD.*/
      sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8000d82:	4630      	mov	r0, r6
 8000d84:	f7ff fb5c 	bl	8000440 <_mmcsd_get_capacity>
 8000d88:	62a8      	str	r0, [r5, #40]	; 0x28
 8000d8a:	e70e      	b.n	8000baa <sdcConnect+0x1da>
 *
 * @notapi
 */
static bool mmc_set_bus_width(SDCDriver *sdcp) {
  uint32_t resp[1];
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);
 8000d8c:	4a06      	ldr	r2, [pc, #24]	; (8000da8 <sdcConnect+0x3d8>)
 8000d8e:	e73d      	b.n	8000c0c <sdcConnect+0x23c>
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;

  switch (mode) {
  case SDC_MODE_1BIT:
    sdcp->sdio->CLKCR = clk;
 8000d90:	604b      	str	r3, [r1, #4]
 8000d92:	4a05      	ldr	r2, [pc, #20]	; (8000da8 <sdcConnect+0x3d8>)
 8000d94:	e73a      	b.n	8000c0c <sdcConnect+0x23c>
 8000d96:	4a04      	ldr	r2, [pc, #16]	; (8000da8 <sdcConnect+0x3d8>)
 8000d98:	e76a      	b.n	8000c70 <sdcConnect+0x2a0>
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 8000d9a:	684b      	ldr	r3, [r1, #4]
    return HAL_SUCCESS;
  case SDC_MODE_4BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
    break;
  case SDC_MODE_8BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
 8000d9c:	4a03      	ldr	r2, [pc, #12]	; (8000dac <sdcConnect+0x3dc>)
 8000d9e:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
 8000da2:	e730      	b.n	8000c06 <sdcConnect+0x236>
 8000da4:	03b90100 	.word	0x03b90100
 8000da8:	03b70000 	.word	0x03b70000
 8000dac:	03b70200 	.word	0x03b70200

08000db0 <_sdc_wait_for_transfer_state>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8000db0:	b510      	push	{r4, lr}
 8000db2:	4604      	mov	r4, r0
 8000db4:	b082      	sub	sp, #8
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 8000db6:	ab01      	add	r3, sp, #4
 8000db8:	4620      	mov	r0, r4
 8000dba:	210d      	movs	r1, #13
 8000dbc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000dbe:	f001 f9e7 	bl	8002190 <sdc_lld_send_cmd_short_crc>
                                   sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
 8000dc2:	4b0a      	ldr	r3, [pc, #40]	; (8000dec <_sdc_wait_for_transfer_state+0x3c>)
 */
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 8000dc4:	b978      	cbnz	r0, 8000de6 <_sdc_wait_for_transfer_state+0x36>
                                   sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
 8000dc6:	9a01      	ldr	r2, [sp, #4]
 8000dc8:	4013      	ands	r3, r2
      return HAL_FAILED;
    }

    switch (MMCSD_R1_STS(resp[0])) {
 8000dca:	f3c2 2143 	ubfx	r1, r2, #9, #4
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
                                   sdcp->rca, resp) ||
 8000dce:	b94b      	cbnz	r3, 8000de4 <_sdc_wait_for_transfer_state+0x34>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
    }

    switch (MMCSD_R1_STS(resp[0])) {
 8000dd0:	2904      	cmp	r1, #4
 8000dd2:	d008      	beq.n	8000de6 <_sdc_wait_for_transfer_state+0x36>
 8000dd4:	f04f 000a 	mov.w	r0, #10
 8000dd8:	d304      	bcc.n	8000de4 <_sdc_wait_for_transfer_state+0x34>
 8000dda:	2907      	cmp	r1, #7
 8000ddc:	d802      	bhi.n	8000de4 <_sdc_wait_for_transfer_state+0x34>
 8000dde:	f7ff fde7 	bl	80009b0 <chThdSleep>
 8000de2:	e7e8      	b.n	8000db6 <_sdc_wait_for_transfer_state+0x6>

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
                                   sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8000de4:	2001      	movs	r0, #1
      /* The card should have been initialized so any other state is not
         valid and is reported as an error.*/
      return HAL_FAILED;
    }
  }
}
 8000de6:	b002      	add	sp, #8
 8000de8:	bd10      	pop	{r4, pc}
 8000dea:	bf00      	nop
 8000dec:	fdffe008 	.word	0xfdffe008

08000df0 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000df0:	2200      	movs	r2, #0
 8000df2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000df4:	4b08      	ldr	r3, [pc, #32]	; (8000e18 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000df6:	b410      	push	{r4}
 8000df8:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000dfa:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8000dfc:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000dfe:	689a      	ldr	r2, [r3, #8]
 8000e00:	428a      	cmp	r2, r1
 8000e02:	d2fb      	bcs.n	8000dfc <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000e04:	685a      	ldr	r2, [r3, #4]
 8000e06:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000e08:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 8000e0a:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8000e0c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8000e0e:	605c      	str	r4, [r3, #4]

  return tp;
}
 8000e10:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000e14:	4770      	bx	lr
 8000e16:	bf00      	nop
 8000e18:	20001140 	.word	0x20001140
 8000e1c:	00000000 	.word	0x00000000

08000e20 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8000e20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8000e22:	4d18      	ldr	r5, [pc, #96]	; (8000e84 <chMtxUnlock+0x64>)
 8000e24:	2320      	movs	r3, #32
 8000e26:	69ae      	ldr	r6, [r5, #24]
 8000e28:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000e2c:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8000e2e:	68c3      	ldr	r3, [r0, #12]
 8000e30:	63b3      	str	r3, [r6, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000e32:	42a0      	cmp	r0, r4
 8000e34:	d023      	beq.n	8000e7e <chMtxUnlock+0x5e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8000e36:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000e38:	b14b      	cbz	r3, 8000e4e <chMtxUnlock+0x2e>
 8000e3a:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000e3c:	4293      	cmp	r3, r2
 8000e3e:	d003      	beq.n	8000e48 <chMtxUnlock+0x28>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8000e40:	6892      	ldr	r2, [r2, #8]
 8000e42:	4291      	cmp	r1, r2
 8000e44:	bf38      	it	cc
 8000e46:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8000e48:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000e4a:	2b00      	cmp	r3, #0
 8000e4c:	d1f5      	bne.n	8000e3a <chMtxUnlock+0x1a>
 8000e4e:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000e50:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8000e52:	6ba7      	ldr	r7, [r4, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8000e54:	60b1      	str	r1, [r6, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8000e56:	4620      	mov	r0, r4
 8000e58:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000e5a:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8000e5c:	609c      	str	r4, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8000e5e:	60df      	str	r7, [r3, #12]
      tp->p_mtxlist = mp;
 8000e60:	63a3      	str	r3, [r4, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8000e62:	f7ff ffc5 	bl	8000df0 <chSchReadyI>
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8000e66:	682a      	ldr	r2, [r5, #0]
 8000e68:	69ab      	ldr	r3, [r5, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000e6a:	6892      	ldr	r2, [r2, #8]
 8000e6c:	689b      	ldr	r3, [r3, #8]
 8000e6e:	429a      	cmp	r2, r3
 8000e70:	d901      	bls.n	8000e76 <chMtxUnlock+0x56>
    chSchDoRescheduleAhead();
 8000e72:	f7ff fb85 	bl	8000580 <chSchDoRescheduleAhead>
 8000e76:	2300      	movs	r3, #0
 8000e78:	f383 8811 	msr	BASEPRI, r3
 8000e7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      chSchRescheduleS();
    }
    else {
      mp->m_owner = NULL;
 8000e7e:	2300      	movs	r3, #0
 8000e80:	6083      	str	r3, [r0, #8]
 8000e82:	e7f8      	b.n	8000e76 <chMtxUnlock+0x56>
 8000e84:	20001140 	.word	0x20001140
	...

08000e90 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000e90:	4b30      	ldr	r3, [pc, #192]	; (8000f54 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000e92:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8000e94:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8000e96:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000e98:	2a00      	cmp	r2, #0
 8000e9a:	d055      	beq.n	8000f48 <chMtxLockS+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000e9c:	68a1      	ldr	r1, [r4, #8]
 8000e9e:	6893      	ldr	r3, [r2, #8]
 8000ea0:	4299      	cmp	r1, r3
 8000ea2:	4605      	mov	r5, r0
 8000ea4:	d906      	bls.n	8000eb4 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000ea6:	7f13      	ldrb	r3, [r2, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8000ea8:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000eaa:	2b06      	cmp	r3, #6
 8000eac:	d033      	beq.n	8000f16 <chMtxLockS+0x86>
 8000eae:	2b07      	cmp	r3, #7
 8000eb0:	d01d      	beq.n	8000eee <chMtxLockS+0x5e>
 8000eb2:	b19b      	cbz	r3, 8000edc <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000eb4:	462b      	mov	r3, r5
 8000eb6:	e003      	b.n	8000ec0 <chMtxLockS+0x30>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000eb8:	6899      	ldr	r1, [r3, #8]
 8000eba:	68a2      	ldr	r2, [r4, #8]
 8000ebc:	4291      	cmp	r1, r2
 8000ebe:	d302      	bcc.n	8000ec6 <chMtxLockS+0x36>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000ec0:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000ec2:	429d      	cmp	r5, r3
 8000ec4:	d1f8      	bne.n	8000eb8 <chMtxLockS+0x28>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000ec6:	685a      	ldr	r2, [r3, #4]
 8000ec8:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000eca:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8000ecc:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8000ece:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 8000ed0:	6225      	str	r5, [r4, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8000ed2:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 8000ed4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8000ed8:	f7ff bbd2 	b.w	8000680 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000edc:	e892 000a 	ldmia.w	r2, {r1, r3}
 8000ee0:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000ee2:	6811      	ldr	r1, [r2, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8000ee4:	4610      	mov	r0, r2
 8000ee6:	604b      	str	r3, [r1, #4]
 8000ee8:	f7ff ff82 	bl	8000df0 <chSchReadyI>
 8000eec:	e7e2      	b.n	8000eb4 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000eee:	e892 0009 	ldmia.w	r2, {r0, r3}
 8000ef2:	6018      	str	r0, [r3, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8000ef4:	6a16      	ldr	r6, [r2, #32]
  tp->p_next->p_prev = tp->p_prev;
 8000ef6:	6810      	ldr	r0, [r2, #0]
 8000ef8:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000efa:	4633      	mov	r3, r6
 8000efc:	e002      	b.n	8000f04 <chMtxLockS+0x74>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000efe:	6898      	ldr	r0, [r3, #8]
 8000f00:	4288      	cmp	r0, r1
 8000f02:	d302      	bcc.n	8000f0a <chMtxLockS+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000f04:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000f06:	429e      	cmp	r6, r3
 8000f08:	d1f9      	bne.n	8000efe <chMtxLockS+0x6e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000f0a:	6859      	ldr	r1, [r3, #4]
 8000f0c:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000f0e:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8000f10:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 8000f12:	605a      	str	r2, [r3, #4]
 8000f14:	e7ce      	b.n	8000eb4 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000f16:	e892 0009 	ldmia.w	r2, {r0, r3}
 8000f1a:	6018      	str	r0, [r3, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8000f1c:	6a16      	ldr	r6, [r2, #32]
  tp->p_next->p_prev = tp->p_prev;
 8000f1e:	6810      	ldr	r0, [r2, #0]
 8000f20:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000f22:	4633      	mov	r3, r6
 8000f24:	e002      	b.n	8000f2c <chMtxLockS+0x9c>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000f26:	6898      	ldr	r0, [r3, #8]
 8000f28:	4288      	cmp	r0, r1
 8000f2a:	d302      	bcc.n	8000f32 <chMtxLockS+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000f2c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000f2e:	429e      	cmp	r6, r3
 8000f30:	d1f9      	bne.n	8000f26 <chMtxLockS+0x96>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000f32:	6859      	ldr	r1, [r3, #4]
 8000f34:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000f36:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8000f38:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 8000f3a:	605a      	str	r2, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 8000f3c:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000f3e:	68a1      	ldr	r1, [r4, #8]
 8000f40:	6893      	ldr	r3, [r2, #8]
 8000f42:	428b      	cmp	r3, r1
 8000f44:	d3af      	bcc.n	8000ea6 <chMtxLockS+0x16>
 8000f46:	e7b5      	b.n	8000eb4 <chMtxLockS+0x24>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8000f48:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000f4a:	60c3      	str	r3, [r0, #12]
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8000f4c:	6084      	str	r4, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 8000f4e:	63a0      	str	r0, [r4, #56]	; 0x38
 8000f50:	bd70      	pop	{r4, r5, r6, pc}
 8000f52:	bf00      	nop
 8000f54:	20001140 	.word	0x20001140
	...

08000f60 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8000f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
 8000f62:	f850 7c08 	ldr.w	r7, [r0, #-8]
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8000f66:	4606      	mov	r6, r0

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8000f68:	f107 0508 	add.w	r5, r7, #8
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8000f6c:	f1a0 0408 	sub.w	r4, r0, #8
 8000f70:	2320      	movs	r3, #32
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8000f72:	3710      	adds	r7, #16
 8000f74:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8000f78:	4638      	mov	r0, r7
 8000f7a:	f7ff ff89 	bl	8000e90 <chMtxLockS>
 8000f7e:	2300      	movs	r3, #0
 8000f80:	f383 8811 	msr	BASEPRI, r3

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8000f84:	462b      	mov	r3, r5

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8000f86:	42ab      	cmp	r3, r5
 8000f88:	d004      	beq.n	8000f94 <chHeapFree+0x34>
 8000f8a:	42a3      	cmp	r3, r4
 8000f8c:	d302      	bcc.n	8000f94 <chHeapFree+0x34>
 8000f8e:	681b      	ldr	r3, [r3, #0]
 8000f90:	42ab      	cmp	r3, r5
 8000f92:	d1fa      	bne.n	8000f8a <chHeapFree+0x2a>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8000f94:	681a      	ldr	r2, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8000f96:	b11a      	cbz	r2, 8000fa0 <chHeapFree+0x40>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8000f98:	4294      	cmp	r4, r2
 8000f9a:	d301      	bcc.n	8000fa0 <chHeapFree+0x40>
 8000f9c:	4613      	mov	r3, r2
 8000f9e:	e7f2      	b.n	8000f86 <chHeapFree+0x26>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8000fa0:	f856 1c04 	ldr.w	r1, [r6, #-4]
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8000fa4:	f846 2c08 	str.w	r2, [r6, #-8]
      qp->h.u.next = hp;
 8000fa8:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8000faa:	f101 0208 	add.w	r2, r1, #8
 8000fae:	f856 5c08 	ldr.w	r5, [r6, #-8]
 8000fb2:	18a0      	adds	r0, r4, r2
 8000fb4:	42a8      	cmp	r0, r5
 8000fb6:	d00a      	beq.n	8000fce <chHeapFree+0x6e>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8000fb8:	6859      	ldr	r1, [r3, #4]
 8000fba:	f101 0208 	add.w	r2, r1, #8
 8000fbe:	441a      	add	r2, r3
 8000fc0:	4294      	cmp	r4, r2
 8000fc2:	d00d      	beq.n	8000fe0 <chHeapFree+0x80>
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8000fc4:	4638      	mov	r0, r7

  return;
}
 8000fc6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8000fca:	f7ff bf29 	b.w	8000e20 <chMtxUnlock>
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8000fce:	6840      	ldr	r0, [r0, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8000fd0:	58a2      	ldr	r2, [r4, r2]
 8000fd2:	f846 2c08 	str.w	r2, [r6, #-8]
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8000fd6:	180a      	adds	r2, r1, r0
 8000fd8:	3208      	adds	r2, #8
 8000fda:	f846 2c04 	str.w	r2, [r6, #-4]
 8000fde:	e7eb      	b.n	8000fb8 <chHeapFree+0x58>
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
        qp->h.u.next = hp->h.u.next;
 8000fe0:	e916 0005 	ldmdb	r6, {r0, r2}
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8000fe4:	440a      	add	r2, r1
 8000fe6:	3208      	adds	r2, #8
        qp->h.u.next = hp->h.u.next;
 8000fe8:	6018      	str	r0, [r3, #0]
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8000fea:	605a      	str	r2, [r3, #4]
 8000fec:	e7ea      	b.n	8000fc4 <chHeapFree+0x64>
 8000fee:	bf00      	nop

08000ff0 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000ff0:	6803      	ldr	r3, [r0, #0]
 8000ff2:	b12b      	cbz	r3, 8001000 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8000ff4:	2200      	movs	r2, #0
 8000ff6:	6002      	str	r2, [r0, #0]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8000ff8:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8000ffa:	6219      	str	r1, [r3, #32]
    (void) chSchReadyI(tp);
 8000ffc:	f7ff bef8 	b.w	8000df0 <chSchReadyI>
 8001000:	4770      	bx	lr
 8001002:	bf00      	nop
	...

08001010 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001010:	b538      	push	{r3, r4, r5, lr}
 8001012:	2220      	movs	r2, #32
 8001014:	4603      	mov	r3, r0
 8001016:	f382 8811 	msr	BASEPRI, r2
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 800101a:	4a0e      	ldr	r2, [pc, #56]	; (8001054 <chThdExit+0x44>)
 800101c:	6994      	ldr	r4, [r2, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800101e:	6a60      	ldr	r0, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
 8001020:	6223      	str	r3, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001022:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8001026:	42a8      	cmp	r0, r5
 8001028:	d006      	beq.n	8001038 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 800102a:	6803      	ldr	r3, [r0, #0]
 800102c:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 800102e:	f7ff fedf 	bl	8000df0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001032:	6a60      	ldr	r0, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001034:	42a8      	cmp	r0, r5
 8001036:	d1f8      	bne.n	800102a <chThdExit+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8001038:	7f63      	ldrb	r3, [r4, #29]
 800103a:	079b      	lsls	r3, r3, #30
 800103c:	d104      	bne.n	8001048 <chThdExit+0x38>
    REG_REMOVE(tp);
 800103e:	6963      	ldr	r3, [r4, #20]
 8001040:	6922      	ldr	r2, [r4, #16]
 8001042:	611a      	str	r2, [r3, #16]
 8001044:	6922      	ldr	r2, [r4, #16]
 8001046:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001048:	200f      	movs	r0, #15
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 800104a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800104e:	f7ff bb17 	b.w	8000680 <chSchGoSleepS>
 8001052:	bf00      	nop
 8001054:	20001140 	.word	0x20001140
	...

08001060 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001060:	e7fe      	b.n	8001060 <BusFault_Handler>
 8001062:	bf00      	nop
	...

08001070 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001070:	e7fe      	b.n	8001070 <__default_exit>
 8001072:	bf00      	nop
	...

08001080 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001080:	4770      	bx	lr
 8001082:	bf00      	nop
	...

08001090 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8001090:	4770      	bx	lr
 8001092:	bf00      	nop
	...

080010a0 <sdc_lld_is_write_protected>:
bool sdc_lld_is_write_protected(SDCDriver *sdcp) {

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return false;
}
 80010a0:	2000      	movs	r0, #0
 80010a2:	4770      	bx	lr
	...

080010b0 <sdc_lld_is_card_inserted>:
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return true;
}
 80010b0:	2001      	movs	r0, #1
 80010b2:	4770      	bx	lr
	...

080010c0 <notify2.lto_priv.68>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 80010c0:	4a02      	ldr	r2, [pc, #8]	; (80010cc <notify2.lto_priv.68+0xc>)
 80010c2:	68d3      	ldr	r3, [r2, #12]
 80010c4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80010c8:	60d3      	str	r3, [r2, #12]
 80010ca:	4770      	bx	lr
 80010cc:	40004400 	.word	0x40004400

080010d0 <i2c_lld_serve_tx_end_irq.lto_priv.65>:
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80010d0:	f011 0f0c 	tst.w	r1, #12
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 80010d4:	b410      	push	{r4}
  I2C_TypeDef *dp = i2cp->i2c;
 80010d6:	6b44      	ldr	r4, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80010d8:	d114      	bne.n	8001104 <i2c_lld_serve_tx_end_irq.lto_priv.65+0x34>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 80010da:	6b02      	ldr	r2, [r0, #48]	; 0x30
 80010dc:	6813      	ldr	r3, [r2, #0]
 80010de:	6819      	ldr	r1, [r3, #0]
 80010e0:	f021 011f 	bic.w	r1, r1, #31
 80010e4:	6019      	str	r1, [r3, #0]
 80010e6:	6819      	ldr	r1, [r3, #0]
 80010e8:	07c9      	lsls	r1, r1, #31
 80010ea:	d4fc      	bmi.n	80010e6 <i2c_lld_serve_tx_end_irq.lto_priv.65+0x16>
 80010ec:	7a11      	ldrb	r1, [r2, #8]
 80010ee:	6852      	ldr	r2, [r2, #4]
 80010f0:	233d      	movs	r3, #61	; 0x3d
 80010f2:	408b      	lsls	r3, r1
 80010f4:	6013      	str	r3, [r2, #0]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 80010f6:	6863      	ldr	r3, [r4, #4]
 80010f8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80010fc:	6063      	str	r3, [r4, #4]
}
 80010fe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001102:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001104:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8001106:	4b02      	ldr	r3, [pc, #8]	; (8001110 <i2c_lld_serve_tx_end_irq.lto_priv.65+0x40>)
 8001108:	4a02      	ldr	r2, [pc, #8]	; (8001114 <i2c_lld_serve_tx_end_irq.lto_priv.65+0x44>)
 800110a:	62da      	str	r2, [r3, #44]	; 0x2c
 800110c:	e7fe      	b.n	800110c <i2c_lld_serve_tx_end_irq.lto_priv.65+0x3c>
 800110e:	bf00      	nop
 8001110:	20001140 	.word	0x20001140
 8001114:	08004440 	.word	0x08004440
	...

08001120 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001120:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8001124:	4d6a      	ldr	r5, [pc, #424]	; (80012d0 <VectorD8+0x1b0>)
 8001126:	6f6e      	ldr	r6, [r5, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8001128:	f8d6 a00c 	ldr.w	sl, [r6, #12]
  uint16_t sr = u->SR;
 800112c:	6833      	ldr	r3, [r6, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 800112e:	05da      	lsls	r2, r3, #23
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001130:	b082      	sub	sp, #8
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8001132:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8001134:	f100 8082 	bmi.w	800123c <VectorD8+0x11c>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001138:	2320      	movs	r3, #32
 800113a:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800113e:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001142:	d049      	beq.n	80011d8 <VectorD8+0xb8>
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8001144:	4f62      	ldr	r7, [pc, #392]	; (80012d0 <VectorD8+0x1b0>)

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001146:	f04f 0900 	mov.w	r9, #0
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 800114a:	f107 080c 	add.w	r8, r7, #12
 800114e:	e007      	b.n	8001160 <VectorD8+0x40>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8001150:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8001152:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 8001154:	d41c      	bmi.n	8001190 <VectorD8+0x70>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8001156:	6834      	ldr	r4, [r6, #0]
 8001158:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800115a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800115e:	d03b      	beq.n	80011d8 <VectorD8+0xb8>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8001160:	0723      	lsls	r3, r4, #28
 8001162:	d0f5      	beq.n	8001150 <VectorD8+0x30>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8001164:	f014 0f08 	tst.w	r4, #8
 8001168:	bf0c      	ite	eq
 800116a:	2000      	moveq	r0, #0
 800116c:	2080      	movne	r0, #128	; 0x80
  if (sr & USART_SR_PE)
 800116e:	07e1      	lsls	r1, r4, #31
    sts |= SD_PARITY_ERROR;
 8001170:	bf48      	it	mi
 8001172:	f040 0020 	orrmi.w	r0, r0, #32
  if (sr & USART_SR_FE)
 8001176:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 8001178:	bf48      	it	mi
 800117a:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
  if (sr & USART_SR_NE)
 800117e:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 8001180:	bf48      	it	mi
 8001182:	f440 7080 	orrmi.w	r0, r0, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001186:	f002 f853 	bl	8003230 <chEvtBroadcastFlagsI.constprop.46>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 800118a:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 800118c:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 800118e:	d5e2      	bpl.n	8001156 <VectorD8+0x36>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8001190:	696a      	ldr	r2, [r5, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001192:	2a00      	cmp	r2, #0
 8001194:	d042      	beq.n	800121c <VectorD8+0xfc>
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8001196:	6a29      	ldr	r1, [r5, #32]
 8001198:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800119a:	4291      	cmp	r1, r2
 800119c:	d047      	beq.n	800122e <VectorD8+0x10e>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 800119e:	696a      	ldr	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 80011a0:	1c48      	adds	r0, r1, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80011a2:	3201      	adds	r2, #1
 80011a4:	616a      	str	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 80011a6:	6228      	str	r0, [r5, #32]
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 80011a8:	700b      	strb	r3, [r1, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80011aa:	6a2a      	ldr	r2, [r5, #32]
 80011ac:	69eb      	ldr	r3, [r5, #28]
 80011ae:	429a      	cmp	r2, r3
 80011b0:	d301      	bcc.n	80011b6 <VectorD8+0x96>
    iqp->q_wrptr = iqp->q_buffer;
 80011b2:	69bb      	ldr	r3, [r7, #24]
 80011b4:	623b      	str	r3, [r7, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80011b6:	68eb      	ldr	r3, [r5, #12]
 80011b8:	4543      	cmp	r3, r8
 80011ba:	d0cc      	beq.n	8001156 <VectorD8+0x36>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80011bc:	681a      	ldr	r2, [r3, #0]
 80011be:	60fa      	str	r2, [r7, #12]
  (void) chSchReadyI(tp);
 80011c0:	4618      	mov	r0, r3
  tqp->p_next->p_prev = (thread_t *)tqp;
 80011c2:	f8c2 8004 	str.w	r8, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80011c6:	f8c3 9020 	str.w	r9, [r3, #32]
  (void) chSchReadyI(tp);
 80011ca:	f7ff fe11 	bl	8000df0 <chSchReadyI>
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 80011ce:	6834      	ldr	r4, [r6, #0]
 80011d0:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80011d2:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80011d6:	d1c3      	bne.n	8001160 <VectorD8+0x40>
 80011d8:	2300      	movs	r3, #0
 80011da:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 80011de:	f01a 0f80 	tst.w	sl, #128	; 0x80
 80011e2:	d001      	beq.n	80011e8 <VectorD8+0xc8>
 80011e4:	0622      	lsls	r2, r4, #24
 80011e6:	d437      	bmi.n	8001258 <VectorD8+0x138>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 80011e8:	0663      	lsls	r3, r4, #25
 80011ea:	d512      	bpl.n	8001212 <VectorD8+0xf2>
 80011ec:	2320      	movs	r3, #32
 80011ee:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80011f2:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 80011f4:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80011f6:	4936      	ldr	r1, [pc, #216]	; (80012d0 <VectorD8+0x1b0>)
 80011f8:	429a      	cmp	r2, r3
 80011fa:	d054      	beq.n	80012a6 <VectorD8+0x186>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80011fc:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8001200:	ea0a 0303 	and.w	r3, sl, r3
    u->SR = ~USART_SR_TC;
 8001204:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001208:	60f3      	str	r3, [r6, #12]
 800120a:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 800120c:	6032      	str	r2, [r6, #0]
 800120e:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
}
 8001212:	b002      	add	sp, #8
 8001214:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 8001218:	f7ff b9d2 	b.w	80005c0 <_port_irq_epilogue>
 800121c:	2004      	movs	r0, #4
 800121e:	9301      	str	r3, [sp, #4]
 8001220:	f002 f806 	bl	8003230 <chEvtBroadcastFlagsI.constprop.46>
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8001224:	6a29      	ldr	r1, [r5, #32]
 8001226:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8001228:	9b01      	ldr	r3, [sp, #4]
 800122a:	4291      	cmp	r1, r2
 800122c:	d1b7      	bne.n	800119e <VectorD8+0x7e>
 800122e:	697a      	ldr	r2, [r7, #20]
 8001230:	2a00      	cmp	r2, #0
 8001232:	d0b4      	beq.n	800119e <VectorD8+0x7e>
 8001234:	2080      	movs	r0, #128	; 0x80
 8001236:	f001 fffb 	bl	8003230 <chEvtBroadcastFlagsI.constprop.46>
 800123a:	e78c      	b.n	8001156 <VectorD8+0x36>
 800123c:	2320      	movs	r3, #32
 800123e:	f383 8811 	msr	BASEPRI, r3
 8001242:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001246:	f001 fff3 	bl	8003230 <chEvtBroadcastFlagsI.constprop.46>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 800124a:	f46f 7380 	mvn.w	r3, #256	; 0x100
 800124e:	6033      	str	r3, [r6, #0]
 8001250:	2300      	movs	r3, #0
 8001252:	f383 8811 	msr	BASEPRI, r3
 8001256:	e76f      	b.n	8001138 <VectorD8+0x18>
 8001258:	2320      	movs	r3, #32
 800125a:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800125e:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8001260:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8001262:	491b      	ldr	r1, [pc, #108]	; (80012d0 <VectorD8+0x1b0>)
 8001264:	429a      	cmp	r2, r3
 8001266:	d025      	beq.n	80012b4 <VectorD8+0x194>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8001268:	6baa      	ldr	r2, [r5, #56]	; 0x38
 800126a:	4919      	ldr	r1, [pc, #100]	; (80012d0 <VectorD8+0x1b0>)
  b = *oqp->q_rdptr++;
 800126c:	1c58      	adds	r0, r3, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 800126e:	3201      	adds	r2, #1
 8001270:	63aa      	str	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8001272:	64a8      	str	r0, [r5, #72]	; 0x48
 8001274:	781f      	ldrb	r7, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8001276:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8001278:	4298      	cmp	r0, r3
 800127a:	d301      	bcc.n	8001280 <VectorD8+0x160>
    oqp->q_rdptr = oqp->q_buffer;
 800127c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 800127e:	648b      	str	r3, [r1, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001280:	4913      	ldr	r1, [pc, #76]	; (80012d0 <VectorD8+0x1b0>)
 8001282:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8001284:	f101 0230 	add.w	r2, r1, #48	; 0x30
 8001288:	4293      	cmp	r3, r2
 800128a:	d007      	beq.n	800129c <VectorD8+0x17c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800128c:	6818      	ldr	r0, [r3, #0]
 800128e:	6308      	str	r0, [r1, #48]	; 0x30

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001290:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001292:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 8001294:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001296:	6219      	str	r1, [r3, #32]
  (void) chSchReadyI(tp);
 8001298:	f7ff fdaa 	bl	8000df0 <chSchReadyI>
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 800129c:	6077      	str	r7, [r6, #4]
 800129e:	2300      	movs	r3, #0
 80012a0:	f383 8811 	msr	BASEPRI, r3
 80012a4:	e7a0      	b.n	80011e8 <VectorD8+0xc8>
 80012a6:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 80012a8:	2b00      	cmp	r3, #0
 80012aa:	d0a7      	beq.n	80011fc <VectorD8+0xdc>
 80012ac:	2010      	movs	r0, #16
 80012ae:	f001 ffbf 	bl	8003230 <chEvtBroadcastFlagsI.constprop.46>
 80012b2:	e7a3      	b.n	80011fc <VectorD8+0xdc>
 80012b4:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 80012b6:	2a00      	cmp	r2, #0
 80012b8:	d0d6      	beq.n	8001268 <VectorD8+0x148>
 80012ba:	2008      	movs	r0, #8
 80012bc:	f001 ffb8 	bl	8003230 <chEvtBroadcastFlagsI.constprop.46>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80012c0:	f64f 733f 	movw	r3, #65343	; 0xff3f
 80012c4:	ea0a 0303 	and.w	r3, sl, r3
 80012c8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80012cc:	60f3      	str	r3, [r6, #12]
 80012ce:	e7e6      	b.n	800129e <VectorD8+0x17e>
 80012d0:	200010c4 	.word	0x200010c4
	...

080012e0 <VectorC0>:

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 80012e0:	4834      	ldr	r0, [pc, #208]	; (80013b4 <VectorC0+0xd4>)
}

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 80012e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t sr = I2CD1.i2c->SR1;
 80012e4:	6b44      	ldr	r4, [r0, #52]	; 0x34
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80012e6:	6b07      	ldr	r7, [r0, #48]	; 0x30

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 80012e8:	6966      	ldr	r6, [r4, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80012ea:	683a      	ldr	r2, [r7, #0]

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 80012ec:	b2b1      	uxth	r1, r6

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 80012ee:	f401 435f 	and.w	r3, r1, #57088	; 0xdf00
 80012f2:	43db      	mvns	r3, r3
 80012f4:	6163      	str	r3, [r4, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80012f6:	6813      	ldr	r3, [r2, #0]
 80012f8:	f023 031f 	bic.w	r3, r3, #31
 80012fc:	6013      	str	r3, [r2, #0]
 80012fe:	6813      	ldr	r3, [r2, #0]
 8001300:	07db      	lsls	r3, r3, #31
 8001302:	d4fc      	bmi.n	80012fe <VectorC0+0x1e>
 8001304:	f897 e008 	ldrb.w	lr, [r7, #8]
  dmaStreamDisable(i2cp->dmarx);
 8001308:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800130a:	687f      	ldr	r7, [r7, #4]
  dmaStreamDisable(i2cp->dmarx);
 800130c:	682a      	ldr	r2, [r5, #0]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800130e:	233d      	movs	r3, #61	; 0x3d
 8001310:	fa03 f30e 	lsl.w	r3, r3, lr
 8001314:	603b      	str	r3, [r7, #0]
  dmaStreamDisable(i2cp->dmarx);
 8001316:	6813      	ldr	r3, [r2, #0]
 8001318:	f023 031f 	bic.w	r3, r3, #31
 800131c:	6013      	str	r3, [r2, #0]
 800131e:	6813      	ldr	r3, [r2, #0]
 8001320:	f013 0301 	ands.w	r3, r3, #1
 8001324:	d1fb      	bne.n	800131e <VectorC0+0x3e>
 8001326:	7a2f      	ldrb	r7, [r5, #8]
 8001328:	686d      	ldr	r5, [r5, #4]
 800132a:	223d      	movs	r2, #61	; 0x3d
 800132c:	40ba      	lsls	r2, r7

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 800132e:	05cf      	lsls	r7, r1, #23
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 8001330:	602a      	str	r2, [r5, #0]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 8001332:	bf48      	it	mi
 8001334:	2301      	movmi	r3, #1

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8001336:	058d      	lsls	r5, r1, #22
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 8001338:	6083      	str	r3, [r0, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;
 800133a:	bf44      	itt	mi
 800133c:	f043 0302 	orrmi.w	r3, r3, #2
 8001340:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8001342:	054a      	lsls	r2, r1, #21
 8001344:	d50a      	bpl.n	800135c <VectorC0+0x7c>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8001346:	6862      	ldr	r2, [r4, #4]
 8001348:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800134c:	6062      	str	r2, [r4, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800134e:	6822      	ldr	r2, [r4, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8001350:	f043 0304 	orr.w	r3, r3, #4
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8001354:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001358:	6022      	str	r2, [r4, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 800135a:	6083      	str	r3, [r0, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 800135c:	050f      	lsls	r7, r1, #20
    i2cp->errors |= I2C_OVERRUN;
 800135e:	bf44      	itt	mi
 8001360:	f043 0308 	orrmi.w	r3, r3, #8
 8001364:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8001366:	044d      	lsls	r5, r1, #17
    i2cp->errors |= I2C_TIMEOUT;
 8001368:	bf44      	itt	mi
 800136a:	f043 0320 	orrmi.w	r3, r3, #32
 800136e:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8001370:	04cc      	lsls	r4, r1, #19
 8001372:	d513      	bpl.n	800139c <VectorC0+0xbc>
    i2cp->errors |= I2C_PEC_ERROR;
 8001374:	f043 0310 	orr.w	r3, r3, #16

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8001378:	0431      	lsls	r1, r6, #16

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;
 800137a:	6083      	str	r3, [r0, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800137c:	d416      	bmi.n	80013ac <VectorC0+0xcc>
 800137e:	2320      	movs	r3, #32
 8001380:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8001384:	480c      	ldr	r0, [pc, #48]	; (80013b8 <VectorC0+0xd8>)
 8001386:	f06f 0101 	mvn.w	r1, #1
 800138a:	f7ff fe31 	bl	8000ff0 <chThdResumeI>
 800138e:	2300      	movs	r3, #0
 8001390:	f383 8811 	msr	BASEPRI, r3

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
}
 8001394:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8001398:	f7ff b912 	b.w	80005c0 <_port_irq_epilogue>
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800139c:	0432      	lsls	r2, r6, #16
 800139e:	d405      	bmi.n	80013ac <VectorC0+0xcc>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 80013a0:	2b00      	cmp	r3, #0
 80013a2:	d1ec      	bne.n	800137e <VectorC0+0x9e>

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
}
 80013a4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 80013a8:	f7ff b90a 	b.w	80005c0 <_port_irq_epilogue>

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
    i2cp->errors |= I2C_SMB_ALERT;
 80013ac:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80013b0:	6083      	str	r3, [r0, #8]
 80013b2:	e7e4      	b.n	800137e <VectorC0+0x9e>
 80013b4:	2000103c 	.word	0x2000103c
 80013b8:	20001058 	.word	0x20001058
 80013bc:	00000000 	.word	0x00000000

080013c0 <VectorBC>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80013c0:	483a      	ldr	r0, [pc, #232]	; (80014ac <VectorBC+0xec>)
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80013c2:	4a3b      	ldr	r2, [pc, #236]	; (80014b0 <VectorBC+0xf0>)
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 80013c4:	b570      	push	{r4, r5, r6, lr}
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80013c6:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t regSR2 = dp->SR2;
 80013c8:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 80013ca:	6965      	ldr	r5, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80013cc:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 80013d0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80013d4:	4293      	cmp	r3, r2
 80013d6:	d04c      	beq.n	8001472 <VectorBC+0xb2>
 80013d8:	d81e      	bhi.n	8001418 <VectorBC+0x58>
 80013da:	3a07      	subs	r2, #7
 80013dc:	4293      	cmp	r3, r2
 80013de:	d03c      	beq.n	800145a <VectorBC+0x9a>
 80013e0:	3201      	adds	r2, #1
 80013e2:	4293      	cmp	r3, r2
 80013e4:	d110      	bne.n	8001408 <VectorBC+0x48>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80013e6:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 80013e8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80013ea:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 80013ee:	681b      	ldr	r3, [r3, #0]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80013f0:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 80013f2:	681a      	ldr	r2, [r3, #0]
 80013f4:	f042 0201 	orr.w	r2, r2, #1
 80013f8:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 80013fa:	6862      	ldr	r2, [r4, #4]
 80013fc:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001400:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8001402:	685b      	ldr	r3, [r3, #4]
 8001404:	2b01      	cmp	r3, #1
 8001406:	d94b      	bls.n	80014a0 <VectorBC+0xe0>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8001408:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 800140c:	bf18      	it	ne
 800140e:	69a3      	ldrne	r3, [r4, #24]
  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
}
 8001410:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 8001414:	f7ff b8d4 	b.w	80005c0 <_port_irq_epilogue>
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8001418:	4a26      	ldr	r2, [pc, #152]	; (80014b4 <VectorBC+0xf4>)
 800141a:	4293      	cmp	r3, r2
 800141c:	d012      	beq.n	8001444 <VectorBC+0x84>
 800141e:	3202      	adds	r2, #2
 8001420:	4293      	cmp	r3, r2
 8001422:	d1f1      	bne.n	8001408 <VectorBC+0x48>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8001424:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8001426:	681b      	ldr	r3, [r3, #0]
 8001428:	685e      	ldr	r6, [r3, #4]
 800142a:	b33e      	cbz	r6, 800147c <VectorBC+0xbc>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800142c:	6823      	ldr	r3, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800142e:	8c02      	ldrh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8001430:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8001434:	f042 0201 	orr.w	r2, r2, #1
 8001438:	8402      	strh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800143a:	6023      	str	r3, [r4, #0]
  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
}
 800143c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 8001440:	f7ff b8be 	b.w	80005c0 <_port_irq_epilogue>
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8001444:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8001446:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8001448:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 800144c:	6812      	ldr	r2, [r2, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800144e:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8001450:	6813      	ldr	r3, [r2, #0]
 8001452:	f043 0301 	orr.w	r3, r3, #1
 8001456:	6013      	str	r3, [r2, #0]
 8001458:	e7d6      	b.n	8001408 <VectorBC+0x48>
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 800145a:	8c03      	ldrh	r3, [r0, #32]
 800145c:	0a1a      	lsrs	r2, r3, #8
 800145e:	d00b      	beq.n	8001478 <VectorBC+0xb8>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 8001460:	f003 0301 	and.w	r3, r3, #1
 8001464:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8001468:	f002 0206 	and.w	r2, r2, #6
 800146c:	4313      	orrs	r3, r2
 800146e:	6123      	str	r3, [r4, #16]
 8001470:	e7ca      	b.n	8001408 <VectorBC+0x48>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8001472:	8c03      	ldrh	r3, [r0, #32]
 8001474:	f3c3 0347 	ubfx	r3, r3, #1, #8
 8001478:	6123      	str	r3, [r4, #16]
 800147a:	e7c5      	b.n	8001408 <VectorBC+0x48>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800147c:	6863      	ldr	r3, [r4, #4]
 800147e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001482:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8001484:	6823      	ldr	r3, [r4, #0]
 8001486:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800148a:	6023      	str	r3, [r4, #0]
 800148c:	2320      	movs	r3, #32
 800148e:	f383 8811 	msr	BASEPRI, r3
 8001492:	301c      	adds	r0, #28
 8001494:	4631      	mov	r1, r6
 8001496:	f7ff fdab 	bl	8000ff0 <chThdResumeI>
 800149a:	f386 8811 	msr	BASEPRI, r6
 800149e:	e7b3      	b.n	8001408 <VectorBC+0x48>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 80014a0:	6823      	ldr	r3, [r4, #0]
 80014a2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80014a6:	6023      	str	r3, [r4, #0]
 80014a8:	e7ae      	b.n	8001408 <VectorBC+0x48>
 80014aa:	bf00      	nop
 80014ac:	2000103c 	.word	0x2000103c
 80014b0:	00030008 	.word	0x00030008
 80014b4:	00070082 	.word	0x00070082
	...

080014c0 <i2c_lld_serve_rx_end_irq.lto_priv.64>:
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80014c0:	f011 0f0c 	tst.w	r1, #12
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;
 80014c4:	6b43      	ldr	r3, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80014c6:	d125      	bne.n	8001514 <i2c_lld_serve_rx_end_irq.lto_priv.64+0x54>
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 80014c8:	b570      	push	{r4, r5, r6, lr}
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 80014ca:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80014cc:	6829      	ldr	r1, [r5, #0]
 80014ce:	680a      	ldr	r2, [r1, #0]
 80014d0:	f022 021f 	bic.w	r2, r2, #31
 80014d4:	600a      	str	r2, [r1, #0]
 80014d6:	680a      	ldr	r2, [r1, #0]
 80014d8:	f012 0401 	ands.w	r4, r2, #1
 80014dc:	d1fb      	bne.n	80014d6 <i2c_lld_serve_rx_end_irq.lto_priv.64+0x16>
 80014de:	7a2e      	ldrb	r6, [r5, #8]
 80014e0:	6869      	ldr	r1, [r5, #4]
 80014e2:	223d      	movs	r2, #61	; 0x3d
 80014e4:	40b2      	lsls	r2, r6
 80014e6:	600a      	str	r2, [r1, #0]

  dp->CR2 &= ~I2C_CR2_LAST;
 80014e8:	685a      	ldr	r2, [r3, #4]
 80014ea:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80014ee:	605a      	str	r2, [r3, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 80014f0:	681a      	ldr	r2, [r3, #0]
 80014f2:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80014f6:	601a      	str	r2, [r3, #0]
  dp->CR1 |= I2C_CR1_STOP;
 80014f8:	681a      	ldr	r2, [r3, #0]
 80014fa:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80014fe:	601a      	str	r2, [r3, #0]
 8001500:	2320      	movs	r3, #32
 8001502:	f383 8811 	msr	BASEPRI, r3
 8001506:	301c      	adds	r0, #28
 8001508:	4621      	mov	r1, r4
 800150a:	f7ff fd71 	bl	8000ff0 <chThdResumeI>
 800150e:	f384 8811 	msr	BASEPRI, r4
 8001512:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001514:	b672      	cpsid	i
 8001516:	4b02      	ldr	r3, [pc, #8]	; (8001520 <i2c_lld_serve_rx_end_irq.lto_priv.64+0x60>)
 8001518:	4a02      	ldr	r2, [pc, #8]	; (8001524 <i2c_lld_serve_rx_end_irq.lto_priv.64+0x64>)
 800151a:	62da      	str	r2, [r3, #44]	; 0x2c
 800151c:	e7fe      	b.n	800151c <i2c_lld_serve_rx_end_irq.lto_priv.64+0x5c>
 800151e:	bf00      	nop
 8001520:	20001140 	.word	0x20001140
 8001524:	08004440 	.word	0x08004440
	...

08001530 <get_ldnumber.lto_priv.77>:
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;


	if (*path) {	/* If the pointer is not a null */
 8001530:	6801      	ldr	r1, [r0, #0]
 8001532:	b1b9      	cbz	r1, 8001564 <get_ldnumber.lto_priv.77+0x34>

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 8001534:	b410      	push	{r4}
	UINT i;
	int vol = -1;


	if (*path) {	/* If the pointer is not a null */
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8001536:	780c      	ldrb	r4, [r1, #0]
 8001538:	2c1f      	cmp	r4, #31
 800153a:	d909      	bls.n	8001550 <get_ldnumber.lto_priv.77+0x20>
 800153c:	2c3a      	cmp	r4, #58	; 0x3a
 800153e:	d00e      	beq.n	800155e <get_ldnumber.lto_priv.77+0x2e>
 8001540:	460a      	mov	r2, r1
 8001542:	e001      	b.n	8001548 <get_ldnumber.lto_priv.77+0x18>
 8001544:	2b3a      	cmp	r3, #58	; 0x3a
 8001546:	d007      	beq.n	8001558 <get_ldnumber.lto_priv.77+0x28>
 8001548:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800154c:	2b1f      	cmp	r3, #31
 800154e:	d8f9      	bhi.n	8001544 <get_ldnumber.lto_priv.77+0x14>
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 8001550:	2000      	movs	r0, #0
#endif
	}
	return vol;
}
 8001552:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001556:	4770      	bx	lr

	if (*path) {	/* If the pointer is not a null */
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
 8001558:	1c4b      	adds	r3, r1, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 800155a:	429a      	cmp	r2, r3
 800155c:	d005      	beq.n	800156a <get_ldnumber.lto_priv.77+0x3a>
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 800155e:	f04f 30ff 	mov.w	r0, #4294967295
 8001562:	e7f6      	b.n	8001552 <get_ldnumber.lto_priv.77+0x22>
 8001564:	f04f 30ff 	mov.w	r0, #4294967295
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 8001568:	4770      	bx	lr
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 800156a:	2c30      	cmp	r4, #48	; 0x30
 800156c:	d1f7      	bne.n	800155e <get_ldnumber.lto_priv.77+0x2e>
					vol = (int)i;
					*path = ++tt;
 800156e:	3102      	adds	r1, #2
 8001570:	6001      	str	r1, [r0, #0]

	if (*path) {	/* If the pointer is not a null */
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
 8001572:	2000      	movs	r0, #0
 8001574:	e7ed      	b.n	8001552 <get_ldnumber.lto_priv.77+0x22>
 8001576:	bf00      	nop
	...

08001580 <dir_next.lto_priv.59>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8001580:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	DWORD clst;
	UINT i;


	i = dp->index + 1;
 8001584:	88c4      	ldrh	r4, [r0, #6]
 8001586:	3401      	adds	r4, #1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 8001588:	b2a3      	uxth	r3, r4
 800158a:	b913      	cbnz	r3, 8001592 <dir_next.lto_priv.59+0x12>
		return FR_NO_FILE;
 800158c:	2004      	movs	r0, #4
 800158e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	DWORD clst;
	UINT i;


	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 8001592:	6903      	ldr	r3, [r0, #16]
 8001594:	2b00      	cmp	r3, #0
 8001596:	d0f9      	beq.n	800158c <dir_next.lto_priv.59+0xc>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
 8001598:	f014 080f 	ands.w	r8, r4, #15
 800159c:	460e      	mov	r6, r1
 800159e:	4605      	mov	r5, r0
 80015a0:	d008      	beq.n	80015b4 <dir_next.lto_priv.59+0x34>
 80015a2:	6807      	ldr	r7, [r0, #0]
				dp->sect = clust2sect(dp->fs, clst);
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
 80015a4:	80ec      	strh	r4, [r5, #6]
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Current entry in the window */
 80015a6:	eb07 1748 	add.w	r7, r7, r8, lsl #5
 80015aa:	3730      	adds	r7, #48	; 0x30
 80015ac:	616f      	str	r7, [r5, #20]

	return FR_OK;
 80015ae:	2000      	movs	r0, #0
 80015b0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
		dp->sect++;					/* Next sector */

		if (!dp->clust) {		/* Static table */
 80015b4:	68c1      	ldr	r1, [r0, #12]
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
 80015b6:	6807      	ldr	r7, [r0, #0]
	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
		dp->sect++;					/* Next sector */
 80015b8:	3301      	adds	r3, #1
 80015ba:	6103      	str	r3, [r0, #16]

		if (!dp->clust) {		/* Static table */
 80015bc:	b161      	cbz	r1, 80015d8 <dir_next.lto_priv.59+0x58>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
 80015be:	78bb      	ldrb	r3, [r7, #2]
 80015c0:	3b01      	subs	r3, #1
 80015c2:	ea13 1914 	ands.w	r9, r3, r4, lsr #4
 80015c6:	d1ed      	bne.n	80015a4 <dir_next.lto_priv.59+0x24>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 80015c8:	2901      	cmp	r1, #1
 80015ca:	d902      	bls.n	80015d2 <dir_next.lto_priv.59+0x52>
 80015cc:	697b      	ldr	r3, [r7, #20]
 80015ce:	4299      	cmp	r1, r3
 80015d0:	d306      	bcc.n	80015e0 <dir_next.lto_priv.59+0x60>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
 80015d2:	2002      	movs	r0, #2
 80015d4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
		dp->sect++;					/* Next sector */

		if (!dp->clust) {		/* Static table */
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
 80015d8:	893b      	ldrh	r3, [r7, #8]
 80015da:	429c      	cmp	r4, r3
 80015dc:	d2d6      	bcs.n	800158c <dir_next.lto_priv.59+0xc>
 80015de:	e7e1      	b.n	80015a4 <dir_next.lto_priv.59+0x24>
 80015e0:	4638      	mov	r0, r7
 80015e2:	f002 fc25 	bl	8003e30 <get_fat.part.5.lto_priv.62>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
 80015e6:	2801      	cmp	r0, #1
 80015e8:	4682      	mov	sl, r0
 80015ea:	d9f2      	bls.n	80015d2 <dir_next.lto_priv.59+0x52>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 80015ec:	f1b0 3fff 	cmp.w	r0, #4294967295
 80015f0:	f000 8088 	beq.w	8001704 <dir_next.lto_priv.59+0x184>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
 80015f4:	682f      	ldr	r7, [r5, #0]
 80015f6:	697b      	ldr	r3, [r7, #20]
 80015f8:	4283      	cmp	r3, r0
 80015fa:	461a      	mov	r2, r3
 80015fc:	d90d      	bls.n	800161a <dir_next.lto_priv.59+0x9a>
 80015fe:	1e86      	subs	r6, r0, #2
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8001600:	3a02      	subs	r2, #2
 8001602:	4296      	cmp	r6, r2
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
 8001604:	f8c5 a00c 	str.w	sl, [r5, #12]
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8001608:	d204      	bcs.n	8001614 <dir_next.lto_priv.59+0x94>
	return clst * fs->csize + fs->database;
 800160a:	f897 9002 	ldrb.w	r9, [r7, #2]
 800160e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001610:	fb09 3906 	mla	r9, r9, r6, r3
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
				dp->sect = clust2sect(dp->fs, clst);
 8001614:	f8c5 9010 	str.w	r9, [r5, #16]
 8001618:	e7c4      	b.n	80015a4 <dir_next.lto_priv.59+0x24>
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
#if !_FS_READONLY
					UINT c;
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
 800161a:	2e00      	cmp	r6, #0
 800161c:	d0b6      	beq.n	800158c <dir_next.lto_priv.59+0xc>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
 800161e:	68ee      	ldr	r6, [r5, #12]
{
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
 8001620:	2e00      	cmp	r6, #0
 8001622:	d172      	bne.n	800170a <dir_next.lto_priv.59+0x18a>
		scl = fs->last_clust;			/* Get suggested start point */
 8001624:	f8d7 b00c 	ldr.w	fp, [r7, #12]
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8001628:	f1bb 0f00 	cmp.w	fp, #0
 800162c:	f000 8081 	beq.w	8001732 <dir_next.lto_priv.59+0x1b2>
 8001630:	455b      	cmp	r3, fp
 8001632:	bf98      	it	ls
 8001634:	f04f 0b01 	movls.w	fp, #1
 8001638:	46da      	mov	sl, fp
 800163a:	e014      	b.n	8001666 <dir_next.lto_priv.59+0xe6>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
 800163c:	f1bb 0f01 	cmp.w	fp, #1
 8001640:	f240 8094 	bls.w	800176c <dir_next.lto_priv.59+0x1ec>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8001644:	2b02      	cmp	r3, #2
 8001646:	d916      	bls.n	8001676 <dir_next.lto_priv.59+0xf6>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
 8001648:	f04f 0a02 	mov.w	sl, #2
 800164c:	4651      	mov	r1, sl
 800164e:	f002 fbef 	bl	8003e30 <get_fat.part.5.lto_priv.62>
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
 8001652:	2800      	cmp	r0, #0
 8001654:	d070      	beq.n	8001738 <dir_next.lto_priv.59+0x1b8>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 8001656:	1c41      	adds	r1, r0, #1
 8001658:	d00e      	beq.n	8001678 <dir_next.lto_priv.59+0xf8>
 800165a:	2801      	cmp	r0, #1
 800165c:	d00b      	beq.n	8001676 <dir_next.lto_priv.59+0xf6>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
 800165e:	45da      	cmp	sl, fp
 8001660:	f000 8084 	beq.w	800176c <dir_next.lto_priv.59+0x1ec>
 8001664:	697b      	ldr	r3, [r7, #20]
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
 8001666:	f10a 0a01 	add.w	sl, sl, #1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
 800166a:	459a      	cmp	sl, r3
 800166c:	4638      	mov	r0, r7
 800166e:	d2e5      	bcs.n	800163c <dir_next.lto_priv.59+0xbc>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8001670:	f1ba 0f01 	cmp.w	sl, #1
 8001674:	d8ea      	bhi.n	800164c <dir_next.lto_priv.59+0xcc>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
 8001676:	2001      	movs	r0, #1
#if !_FS_READONLY
					UINT c;
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
 8001678:	2801      	cmp	r0, #1
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* Invalid value */
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 800167a:	4682      	mov	sl, r0
#if !_FS_READONLY
					UINT c;
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
 800167c:	d0a9      	beq.n	80015d2 <dir_next.lto_priv.59+0x52>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 800167e:	f1ba 3fff 	cmp.w	sl, #4294967295
 8001682:	d03f      	beq.n	8001704 <dir_next.lto_priv.59+0x184>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 8001684:	6828      	ldr	r0, [r5, #0]
{
	DWORD wsect;
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001686:	7903      	ldrb	r3, [r0, #4]
 8001688:	2b00      	cmp	r3, #0
 800168a:	d179      	bne.n	8001780 <dir_next.lto_priv.59+0x200>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
 800168c:	f100 0330 	add.w	r3, r0, #48	; 0x30
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
 8001690:	2200      	movs	r2, #0
 8001692:	f500 700c 	add.w	r0, r0, #560	; 0x230
 8001696:	f803 2b01 	strb.w	r2, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 800169a:	4283      	cmp	r3, r0
 800169c:	d1fb      	bne.n	8001696 <dir_next.lto_priv.59+0x116>
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 800169e:	6828      	ldr	r0, [r5, #0]
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80016a0:	6943      	ldr	r3, [r0, #20]
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 80016a2:	f1aa 0602 	sub.w	r6, sl, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80016a6:	3b02      	subs	r3, #2
 80016a8:	429e      	cmp	r6, r3
	return clst * fs->csize + fs->database;
 80016aa:	bf3b      	ittet	cc
 80016ac:	6a83      	ldrcc	r3, [r0, #40]	; 0x28
 80016ae:	7882      	ldrbcc	r2, [r0, #2]
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80016b0:	2300      	movcs	r3, #0
	return clst * fs->csize + fs->database;
 80016b2:	fb02 3306 	mlacc	r3, r2, r6, r3
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 80016b6:	62c3      	str	r3, [r0, #44]	; 0x2c
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80016b8:	f04f 0b00 	mov.w	fp, #0
						dp->fs->wflag = 1;
 80016bc:	2701      	movs	r7, #1
 80016be:	e004      	b.n	80016ca <dir_next.lto_priv.59+0x14a>
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
 80016c0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80016c2:	3301      	adds	r3, #1
 80016c4:	62c3      	str	r3, [r0, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80016c6:	f10b 0b01 	add.w	fp, fp, #1
 80016ca:	7883      	ldrb	r3, [r0, #2]
 80016cc:	459b      	cmp	fp, r3
 80016ce:	d250      	bcs.n	8001772 <dir_next.lto_priv.59+0x1f2>
						dp->fs->wflag = 1;
 80016d0:	7107      	strb	r7, [r0, #4]
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 80016d2:	6828      	ldr	r0, [r5, #0]
{
	DWORD wsect;
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80016d4:	7903      	ldrb	r3, [r0, #4]
 80016d6:	2b00      	cmp	r3, #0
 80016d8:	d0f2      	beq.n	80016c0 <dir_next.lto_priv.59+0x140>
 80016da:	f002 fc11 	bl	8003f00 <sync_window.part.1.lto_priv.56>
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 80016de:	b988      	cbnz	r0, 8001704 <dir_next.lto_priv.59+0x184>
 80016e0:	6828      	ldr	r0, [r5, #0]
 80016e2:	e7ed      	b.n	80016c0 <dir_next.lto_priv.59+0x140>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 80016e4:	2e01      	cmp	r6, #1
 80016e6:	f67f af74 	bls.w	80015d2 <dir_next.lto_priv.59+0x52>
 80016ea:	697b      	ldr	r3, [r7, #20]
 80016ec:	429e      	cmp	r6, r3
 80016ee:	f4bf af70 	bcs.w	80015d2 <dir_next.lto_priv.59+0x52>
 80016f2:	4631      	mov	r1, r6
 80016f4:	4638      	mov	r0, r7
 80016f6:	4652      	mov	r2, sl
 80016f8:	f002 fb22 	bl	8003d40 <put_fat.part.6.lto_priv.63>

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
 80016fc:	b350      	cbz	r0, 8001754 <dir_next.lto_priv.59+0x1d4>
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag |= 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 80016fe:	2801      	cmp	r0, #1
 8001700:	f47f af67 	bne.w	80015d2 <dir_next.lto_priv.59+0x52>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8001704:	2001      	movs	r0, #1
 8001706:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 800170a:	2e01      	cmp	r6, #1
 800170c:	f67f af61 	bls.w	80015d2 <dir_next.lto_priv.59+0x52>
 8001710:	42b3      	cmp	r3, r6
 8001712:	f67f af5e 	bls.w	80015d2 <dir_next.lto_priv.59+0x52>
 8001716:	4638      	mov	r0, r7
 8001718:	4631      	mov	r1, r6
 800171a:	f002 fb89 	bl	8003e30 <get_fat.part.5.lto_priv.62>
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* Invalid value */
 800171e:	2801      	cmp	r0, #1
 8001720:	f67f af57 	bls.w	80015d2 <dir_next.lto_priv.59+0x52>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 8001724:	1c43      	adds	r3, r0, #1
 8001726:	d0ed      	beq.n	8001704 <dir_next.lto_priv.59+0x184>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8001728:	697b      	ldr	r3, [r7, #20]
 800172a:	4298      	cmp	r0, r3
 800172c:	d3a4      	bcc.n	8001678 <dir_next.lto_priv.59+0xf8>
 800172e:	46b3      	mov	fp, r6
 8001730:	e782      	b.n	8001638 <dir_next.lto_priv.59+0xb8>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8001732:	f04f 0b01 	mov.w	fp, #1
 8001736:	e77f      	b.n	8001638 <dir_next.lto_priv.59+0xb8>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8001738:	697b      	ldr	r3, [r7, #20]
 800173a:	4553      	cmp	r3, sl
 800173c:	f67f af49 	bls.w	80015d2 <dir_next.lto_priv.59+0x52>
 8001740:	4638      	mov	r0, r7
 8001742:	4651      	mov	r1, sl
 8001744:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 8001748:	f002 fafa 	bl	8003d40 <put_fat.part.6.lto_priv.63>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
 800174c:	2800      	cmp	r0, #0
 800174e:	d1d6      	bne.n	80016fe <dir_next.lto_priv.59+0x17e>
 8001750:	2e00      	cmp	r6, #0
 8001752:	d1c7      	bne.n	80016e4 <dir_next.lto_priv.59+0x164>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
 8001754:	693b      	ldr	r3, [r7, #16]
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
 8001756:	f8c7 a00c 	str.w	sl, [r7, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
 800175a:	1c5a      	adds	r2, r3, #1
 800175c:	d08f      	beq.n	800167e <dir_next.lto_priv.59+0xfe>
			fs->free_clust--;
			fs->fsi_flag |= 1;
 800175e:	797a      	ldrb	r2, [r7, #5]
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
 8001760:	3b01      	subs	r3, #1
			fs->fsi_flag |= 1;
 8001762:	f042 0201 	orr.w	r2, r2, #1
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
 8001766:	613b      	str	r3, [r7, #16]
			fs->fsi_flag |= 1;
 8001768:	717a      	strb	r2, [r7, #5]
 800176a:	e788      	b.n	800167e <dir_next.lto_priv.59+0xfe>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
#if !_FS_READONLY
					UINT c;
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800176c:	2007      	movs	r0, #7
 800176e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
 8001772:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8001774:	6942      	ldr	r2, [r0, #20]
 8001776:	ebcb 0303 	rsb	r3, fp, r3
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 800177a:	4607      	mov	r7, r0
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
 800177c:	62c3      	str	r3, [r0, #44]	; 0x2c
 800177e:	e73f      	b.n	8001600 <dir_next.lto_priv.59+0x80>
 8001780:	f002 fbbe 	bl	8003f00 <sync_window.part.1.lto_priv.56>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 8001784:	2800      	cmp	r0, #0
 8001786:	d1bd      	bne.n	8001704 <dir_next.lto_priv.59+0x184>
 8001788:	6828      	ldr	r0, [r5, #0]
 800178a:	e77f      	b.n	800168c <dir_next.lto_priv.59+0x10c>
 800178c:	0000      	movs	r0, r0
	...

08001790 <dir_sdi.lto_priv.60>:
static
FRESULT dir_sdi (
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
 8001790:	b570      	push	{r4, r5, r6, lr}
 8001792:	460d      	mov	r5, r1
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
 8001794:	6881      	ldr	r1, [r0, #8]
{
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
 8001796:	80c5      	strh	r5, [r0, #6]
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 8001798:	2901      	cmp	r1, #1
static
FRESULT dir_sdi (
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
 800179a:	4604      	mov	r4, r0
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 800179c:	d003      	beq.n	80017a6 <dir_sdi.lto_priv.60+0x16>
 800179e:	6800      	ldr	r0, [r0, #0]
 80017a0:	6943      	ldr	r3, [r0, #20]
 80017a2:	4299      	cmp	r1, r3
 80017a4:	d301      	bcc.n	80017aa <dir_sdi.lto_priv.60+0x1a>
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
 80017a6:	2002      	movs	r0, #2
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;
}
 80017a8:	bd70      	pop	{r4, r5, r6, pc}

	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 80017aa:	b9c1      	cbnz	r1, 80017de <dir_sdi.lto_priv.60+0x4e>
 80017ac:	7802      	ldrb	r2, [r0, #0]
 80017ae:	2a03      	cmp	r2, #3
 80017b0:	d011      	beq.n	80017d6 <dir_sdi.lto_priv.60+0x46>
		clst = dp->fs->dirbase;

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
 80017b2:	8903      	ldrh	r3, [r0, #8]
 80017b4:	429d      	cmp	r5, r3
 80017b6:	d2f6      	bcs.n	80017a6 <dir_sdi.lto_priv.60+0x16>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
 80017b8:	6a43      	ldr	r3, [r0, #36]	; 0x24
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
 80017ba:	60e1      	str	r1, [r4, #12]
	if (!sect) return FR_INT_ERR;
 80017bc:	2b00      	cmp	r3, #0
 80017be:	d0f2      	beq.n	80017a6 <dir_sdi.lto_priv.60+0x16>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
 80017c0:	f005 020f 	and.w	r2, r5, #15
 80017c4:	eb00 1042 	add.w	r0, r0, r2, lsl #5
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
 80017c8:	eb03 1515 	add.w	r5, r3, r5, lsr #4
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
 80017cc:	3030      	adds	r0, #48	; 0x30
 80017ce:	6160      	str	r0, [r4, #20]
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
 80017d0:	6125      	str	r5, [r4, #16]
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;
 80017d2:	2000      	movs	r0, #0
 80017d4:	bd70      	pop	{r4, r5, r6, pc}
	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dp->fs->dirbase;
 80017d6:	6a42      	ldr	r2, [r0, #36]	; 0x24

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 80017d8:	2a00      	cmp	r2, #0
 80017da:	d0ea      	beq.n	80017b2 <dir_sdi.lto_priv.60+0x22>
 80017dc:	4611      	mov	r1, r2
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
 80017de:	7886      	ldrb	r6, [r0, #2]
 80017e0:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
 80017e2:	42b5      	cmp	r5, r6
 80017e4:	d20f      	bcs.n	8001806 <dir_sdi.lto_priv.60+0x76>
 80017e6:	e015      	b.n	8001814 <dir_sdi.lto_priv.60+0x84>
 80017e8:	f002 fb22 	bl	8003e30 <get_fat.part.5.lto_priv.62>
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80017ec:	1c43      	adds	r3, r0, #1
 80017ee:	4601      	mov	r1, r0
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
 80017f0:	eba5 0506 	sub.w	r5, r5, r6
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80017f4:	d017      	beq.n	8001826 <dir_sdi.lto_priv.60+0x96>
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
 80017f6:	2801      	cmp	r0, #1
 80017f8:	d9d5      	bls.n	80017a6 <dir_sdi.lto_priv.60+0x16>
 80017fa:	6820      	ldr	r0, [r4, #0]
 80017fc:	6943      	ldr	r3, [r0, #20]
 80017fe:	428b      	cmp	r3, r1
 8001800:	d9d1      	bls.n	80017a6 <dir_sdi.lto_priv.60+0x16>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
 8001802:	42ae      	cmp	r6, r5
 8001804:	d806      	bhi.n	8001814 <dir_sdi.lto_priv.60+0x84>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8001806:	2901      	cmp	r1, #1
 8001808:	d9cd      	bls.n	80017a6 <dir_sdi.lto_priv.60+0x16>
 800180a:	6943      	ldr	r3, [r0, #20]
 800180c:	428b      	cmp	r3, r1
 800180e:	d8eb      	bhi.n	80017e8 <dir_sdi.lto_priv.60+0x58>
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
 8001810:	2002      	movs	r0, #2
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;
}
 8001812:	bd70      	pop	{r4, r5, r6, pc}
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8001814:	3b02      	subs	r3, #2
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 8001816:	1e8a      	subs	r2, r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8001818:	429a      	cmp	r2, r3
 800181a:	d206      	bcs.n	800182a <dir_sdi.lto_priv.60+0x9a>
	return clst * fs->csize + fs->database;
 800181c:	7886      	ldrb	r6, [r0, #2]
 800181e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001820:	fb06 3302 	mla	r3, r6, r2, r3
 8001824:	e7c9      	b.n	80017ba <dir_sdi.lto_priv.60+0x2a>
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8001826:	2001      	movs	r0, #1
 8001828:	bd70      	pop	{r4, r5, r6, pc}
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
 800182a:	60e1      	str	r1, [r4, #12]
 800182c:	e7bb      	b.n	80017a6 <dir_sdi.lto_priv.60+0x16>
 800182e:	bf00      	nop

08001830 <follow_path.lto_priv.58>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8001830:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
 8001834:	780b      	ldrb	r3, [r1, #0]
 8001836:	2b2f      	cmp	r3, #47	; 0x2f
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8001838:	b083      	sub	sp, #12
 800183a:	460c      	mov	r4, r1
 800183c:	4605      	mov	r5, r0
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
 800183e:	f000 813a 	beq.w	8001ab6 <follow_path.lto_priv.58+0x286>
 8001842:	2b5c      	cmp	r3, #92	; 0x5c
 8001844:	f000 8137 	beq.w	8001ab6 <follow_path.lto_priv.58+0x286>
		path++;
	dp->sclust = 0;							/* Always start from the root directory */
 8001848:	2600      	movs	r6, #0
 800184a:	60ae      	str	r6, [r5, #8]
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 800184c:	7823      	ldrb	r3, [r4, #0]
 800184e:	2b1f      	cmp	r3, #31
 8001850:	f240 814b 	bls.w	8001aea <follow_path.lto_priv.58+0x2ba>
	if (chr < 0x80) {	/* ASCII */
		c = chr;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8001854:	f8df b2b8 	ldr.w	fp, [pc, #696]	; 8001b10 <follow_path.lto_priv.58+0x2e0>
 8001858:	e001      	b.n	800185e <follow_path.lto_priv.58+0x2e>
 800185a:	f814 3f01 	ldrb.w	r3, [r4, #1]!
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 800185e:	2b2f      	cmp	r3, #47	; 0x2f
 8001860:	d0fb      	beq.n	800185a <follow_path.lto_priv.58+0x2a>
 8001862:	2b5c      	cmp	r3, #92	; 0x5c
 8001864:	d0f9      	beq.n	800185a <follow_path.lto_priv.58+0x2a>
	lfn = dp->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
 8001866:	b299      	uxth	r1, r3
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 8001868:	291f      	cmp	r1, #31
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dp->lfn;
 800186a:	69e8      	ldr	r0, [r5, #28]
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 800186c:	f240 80ec 	bls.w	8001a48 <follow_path.lto_priv.58+0x218>
 8001870:	292f      	cmp	r1, #47	; 0x2f
 8001872:	d02d      	beq.n	80018d0 <follow_path.lto_priv.58+0xa0>
 8001874:	295c      	cmp	r1, #92	; 0x5c
 8001876:	d02b      	beq.n	80018d0 <follow_path.lto_priv.58+0xa0>
 8001878:	f1a0 0c02 	sub.w	ip, r0, #2
 800187c:	46a6      	mov	lr, r4
 800187e:	2701      	movs	r7, #1
 8001880:	e017      	b.n	80018b2 <follow_path.lto_priv.58+0x82>
 8001882:	3b80      	subs	r3, #128	; 0x80
 8001884:	f83b 1013 	ldrh.w	r1, [fp, r3, lsl #1]
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8001888:	b1f1      	cbz	r1, 80018c8 <follow_path.lto_priv.58+0x98>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
 800188a:	297f      	cmp	r1, #127	; 0x7f
 800188c:	d913      	bls.n	80018b6 <follow_path.lto_priv.58+0x86>
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
 800188e:	f82c 1f02 	strh.w	r1, [ip, #2]!
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dp->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
 8001892:	f81e 3f01 	ldrb.w	r3, [lr, #1]!
 8001896:	b299      	uxth	r1, r3
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 8001898:	291f      	cmp	r1, #31
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dp->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
 800189a:	f107 0201 	add.w	r2, r7, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 800189e:	f240 80d5 	bls.w	8001a4c <follow_path.lto_priv.58+0x21c>
 80018a2:	292f      	cmp	r1, #47	; 0x2f
 80018a4:	d016      	beq.n	80018d4 <follow_path.lto_priv.58+0xa4>
 80018a6:	295c      	cmp	r1, #92	; 0x5c
 80018a8:	d014      	beq.n	80018d4 <follow_path.lto_priv.58+0xa4>
		if (di >= _MAX_LFN)				/* Reject too long name */
 80018aa:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80018ae:	d00b      	beq.n	80018c8 <follow_path.lto_priv.58+0x98>
 80018b0:	4617      	mov	r7, r2
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 80018b2:	297f      	cmp	r1, #127	; 0x7f
 80018b4:	d8e5      	bhi.n	8001882 <follow_path.lto_priv.58+0x52>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 80018b6:	2922      	cmp	r1, #34	; 0x22
 80018b8:	d006      	beq.n	80018c8 <follow_path.lto_priv.58+0x98>
 80018ba:	4a91      	ldr	r2, [pc, #580]	; (8001b00 <follow_path.lto_priv.58+0x2d0>)
 80018bc:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80018c0:	2b00      	cmp	r3, #0
 80018c2:	d0e4      	beq.n	800188e <follow_path.lto_priv.58+0x5e>
 80018c4:	4299      	cmp	r1, r3
 80018c6:	d1f9      	bne.n	80018bc <follow_path.lto_priv.58+0x8c>
			}
		}
		dp->fn[i++] = (BYTE)w;
	}

	if (dp->fn[0] == DDE) dp->fn[0] = NDDE;	/* If the first character collides with deleted mark, replace it with 0x05 */
 80018c8:	2006      	movs	r0, #6
			dp->sclust = ld_clust(dp->fs, dir);
		}
	}

	return res;
}
 80018ca:	b003      	add	sp, #12
 80018cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dp->lfn;
	si = di = 0;
 80018d0:	2700      	movs	r7, #0
	for (;;) {
		w = p[si++];					/* Get a character */
 80018d2:	2201      	movs	r2, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
	}
	*path = &p[si];						/* Return pointer to the next segment */
 80018d4:	4414      	add	r4, r2
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 80018d6:	2600      	movs	r6, #0
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
 80018d8:	2f00      	cmp	r7, #0
 80018da:	d0f5      	beq.n	80018c8 <follow_path.lto_priv.58+0x98>
 80018dc:	eb00 0247 	add.w	r2, r0, r7, lsl #1
		w = lfn[di-1];
 80018e0:	f832 3d02 	ldrh.w	r3, [r2, #-2]!
		if (w != ' ' && w != '.') break;
 80018e4:	2b20      	cmp	r3, #32
 80018e6:	d001      	beq.n	80018ec <follow_path.lto_priv.58+0xbc>
 80018e8:	2b2e      	cmp	r3, #46	; 0x2e
 80018ea:	d102      	bne.n	80018f2 <follow_path.lto_priv.58+0xc2>
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
 80018ec:	3f01      	subs	r7, #1
 80018ee:	d1f7      	bne.n	80018e0 <follow_path.lto_priv.58+0xb0>
 80018f0:	e7ea      	b.n	80018c8 <follow_path.lto_priv.58+0x98>
		w = lfn[di-1];
		if (w != ' ' && w != '.') break;
 80018f2:	463b      	mov	r3, r7
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
 80018f4:	69aa      	ldr	r2, [r5, #24]
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
 80018f6:	2100      	movs	r1, #0
 80018f8:	f820 1013 	strh.w	r1, [r0, r3, lsl #1]
 80018fc:	f102 070b 	add.w	r7, r2, #11
 8001900:	eb00 0e43 	add.w	lr, r0, r3, lsl #1
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
 8001904:	2120      	movs	r1, #32
 8001906:	f802 1b01 	strb.w	r1, [r2], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 800190a:	42ba      	cmp	r2, r7
 800190c:	d1fb      	bne.n	8001906 <follow_path.lto_priv.58+0xd6>
 800190e:	1e87      	subs	r7, r0, #2
 8001910:	2100      	movs	r1, #0
 8001912:	e000      	b.n	8001916 <follow_path.lto_priv.58+0xe6>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 8001914:	3101      	adds	r1, #1
 8001916:	f837 2f02 	ldrh.w	r2, [r7, #2]!
 800191a:	2a20      	cmp	r2, #32
 800191c:	d0fa      	beq.n	8001914 <follow_path.lto_priv.58+0xe4>
 800191e:	2a2e      	cmp	r2, #46	; 0x2e
 8001920:	d0f8      	beq.n	8001914 <follow_path.lto_priv.58+0xe4>
	if (si) cf |= NS_LOSS | NS_LFN;
 8001922:	b109      	cbz	r1, 8001928 <follow_path.lto_priv.58+0xf8>
 8001924:	f046 0603 	orr.w	r6, r6, #3
 8001928:	4677      	mov	r7, lr
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 800192a:	f837 ed02 	ldrh.w	lr, [r7, #-2]!
 800192e:	f1be 0f2e 	cmp.w	lr, #46	; 0x2e
 8001932:	d001      	beq.n	8001938 <follow_path.lto_priv.58+0x108>
 8001934:	3b01      	subs	r3, #1
 8001936:	d1f8      	bne.n	800192a <follow_path.lto_priv.58+0xfa>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 8001938:	f04f 0c00 	mov.w	ip, #0
 800193c:	46e2      	mov	sl, ip
 800193e:	f04f 0e08 	mov.w	lr, #8
 8001942:	9401      	str	r4, [sp, #4]
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
 8001944:	3101      	adds	r1, #1
		if (!w) break;					/* Break on end of the LFN */
 8001946:	b37a      	cbz	r2, 80019a8 <follow_path.lto_priv.58+0x178>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8001948:	2a20      	cmp	r2, #32
 800194a:	d01f      	beq.n	800198c <follow_path.lto_priv.58+0x15c>
 800194c:	2a2e      	cmp	r2, #46	; 0x2e
 800194e:	d01b      	beq.n	8001988 <follow_path.lto_priv.58+0x158>
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
 8001950:	45f4      	cmp	ip, lr
 8001952:	d220      	bcs.n	8001996 <follow_path.lto_priv.58+0x166>
 8001954:	428b      	cmp	r3, r1
 8001956:	d07c      	beq.n	8001a52 <follow_path.lto_priv.58+0x222>
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII character */
 8001958:	2a7f      	cmp	r2, #127	; 0x7f
 800195a:	f200 8087 	bhi.w	8001a6c <follow_path.lto_priv.58+0x23c>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 800195e:	2a2b      	cmp	r2, #43	; 0x2b
 8001960:	f000 809d 	beq.w	8001a9e <follow_path.lto_priv.58+0x26e>
 8001964:	4f67      	ldr	r7, [pc, #412]	; (8001b04 <follow_path.lto_priv.58+0x2d4>)
 8001966:	e002      	b.n	800196e <follow_path.lto_priv.58+0x13e>
 8001968:	42a2      	cmp	r2, r4
 800196a:	f000 8098 	beq.w	8001a9e <follow_path.lto_priv.58+0x26e>
 800196e:	f817 4f01 	ldrb.w	r4, [r7, #1]!
 8001972:	2c00      	cmp	r4, #0
 8001974:	d1f8      	bne.n	8001968 <follow_path.lto_priv.58+0x138>
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte character */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
 8001976:	f1a2 0441 	sub.w	r4, r2, #65	; 0x41
 800197a:	2c19      	cmp	r4, #25
 800197c:	f200 80ab 	bhi.w	8001ad6 <follow_path.lto_priv.58+0x2a6>
					b |= 2;
 8001980:	f04a 0a02 	orr.w	sl, sl, #2
 8001984:	b2d2      	uxtb	r2, r2
 8001986:	e08d      	b.n	8001aa4 <follow_path.lto_priv.58+0x274>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
		if (!w) break;					/* Break on end of the LFN */
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8001988:	428b      	cmp	r3, r1
 800198a:	d062      	beq.n	8001a52 <follow_path.lto_priv.58+0x222>
			cf |= NS_LOSS | NS_LFN; continue;
 800198c:	f046 0603 	orr.w	r6, r6, #3
 8001990:	f830 2011 	ldrh.w	r2, [r0, r1, lsl #1]
 8001994:	e7d6      	b.n	8001944 <follow_path.lto_priv.58+0x114>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
 8001996:	f1be 0f0b 	cmp.w	lr, #11
 800199a:	f000 808e 	beq.w	8001aba <follow_path.lto_priv.58+0x28a>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 800199e:	428b      	cmp	r3, r1
 80019a0:	d05a      	beq.n	8001a58 <follow_path.lto_priv.58+0x228>
 80019a2:	f046 0603 	orr.w	r6, r6, #3
			if (si > di) break;			/* No extension */
 80019a6:	d257      	bcs.n	8001a58 <follow_path.lto_priv.58+0x228>
			}
		}
		dp->fn[i++] = (BYTE)w;
	}

	if (dp->fn[0] == DDE) dp->fn[0] = NDDE;	/* If the first character collides with deleted mark, replace it with 0x05 */
 80019a8:	69ab      	ldr	r3, [r5, #24]
 80019aa:	9c01      	ldr	r4, [sp, #4]
 80019ac:	781a      	ldrb	r2, [r3, #0]
 80019ae:	2ae5      	cmp	r2, #229	; 0xe5
 80019b0:	f000 808d 	beq.w	8001ace <follow_path.lto_priv.58+0x29e>

	if (ni == 8) b <<= 2;
 80019b4:	f1be 0f08 	cmp.w	lr, #8
 80019b8:	bf04      	itt	eq
 80019ba:	ea4f 028a 	moveq.w	r2, sl, lsl #2
 80019be:	fa5f fa82 	uxtbeq.w	sl, r2
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
 80019c2:	f00a 020c 	and.w	r2, sl, #12
 80019c6:	2a0c      	cmp	r2, #12
 80019c8:	d072      	beq.n	8001ab0 <follow_path.lto_priv.58+0x280>
 80019ca:	f00a 0103 	and.w	r1, sl, #3
 80019ce:	2903      	cmp	r1, #3
 80019d0:	d06e      	beq.n	8001ab0 <follow_path.lto_priv.58+0x280>
		cf |= NS_LFN;
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 80019d2:	07b0      	lsls	r0, r6, #30
 80019d4:	d409      	bmi.n	80019ea <follow_path.lto_priv.58+0x1ba>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 80019d6:	f00a 0103 	and.w	r1, sl, #3
 80019da:	2901      	cmp	r1, #1
 80019dc:	bf08      	it	eq
 80019de:	f046 0610 	orreq.w	r6, r6, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 80019e2:	2a04      	cmp	r2, #4
 80019e4:	bf08      	it	eq
 80019e6:	f046 0608 	orreq.w	r6, r6, #8
	}

	dp->fn[NS] = cf;	/* SFN is created */
 80019ea:	72de      	strb	r6, [r3, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 80019ec:	4628      	mov	r0, r5
 80019ee:	2100      	movs	r1, #0
 80019f0:	f7ff fece 	bl	8001790 <dir_sdi.lto_priv.60>
	if (res != FR_OK) return res;
 80019f4:	b9b8      	cbnz	r0, 8001a26 <follow_path.lto_priv.58+0x1f6>
 80019f6:	4628      	mov	r0, r5
 80019f8:	f002 f8da 	bl	8003bb0 <dir_find.part.7.lto_priv.61>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NS];
 80019fc:	69ab      	ldr	r3, [r5, #24]
 80019fe:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
 8001a00:	b998      	cbnz	r0, 8001a2a <follow_path.lto_priv.58+0x1fa>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8001a02:	0759      	lsls	r1, r3, #29
 8001a04:	f53f af61 	bmi.w	80018ca <follow_path.lto_priv.58+0x9a>
			dir = dp->dir;						/* Follow the sub-directory */
 8001a08:	696b      	ldr	r3, [r5, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
 8001a0a:	7ada      	ldrb	r2, [r3, #11]
 8001a0c:	06d2      	lsls	r2, r2, #27
 8001a0e:	d572      	bpl.n	8001af6 <follow_path.lto_priv.58+0x2c6>
 8001a10:	682a      	ldr	r2, [r5, #0]
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8001a12:	7ed8      	ldrb	r0, [r3, #27]
	if (fs->fs_type == FS_FAT32)
 8001a14:	7811      	ldrb	r1, [r2, #0]
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8001a16:	7e9a      	ldrb	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32)
 8001a18:	2903      	cmp	r1, #3
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8001a1a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	if (fs->fs_type == FS_FAT32)
 8001a1e:	d00c      	beq.n	8001a3a <follow_path.lto_priv.58+0x20a>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
 8001a20:	60aa      	str	r2, [r5, #8]
 8001a22:	7823      	ldrb	r3, [r4, #0]
 8001a24:	e71b      	b.n	800185e <follow_path.lto_priv.58+0x2e>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NS];
 8001a26:	69ab      	ldr	r3, [r5, #24]
 8001a28:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
 8001a2a:	2804      	cmp	r0, #4
 8001a2c:	f47f af4d 	bne.w	80018ca <follow_path.lto_priv.58+0x9a>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8001a30:	f013 0f04 	tst.w	r3, #4
 8001a34:	bf08      	it	eq
 8001a36:	2005      	moveq	r0, #5
 8001a38:	e747      	b.n	80018ca <follow_path.lto_priv.58+0x9a>
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32)
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 8001a3a:	7d59      	ldrb	r1, [r3, #21]
 8001a3c:	7d1b      	ldrb	r3, [r3, #20]
 8001a3e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8001a42:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 8001a46:	e7eb      	b.n	8001a20 <follow_path.lto_priv.58+0x1f0>
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dp->lfn;
	si = di = 0;
 8001a48:	2700      	movs	r7, #0
	for (;;) {
		w = p[si++];					/* Get a character */
 8001a4a:	2201      	movs	r2, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
	}
	*path = &p[si];						/* Return pointer to the next segment */
 8001a4c:	4414      	add	r4, r2
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8001a4e:	2604      	movs	r6, #4
 8001a50:	e742      	b.n	80018d8 <follow_path.lto_priv.58+0xa8>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
 8001a52:	f1be 0f0b 	cmp.w	lr, #11
 8001a56:	d030      	beq.n	8001aba <follow_path.lto_priv.58+0x28a>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
 8001a58:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8001a5c:	fa5f fa8a 	uxtb.w	sl, sl
 8001a60:	4619      	mov	r1, r3
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8001a62:	f04f 0e0b 	mov.w	lr, #11
 8001a66:	f04f 0c08 	mov.w	ip, #8
 8001a6a:	e791      	b.n	8001990 <follow_path.lto_priv.58+0x160>
 8001a6c:	4f26      	ldr	r7, [pc, #152]	; (8001b08 <follow_path.lto_priv.58+0x2d8>)
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII character */
 8001a6e:	2400      	movs	r4, #0
 8001a70:	e001      	b.n	8001a76 <follow_path.lto_priv.58+0x246>
	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
 8001a72:	2c80      	cmp	r4, #128	; 0x80
 8001a74:	d041      	beq.n	8001afa <follow_path.lto_priv.58+0x2ca>
				if (chr == Tbl[c]) break;
 8001a76:	f837 8f02 	ldrh.w	r8, [r7, #2]!
 8001a7a:	4590      	cmp	r8, r2
 8001a7c:	fa1f f984 	uxth.w	r9, r4
 8001a80:	f104 0401 	add.w	r4, r4, #1
 8001a84:	d1f5      	bne.n	8001a72 <follow_path.lto_priv.58+0x242>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 8001a86:	4c21      	ldr	r4, [pc, #132]	; (8001b0c <follow_path.lto_priv.58+0x2dc>)
			}
			c = (c + 0x80) & 0xFF;
 8001a88:	f109 0280 	add.w	r2, r9, #128	; 0x80
 8001a8c:	fa14 f282 	uxtah	r2, r4, r2
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
 8001a90:	f046 0602 	orr.w	r6, r6, #2
		}

		if (w >= 0x80) {				/* Non ASCII character */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 8001a94:	f812 2c80 	ldrb.w	r2, [r2, #-128]
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte character */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 8001a98:	2a00      	cmp	r2, #0
 8001a9a:	f47f af60 	bne.w	800195e <follow_path.lto_priv.58+0x12e>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 8001a9e:	f046 0603 	orr.w	r6, r6, #3
 8001aa2:	225f      	movs	r2, #95	; 0x5f
						b |= 1; w -= 0x20;
					}
				}
			}
		}
		dp->fn[i++] = (BYTE)w;
 8001aa4:	69ac      	ldr	r4, [r5, #24]
 8001aa6:	f804 200c 	strb.w	r2, [r4, ip]
 8001aaa:	f10c 0c01 	add.w	ip, ip, #1
 8001aae:	e76f      	b.n	8001990 <follow_path.lto_priv.58+0x160>

	if (dp->fn[0] == DDE) dp->fn[0] = NDDE;	/* If the first character collides with deleted mark, replace it with 0x05 */

	if (ni == 8) b <<= 2;
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
		cf |= NS_LFN;
 8001ab0:	f046 0602 	orr.w	r6, r6, #2
 8001ab4:	e78d      	b.n	80019d2 <follow_path.lto_priv.58+0x1a2>
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
		path++;
 8001ab6:	3401      	adds	r4, #1
 8001ab8:	e6c6      	b.n	8001848 <follow_path.lto_priv.58+0x18>
			}
		}
		dp->fn[i++] = (BYTE)w;
	}

	if (dp->fn[0] == DDE) dp->fn[0] = NDDE;	/* If the first character collides with deleted mark, replace it with 0x05 */
 8001aba:	69ab      	ldr	r3, [r5, #24]
 8001abc:	9c01      	ldr	r4, [sp, #4]
 8001abe:	781a      	ldrb	r2, [r3, #0]
 8001ac0:	2ae5      	cmp	r2, #229	; 0xe5
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
 8001ac2:	f046 0603 	orr.w	r6, r6, #3
			}
		}
		dp->fn[i++] = (BYTE)w;
	}

	if (dp->fn[0] == DDE) dp->fn[0] = NDDE;	/* If the first character collides with deleted mark, replace it with 0x05 */
 8001ac6:	f47f af7c 	bne.w	80019c2 <follow_path.lto_priv.58+0x192>
 8001aca:	f04f 0e0b 	mov.w	lr, #11
 8001ace:	2205      	movs	r2, #5
 8001ad0:	701a      	strb	r2, [r3, #0]
 8001ad2:	69ab      	ldr	r3, [r5, #24]
 8001ad4:	e76e      	b.n	80019b4 <follow_path.lto_priv.58+0x184>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
					b |= 2;
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
 8001ad6:	f1a2 0461 	sub.w	r4, r2, #97	; 0x61
 8001ada:	2c19      	cmp	r4, #25
						b |= 1; w -= 0x20;
 8001adc:	bf97      	itett	ls
 8001ade:	3a20      	subls	r2, #32
 8001ae0:	b2d2      	uxtbhi	r2, r2
 8001ae2:	b2d2      	uxtbls	r2, r2
 8001ae4:	f04a 0a01 	orrls.w	sl, sl, #1
 8001ae8:	e7dc      	b.n	8001aa4 <follow_path.lto_priv.58+0x274>
		path++;
	dp->sclust = 0;							/* Always start from the root directory */
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
		res = dir_sdi(dp, 0);
 8001aea:	4628      	mov	r0, r5
 8001aec:	4631      	mov	r1, r6
 8001aee:	f7ff fe4f 	bl	8001790 <dir_sdi.lto_priv.60>
		dp->dir = 0;
 8001af2:	616e      	str	r6, [r5, #20]
 8001af4:	e6e9      	b.n	80018ca <follow_path.lto_priv.58+0x9a>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
 8001af6:	2005      	movs	r0, #5
 8001af8:	e6e7      	b.n	80018ca <follow_path.lto_priv.58+0x9a>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
 8001afa:	f046 0602 	orr.w	r6, r6, #2
 8001afe:	e7ce      	b.n	8001a9e <follow_path.lto_priv.58+0x26e>
 8001b00:	0800444c 	.word	0x0800444c
 8001b04:	08004458 	.word	0x08004458
 8001b08:	080042be 	.word	0x080042be
 8001b0c:	080043c0 	.word	0x080043c0
 8001b10:	080042c0 	.word	0x080042c0
	...

08001b20 <move_window.lto_priv.55>:
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
	if (sector != fs->winsect) {	/* Changed current window */
 8001b20:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001b22:	428a      	cmp	r2, r1
static
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
 8001b24:	b538      	push	{r3, r4, r5, lr}
	if (sector != fs->winsect) {	/* Changed current window */
 8001b26:	d01b      	beq.n	8001b60 <move_window.lto_priv.55+0x40>
{
	DWORD wsect;
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001b28:	7903      	ldrb	r3, [r0, #4]
 8001b2a:	460d      	mov	r5, r1
 8001b2c:	4604      	mov	r4, r0
 8001b2e:	b91b      	cbnz	r3, 8001b38 <move_window.lto_priv.55+0x18>
    BYTE *buff,        /* Data buffer to store read data */
    DWORD sector,    /* Sector address (LBA) */
    UINT count        /* Number of sectors to read (1..255) */
)
{
  switch (pdrv) {
 8001b30:	7863      	ldrb	r3, [r4, #1]
 8001b32:	b13b      	cbz	r3, 8001b44 <move_window.lto_priv.55+0x24>
#if !_FS_READONLY
		if (sync_window(fs) != FR_OK)
			return FR_DISK_ERR;
#endif
		if (disk_read(fs->drv, fs->win, sector, 1))
			return FR_DISK_ERR;
 8001b34:	2001      	movs	r0, #1
 8001b36:	bd38      	pop	{r3, r4, r5, pc}
 8001b38:	f002 f9e2 	bl	8003f00 <sync_window.part.1.lto_priv.56>
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
	if (sector != fs->winsect) {	/* Changed current window */
#if !_FS_READONLY
		if (sync_window(fs) != FR_OK)
 8001b3c:	2800      	cmp	r0, #0
 8001b3e:	d0f7      	beq.n	8001b30 <move_window.lto_priv.55+0x10>
			return FR_DISK_ERR;
#endif
		if (disk_read(fs->drv, fs->win, sector, 1))
			return FR_DISK_ERR;
 8001b40:	2001      	movs	r0, #1
 8001b42:	bd38      	pop	{r3, r4, r5, pc}
    if (mmcStopSequentialRead(&MMCD1))
        return RES_ERROR;
    return RES_OK;
#else
  case SDC:
    if (blkGetDriverState(&SDCD1) != BLK_READY)
 8001b44:	4807      	ldr	r0, [pc, #28]	; (8001b64 <move_window.lto_priv.55+0x44>)
 8001b46:	7903      	ldrb	r3, [r0, #4]
 8001b48:	2b05      	cmp	r3, #5
 8001b4a:	d1f3      	bne.n	8001b34 <move_window.lto_priv.55+0x14>
      return RES_NOTRDY;
    if (sdcRead(&SDCD1, sector, buff, count))
 8001b4c:	4629      	mov	r1, r5
 8001b4e:	f104 0230 	add.w	r2, r4, #48	; 0x30
 8001b52:	2301      	movs	r3, #1
 8001b54:	f000 fcb4 	bl	80024c0 <sdcRead>
 8001b58:	2800      	cmp	r0, #0
 8001b5a:	d1eb      	bne.n	8001b34 <move_window.lto_priv.55+0x14>
		fs->winsect = sector;
 8001b5c:	62e5      	str	r5, [r4, #44]	; 0x2c
	}

	return FR_OK;
}
 8001b5e:	bd38      	pop	{r3, r4, r5, pc}
		if (disk_read(fs->drv, fs->win, sector, 1))
			return FR_DISK_ERR;
		fs->winsect = sector;
	}

	return FR_OK;
 8001b60:	2000      	movs	r0, #0
 8001b62:	bd38      	pop	{r3, r4, r5, pc}
 8001b64:	20001078 	.word	0x20001078
	...

08001b70 <disk_status>:
    BYTE pdrv        /* Physical drive nmuber (0..) */
)
{
  DSTATUS stat;

  switch (pdrv) {
 8001b70:	b928      	cbnz	r0, 8001b7e <disk_status+0xe>
    return stat;
#else
  case SDC:
    stat = 0;
    /* It is initialized externally, just reads the status.*/
    if (blkGetDriverState(&SDCD1) != BLK_READY)
 8001b72:	4b04      	ldr	r3, [pc, #16]	; (8001b84 <disk_status+0x14>)
 8001b74:	7918      	ldrb	r0, [r3, #4]
    if (sdcIsWriteProtected(&SDCD1))
      stat |= STA_PROTECT;
    return stat;
#endif
  }
  return STA_NOINIT;
 8001b76:	3805      	subs	r0, #5
 8001b78:	bf18      	it	ne
 8001b7a:	2001      	movne	r0, #1
 8001b7c:	4770      	bx	lr
 8001b7e:	2001      	movs	r0, #1
}
 8001b80:	4770      	bx	lr
 8001b82:	bf00      	nop
 8001b84:	20001078 	.word	0x20001078
	...

08001b90 <__early_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001b90:	4928      	ldr	r1, [pc, #160]	; (8001c34 <__early_init+0xa4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001b92:	4b29      	ldr	r3, [pc, #164]	; (8001c38 <__early_init+0xa8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001b94:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001b98:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001b9c:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001b9e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001ba0:	680b      	ldr	r3, [r1, #0]
 8001ba2:	f043 0301 	orr.w	r3, r3, #1
 8001ba6:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001ba8:	680a      	ldr	r2, [r1, #0]
 8001baa:	4b22      	ldr	r3, [pc, #136]	; (8001c34 <__early_init+0xa4>)
 8001bac:	0792      	lsls	r2, r2, #30
 8001bae:	d5fb      	bpl.n	8001ba8 <__early_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001bb0:	689a      	ldr	r2, [r3, #8]
 8001bb2:	f022 0203 	bic.w	r2, r2, #3
 8001bb6:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001bb8:	689a      	ldr	r2, [r3, #8]
 8001bba:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001bbc:	4619      	mov	r1, r3
 8001bbe:	688b      	ldr	r3, [r1, #8]
 8001bc0:	4a1c      	ldr	r2, [pc, #112]	; (8001c34 <__early_init+0xa4>)
 8001bc2:	f013 030c 	ands.w	r3, r3, #12
 8001bc6:	d1fa      	bne.n	8001bbe <__early_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001bc8:	6811      	ldr	r1, [r2, #0]
 8001bca:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 8001bce:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001bd0:	6093      	str	r3, [r2, #8]
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001bd2:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8001bd4:	f043 0301 	orr.w	r3, r3, #1
 8001bd8:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001bda:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8001bdc:	4915      	ldr	r1, [pc, #84]	; (8001c34 <__early_init+0xa4>)
 8001bde:	0798      	lsls	r0, r3, #30
 8001be0:	d5fb      	bpl.n	8001bda <__early_init+0x4a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8001be2:	4b16      	ldr	r3, [pc, #88]	; (8001c3c <__early_init+0xac>)
 8001be4:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001be6:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001be8:	4a13      	ldr	r2, [pc, #76]	; (8001c38 <__early_init+0xa8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001bea:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001bee:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001bf0:	6853      	ldr	r3, [r2, #4]
 8001bf2:	0459      	lsls	r1, r3, #17
 8001bf4:	d5fc      	bpl.n	8001bf0 <__early_init+0x60>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001bf6:	490f      	ldr	r1, [pc, #60]	; (8001c34 <__early_init+0xa4>)
 8001bf8:	680a      	ldr	r2, [r1, #0]
 8001bfa:	4b0e      	ldr	r3, [pc, #56]	; (8001c34 <__early_init+0xa4>)
 8001bfc:	0192      	lsls	r2, r2, #6
 8001bfe:	d5fb      	bpl.n	8001bf8 <__early_init+0x68>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8001c00:	4a0f      	ldr	r2, [pc, #60]	; (8001c40 <__early_init+0xb0>)
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8001c02:	4910      	ldr	r1, [pc, #64]	; (8001c44 <__early_init+0xb4>)
 8001c04:	6099      	str	r1, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8001c06:	f240 7102 	movw	r1, #1794	; 0x702
 8001c0a:	6011      	str	r1, [r2, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8001c0c:	689a      	ldr	r2, [r3, #8]
 8001c0e:	f042 0202 	orr.w	r2, r2, #2
 8001c12:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001c14:	461a      	mov	r2, r3
 8001c16:	6893      	ldr	r3, [r2, #8]
 8001c18:	4906      	ldr	r1, [pc, #24]	; (8001c34 <__early_init+0xa4>)
 8001c1a:	f003 030c 	and.w	r3, r3, #12
 8001c1e:	2b08      	cmp	r3, #8
 8001c20:	d1f9      	bne.n	8001c16 <__early_init+0x86>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001c22:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8001c24:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001c28:	644b      	str	r3, [r1, #68]	; 0x44
 8001c2a:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 8001c2c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001c30:	664b      	str	r3, [r1, #100]	; 0x64
 8001c32:	4770      	bx	lr
 8001c34:	40023800 	.word	0x40023800
 8001c38:	40007000 	.word	0x40007000
 8001c3c:	07015410 	.word	0x07015410
 8001c40:	40023c00 	.word	0x40023c00
 8001c44:	38081000 	.word	0x38081000
	...

08001c50 <sdcGetInfo>:
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));

  if (sdcp->state != BLK_READY) {
 8001c50:	7903      	ldrb	r3, [r0, #4]
 8001c52:	2b05      	cmp	r3, #5
 8001c54:	d001      	beq.n	8001c5a <sdcGetInfo+0xa>
    return HAL_FAILED;
 8001c56:	2001      	movs	r0, #1

  bdip->blk_num = sdcp->capacity;
  bdip->blk_size = MMCSD_BLOCK_SIZE;

  return HAL_SUCCESS;
}
 8001c58:	4770      	bx	lr

  if (sdcp->state != BLK_READY) {
    return HAL_FAILED;
  }

  bdip->blk_num = sdcp->capacity;
 8001c5a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001c5c:	604b      	str	r3, [r1, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 8001c5e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001c62:	600b      	str	r3, [r1, #0]

  return HAL_SUCCESS;
 8001c64:	2000      	movs	r0, #0
 8001c66:	4770      	bx	lr
	...

08001c70 <sdcSync>:
bool sdcSync(SDCDriver *sdcp) {
  bool result;

  osalDbgCheck(sdcp != NULL);

  if (sdcp->state != BLK_READY) {
 8001c70:	7900      	ldrb	r0, [r0, #4]
  result = sdc_lld_sync(sdcp);

  /* Synchronization operation finished.*/
  sdcp->state = BLK_READY;
  return result;
}
 8001c72:	3805      	subs	r0, #5
 8001c74:	bf18      	it	ne
 8001c76:	2001      	movne	r0, #1
 8001c78:	4770      	bx	lr
 8001c7a:	bf00      	nop
 8001c7c:	0000      	movs	r0, r0
	...

08001c80 <sdcDisconnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcDisconnect(SDCDriver *sdcp) {
 8001c80:	b538      	push	{r3, r4, r5, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001c82:	2220      	movs	r2, #32
 8001c84:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck(sdcp != NULL);

  osalSysLock();
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");
  if (sdcp->state == BLK_ACTIVE) {
 8001c88:	7902      	ldrb	r2, [r0, #4]
 8001c8a:	2a02      	cmp	r2, #2
 8001c8c:	d012      	beq.n	8001cb4 <sdcDisconnect+0x34>
    osalSysUnlock();
    return HAL_SUCCESS;
  }
  sdcp->state = BLK_DISCONNECTING;
 8001c8e:	2304      	movs	r3, #4
 8001c90:	4604      	mov	r4, r0
 8001c92:	7103      	strb	r3, [r0, #4]
 8001c94:	2500      	movs	r5, #0
 8001c96:	f385 8811 	msr	BASEPRI, r5
  osalSysUnlock();

  /* Waits for eventual pending operations completion.*/
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8001c9a:	f7ff f889 	bl	8000db0 <_sdc_wait_for_transfer_state>
 *
 * @notapi
 */
void sdc_lld_stop_clk(SDCDriver *sdcp) {

  sdcp->sdio->CLKCR = 0;
 8001c9e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    sdc_lld_stop_clk(sdcp);
    sdcp->state = BLK_ACTIVE;
 8001ca0:	2202      	movs	r2, #2
  }
  sdcp->state = BLK_DISCONNECTING;
  osalSysUnlock();

  /* Waits for eventual pending operations completion.*/
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8001ca2:	b918      	cbnz	r0, 8001cac <sdcDisconnect+0x2c>
 8001ca4:	6058      	str	r0, [r3, #4]
  sdcp->sdio->POWER = 0;
 8001ca6:	6018      	str	r0, [r3, #0]
    return HAL_FAILED;
  }

  /* Card clock stopped.*/
  sdc_lld_stop_clk(sdcp);
  sdcp->state = BLK_ACTIVE;
 8001ca8:	7122      	strb	r2, [r4, #4]
  return HAL_SUCCESS;
}
 8001caa:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void sdc_lld_stop_clk(SDCDriver *sdcp) {

  sdcp->sdio->CLKCR = 0;
 8001cac:	605d      	str	r5, [r3, #4]
  sdcp->sdio->POWER = 0;
 8001cae:	601d      	str	r5, [r3, #0]
  osalSysUnlock();

  /* Waits for eventual pending operations completion.*/
  if (_sdc_wait_for_transfer_state(sdcp)) {
    sdc_lld_stop_clk(sdcp);
    sdcp->state = BLK_ACTIVE;
 8001cb0:	7122      	strb	r2, [r4, #4]
 8001cb2:	bd38      	pop	{r3, r4, r5, pc}
 8001cb4:	2000      	movs	r0, #0
 8001cb6:	f380 8811 	msr	BASEPRI, r0
 8001cba:	bd38      	pop	{r3, r4, r5, pc}
 8001cbc:	0000      	movs	r0, r0
	...

08001cc0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001cc0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001cc4:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8001cc8:	692b      	ldr	r3, [r5, #16]
 8001cca:	079b      	lsls	r3, r3, #30
 8001ccc:	d403      	bmi.n	8001cd6 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8001cce:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8001cd2:	f7fe bc75 	b.w	80005c0 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8001cd6:	2700      	movs	r7, #0
 8001cd8:	612f      	str	r7, [r5, #16]
 8001cda:	2620      	movs	r6, #32
 8001cdc:	f386 8811 	msr	BASEPRI, r6
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8001ce0:	f8df 9078 	ldr.w	r9, [pc, #120]	; 8001d5c <VectorB0+0x9c>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001ce4:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8001ce6:	f8d9 301c 	ldr.w	r3, [r9, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8001cea:	f8d9 e028 	ldr.w	lr, [r9, #40]	; 0x28
 8001cee:	689a      	ldr	r2, [r3, #8]
 8001cf0:	ebce 0001 	rsb	r0, lr, r1
 8001cf4:	4290      	cmp	r0, r2
 8001cf6:	f109 081c 	add.w	r8, r9, #28
 8001cfa:	d31c      	bcc.n	8001d36 <VectorB0+0x76>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001cfc:	6819      	ldr	r1, [r3, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8001cfe:	68dc      	ldr	r4, [r3, #12]
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8001d00:	4472      	add	r2, lr
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8001d02:	4541      	cmp	r1, r8
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8001d04:	f8c9 2028 	str.w	r2, [r9, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001d08:	f8c1 8004 	str.w	r8, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8001d0c:	f8c9 101c 	str.w	r1, [r9, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 8001d10:	60df      	str	r7, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001d12:	bf08      	it	eq
 8001d14:	60ef      	streq	r7, [r5, #12]
 8001d16:	f387 8811 	msr	BASEPRI, r7
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8001d1a:	6918      	ldr	r0, [r3, #16]
 8001d1c:	47a0      	blx	r4
 8001d1e:	f386 8811 	msr	BASEPRI, r6
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8001d22:	f8d9 301c 	ldr.w	r3, [r9, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001d26:	6a69      	ldr	r1, [r5, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8001d28:	f8d9 e028 	ldr.w	lr, [r9, #40]	; 0x28
 8001d2c:	689a      	ldr	r2, [r3, #8]
 8001d2e:	ebce 0001 	rsb	r0, lr, r1
 8001d32:	4282      	cmp	r2, r0
 8001d34:	d9e2      	bls.n	8001cfc <VectorB0+0x3c>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8001d36:	4543      	cmp	r3, r8
 8001d38:	d008      	beq.n	8001d4c <VectorB0+0x8c>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8001d3a:	4472      	add	r2, lr
 8001d3c:	1a52      	subs	r2, r2, r1
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001d3e:	2a01      	cmp	r2, #1
 8001d40:	bf98      	it	ls
 8001d42:	2202      	movls	r2, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001d44:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  }
  port_timer_set_alarm(now + delta);
 8001d48:	440a      	add	r2, r1
 8001d4a:	635a      	str	r2, [r3, #52]	; 0x34
 8001d4c:	2300      	movs	r3, #0
 8001d4e:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8001d52:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8001d56:	f7fe bc33 	b.w	80005c0 <_port_irq_epilogue>
 8001d5a:	bf00      	nop
 8001d5c:	20001140 	.word	0x20001140

08001d60 <Vector158>:
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001d60:	4b08      	ldr	r3, [pc, #32]	; (8001d84 <Vector158+0x24>)
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 8001d62:	4809      	ldr	r0, [pc, #36]	; (8001d88 <Vector158+0x28>)
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001d64:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 8001d66:	6f82      	ldr	r2, [r0, #120]	; 0x78
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001d68:	0d89      	lsrs	r1, r1, #22
 8001d6a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector158) {
 8001d6e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
 8001d70:	058c      	lsls	r4, r1, #22
 8001d72:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 8001d74:	b10a      	cbz	r2, 8001d7a <Vector158+0x1a>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8001d76:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8001d78:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001d7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001d7e:	f7fe bc1f 	b.w	80005c0 <_port_irq_epilogue>
 8001d82:	bf00      	nop
 8001d84:	40026400 	.word	0x40026400
 8001d88:	20000fb8 	.word	0x20000fb8
 8001d8c:	00000000 	.word	0x00000000

08001d90 <Vector154>:
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001d90:	4b08      	ldr	r3, [pc, #32]	; (8001db4 <Vector154+0x24>)
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 8001d92:	4809      	ldr	r0, [pc, #36]	; (8001db8 <Vector154+0x28>)
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001d94:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 8001d96:	6f02      	ldr	r2, [r0, #112]	; 0x70
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001d98:	0c09      	lsrs	r1, r1, #16
 8001d9a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector154) {
 8001d9e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
 8001da0:	040c      	lsls	r4, r1, #16
 8001da2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 8001da4:	b10a      	cbz	r2, 8001daa <Vector154+0x1a>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8001da6:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8001da8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001daa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001dae:	f7fe bc07 	b.w	80005c0 <_port_irq_epilogue>
 8001db2:	bf00      	nop
 8001db4:	40026400 	.word	0x40026400
 8001db8:	20000fb8 	.word	0x20000fb8
 8001dbc:	00000000 	.word	0x00000000

08001dc0 <Vector150>:
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001dc0:	4b08      	ldr	r3, [pc, #32]	; (8001de4 <Vector150+0x24>)
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 8001dc2:	4809      	ldr	r0, [pc, #36]	; (8001de8 <Vector150+0x28>)
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001dc4:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 8001dc6:	6e82      	ldr	r2, [r0, #104]	; 0x68
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001dc8:	0989      	lsrs	r1, r1, #6
 8001dca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector150) {
 8001dce:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
 8001dd0:	018c      	lsls	r4, r1, #6
 8001dd2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 8001dd4:	b10a      	cbz	r2, 8001dda <Vector150+0x1a>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8001dd6:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8001dd8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001dda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001dde:	f7fe bbef 	b.w	80005c0 <_port_irq_epilogue>
 8001de2:	bf00      	nop
 8001de4:	40026400 	.word	0x40026400
 8001de8:	20000fb8 	.word	0x20000fb8
 8001dec:	00000000 	.word	0x00000000

08001df0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 8001df0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001df2:	4b07      	ldr	r3, [pc, #28]	; (8001e10 <Vector130+0x20>)
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 8001df4:	4807      	ldr	r0, [pc, #28]	; (8001e14 <Vector130+0x24>)
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001df6:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 8001df8:	6e02      	ldr	r2, [r0, #96]	; 0x60
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001dfa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0;
 8001dfe:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 8001e00:	b10a      	cbz	r2, 8001e06 <Vector130+0x16>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 8001e02:	6e40      	ldr	r0, [r0, #100]	; 0x64
 8001e04:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001e06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001e0a:	f7fe bbd9 	b.w	80005c0 <_port_irq_epilogue>
 8001e0e:	bf00      	nop
 8001e10:	40026400 	.word	0x40026400
 8001e14:	20000fb8 	.word	0x20000fb8
	...

08001e20 <Vector12C>:
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001e20:	4b08      	ldr	r3, [pc, #32]	; (8001e44 <Vector12C+0x24>)
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 8001e22:	4809      	ldr	r0, [pc, #36]	; (8001e48 <Vector12C+0x28>)
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001e24:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 8001e26:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001e28:	0d89      	lsrs	r1, r1, #22
 8001e2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector12C) {
 8001e2e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
 8001e30:	058c      	lsls	r4, r1, #22
 8001e32:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 8001e34:	b10a      	cbz	r2, 8001e3a <Vector12C+0x1a>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8001e36:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8001e38:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001e3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001e3e:	f7fe bbbf 	b.w	80005c0 <_port_irq_epilogue>
 8001e42:	bf00      	nop
 8001e44:	40026400 	.word	0x40026400
 8001e48:	20000fb8 	.word	0x20000fb8
 8001e4c:	00000000 	.word	0x00000000

08001e50 <Vector128>:
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001e50:	4b08      	ldr	r3, [pc, #32]	; (8001e74 <Vector128+0x24>)
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 8001e52:	4809      	ldr	r0, [pc, #36]	; (8001e78 <Vector128+0x28>)
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001e54:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 8001e56:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001e58:	0c09      	lsrs	r1, r1, #16
 8001e5a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector128) {
 8001e5e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
 8001e60:	040c      	lsls	r4, r1, #16
 8001e62:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 8001e64:	b10a      	cbz	r2, 8001e6a <Vector128+0x1a>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8001e66:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8001e68:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001e6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001e6e:	f7fe bba7 	b.w	80005c0 <_port_irq_epilogue>
 8001e72:	bf00      	nop
 8001e74:	40026400 	.word	0x40026400
 8001e78:	20000fb8 	.word	0x20000fb8
 8001e7c:	00000000 	.word	0x00000000

08001e80 <Vector124>:
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 8001e80:	4b08      	ldr	r3, [pc, #32]	; (8001ea4 <Vector124+0x24>)
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 8001e82:	4809      	ldr	r0, [pc, #36]	; (8001ea8 <Vector124+0x28>)
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 8001e84:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 8001e86:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 8001e88:	0989      	lsrs	r1, r1, #6
 8001e8a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector124) {
 8001e8e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
 8001e90:	018c      	lsls	r4, r1, #6
 8001e92:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 8001e94:	b10a      	cbz	r2, 8001e9a <Vector124+0x1a>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8001e96:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8001e98:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001e9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001e9e:	f7fe bb8f 	b.w	80005c0 <_port_irq_epilogue>
 8001ea2:	bf00      	nop
 8001ea4:	40026400 	.word	0x40026400
 8001ea8:	20000fb8 	.word	0x20000fb8
 8001eac:	00000000 	.word	0x00000000

08001eb0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 8001eb0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 8001eb2:	4b07      	ldr	r3, [pc, #28]	; (8001ed0 <Vector120+0x20>)
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 8001eb4:	4807      	ldr	r0, [pc, #28]	; (8001ed4 <Vector120+0x24>)
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 8001eb6:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 8001eb8:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 8001eba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0;
 8001ebe:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 8001ec0:	b10a      	cbz	r2, 8001ec6 <Vector120+0x16>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8001ec2:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8001ec4:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001ec6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001eca:	f7fe bb79 	b.w	80005c0 <_port_irq_epilogue>
 8001ece:	bf00      	nop
 8001ed0:	40026400 	.word	0x40026400
 8001ed4:	20000fb8 	.word	0x20000fb8
	...

08001ee0 <VectorFC>:
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001ee0:	4b08      	ldr	r3, [pc, #32]	; (8001f04 <VectorFC+0x24>)
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 8001ee2:	4809      	ldr	r0, [pc, #36]	; (8001f08 <VectorFC+0x28>)
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001ee4:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 8001ee6:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001ee8:	0d89      	lsrs	r1, r1, #22
 8001eea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorFC) {
 8001eee:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
 8001ef0:	058c      	lsls	r4, r1, #22
 8001ef2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 8001ef4:	b10a      	cbz	r2, 8001efa <VectorFC+0x1a>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8001ef6:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8001ef8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001efa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001efe:	f7fe bb5f 	b.w	80005c0 <_port_irq_epilogue>
 8001f02:	bf00      	nop
 8001f04:	40026000 	.word	0x40026000
 8001f08:	20000fb8 	.word	0x20000fb8
 8001f0c:	00000000 	.word	0x00000000

08001f10 <Vector84>:
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001f10:	4b08      	ldr	r3, [pc, #32]	; (8001f34 <Vector84+0x24>)
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 8001f12:	4809      	ldr	r0, [pc, #36]	; (8001f38 <Vector84+0x28>)
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001f14:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 8001f16:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001f18:	0c09      	lsrs	r1, r1, #16
 8001f1a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector84) {
 8001f1e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
 8001f20:	040c      	lsls	r4, r1, #16
 8001f22:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 8001f24:	b10a      	cbz	r2, 8001f2a <Vector84+0x1a>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8001f26:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8001f28:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001f2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001f2e:	f7fe bb47 	b.w	80005c0 <_port_irq_epilogue>
 8001f32:	bf00      	nop
 8001f34:	40026000 	.word	0x40026000
 8001f38:	20000fb8 	.word	0x20000fb8
 8001f3c:	00000000 	.word	0x00000000

08001f40 <Vector80>:
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001f40:	4b08      	ldr	r3, [pc, #32]	; (8001f64 <Vector80+0x24>)
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 8001f42:	4809      	ldr	r0, [pc, #36]	; (8001f68 <Vector80+0x28>)
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001f44:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 8001f46:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001f48:	0989      	lsrs	r1, r1, #6
 8001f4a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector80) {
 8001f4e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
 8001f50:	018c      	lsls	r4, r1, #6
 8001f52:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 8001f54:	b10a      	cbz	r2, 8001f5a <Vector80+0x1a>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8001f56:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8001f58:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001f5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001f5e:	f7fe bb2f 	b.w	80005c0 <_port_irq_epilogue>
 8001f62:	bf00      	nop
 8001f64:	40026000 	.word	0x40026000
 8001f68:	20000fb8 	.word	0x20000fb8
 8001f6c:	00000000 	.word	0x00000000

08001f70 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 8001f70:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001f72:	4b07      	ldr	r3, [pc, #28]	; (8001f90 <Vector7C+0x20>)
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 8001f74:	4807      	ldr	r0, [pc, #28]	; (8001f94 <Vector7C+0x24>)
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001f76:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 8001f78:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001f7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0;
 8001f7e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 8001f80:	b10a      	cbz	r2, 8001f86 <Vector7C+0x16>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8001f82:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8001f84:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001f86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001f8a:	f7fe bb19 	b.w	80005c0 <_port_irq_epilogue>
 8001f8e:	bf00      	nop
 8001f90:	40026000 	.word	0x40026000
 8001f94:	20000fb8 	.word	0x20000fb8
	...

08001fa0 <Vector78>:
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001fa0:	4b08      	ldr	r3, [pc, #32]	; (8001fc4 <Vector78+0x24>)
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 8001fa2:	4809      	ldr	r0, [pc, #36]	; (8001fc8 <Vector78+0x28>)
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001fa4:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 8001fa6:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001fa8:	0d89      	lsrs	r1, r1, #22
 8001faa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector78) {
 8001fae:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
 8001fb0:	058c      	lsls	r4, r1, #22
 8001fb2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 8001fb4:	b10a      	cbz	r2, 8001fba <Vector78+0x1a>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8001fb6:	69c0      	ldr	r0, [r0, #28]
 8001fb8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001fba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001fbe:	f7fe baff 	b.w	80005c0 <_port_irq_epilogue>
 8001fc2:	bf00      	nop
 8001fc4:	40026000 	.word	0x40026000
 8001fc8:	20000fb8 	.word	0x20000fb8
 8001fcc:	00000000 	.word	0x00000000

08001fd0 <Vector74>:
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001fd0:	4b08      	ldr	r3, [pc, #32]	; (8001ff4 <Vector74+0x24>)
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 8001fd2:	4809      	ldr	r0, [pc, #36]	; (8001ff8 <Vector74+0x28>)
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001fd4:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 8001fd6:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001fd8:	0c09      	lsrs	r1, r1, #16
 8001fda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector74) {
 8001fde:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
 8001fe0:	040c      	lsls	r4, r1, #16
 8001fe2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 8001fe4:	b10a      	cbz	r2, 8001fea <Vector74+0x1a>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8001fe6:	6940      	ldr	r0, [r0, #20]
 8001fe8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8001fea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001fee:	f7fe bae7 	b.w	80005c0 <_port_irq_epilogue>
 8001ff2:	bf00      	nop
 8001ff4:	40026000 	.word	0x40026000
 8001ff8:	20000fb8 	.word	0x20000fb8
 8001ffc:	00000000 	.word	0x00000000

08002000 <Vector70>:
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 8002000:	4b08      	ldr	r3, [pc, #32]	; (8002024 <Vector70+0x24>)
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 8002002:	4809      	ldr	r0, [pc, #36]	; (8002028 <Vector70+0x28>)
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 8002004:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 8002006:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 8002008:	0989      	lsrs	r1, r1, #6
 800200a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 800200e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
 8002010:	018c      	lsls	r4, r1, #6
 8002012:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 8002014:	b10a      	cbz	r2, 800201a <Vector70+0x1a>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8002016:	68c0      	ldr	r0, [r0, #12]
 8002018:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800201a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800201e:	f7fe bacf 	b.w	80005c0 <_port_irq_epilogue>
 8002022:	bf00      	nop
 8002024:	40026000 	.word	0x40026000
 8002028:	20000fb8 	.word	0x20000fb8
 800202c:	00000000 	.word	0x00000000

08002030 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 8002030:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 8002032:	4b07      	ldr	r3, [pc, #28]	; (8002050 <Vector6C+0x20>)
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
 8002034:	4a07      	ldr	r2, [pc, #28]	; (8002054 <Vector6C+0x24>)
OSAL_IRQ_HANDLER(Vector6C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 8002036:	6819      	ldr	r1, [r3, #0]
 8002038:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0;
 800203c:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 800203e:	6813      	ldr	r3, [r2, #0]
 8002040:	b10b      	cbz	r3, 8002046 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8002042:	6850      	ldr	r0, [r2, #4]
 8002044:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8002046:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800204a:	f7fe bab9 	b.w	80005c0 <_port_irq_epilogue>
 800204e:	bf00      	nop
 8002050:	40026000 	.word	0x40026000
 8002054:	20000fb8 	.word	0x20000fb8
	...

08002060 <Vector104>:
 * @details It just wakes transaction thread. All error  handling performs in
 *          that thread.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SDIO_HANDLER) {
 8002060:	b510      	push	{r4, lr}
 8002062:	2320      	movs	r3, #32
 8002064:	f383 8811 	msr	BASEPRI, r3

  osalSysLockFromISR();

  /* Disables the source but the status flags are not reset because the
     read/write functions needs to check them.*/
  SDIO->MASK = 0;
 8002068:	4b06      	ldr	r3, [pc, #24]	; (8002084 <Vector104+0x24>)
 800206a:	4807      	ldr	r0, [pc, #28]	; (8002088 <Vector104+0x28>)
 800206c:	2400      	movs	r4, #0
 800206e:	63dc      	str	r4, [r3, #60]	; 0x3c
 8002070:	4621      	mov	r1, r4
 8002072:	f7fe ffbd 	bl	8000ff0 <chThdResumeI>
 8002076:	f384 8811 	msr	BASEPRI, r4
  osalThreadResumeI(&SDCD1.thread, MSG_OK);

  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 800207a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  osalThreadResumeI(&SDCD1.thread, MSG_OK);

  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 800207e:	f7fe ba9f 	b.w	80005c0 <_port_irq_epilogue>
 8002082:	bf00      	nop
 8002084:	40012c00 	.word	0x40012c00
 8002088:	200010b4 	.word	0x200010b4
 800208c:	00000000 	.word	0x00000000

08002090 <readt.lto_priv.76>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8002090:	300c      	adds	r0, #12
 8002092:	f7fe bc25 	b.w	80008e0 <chIQReadTimeout>
 8002096:	bf00      	nop
	...

080020a0 <read.lto_priv.70>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80020a0:	300c      	adds	r0, #12
 80020a2:	f04f 33ff 	mov.w	r3, #4294967295
 80020a6:	f7fe bc1b 	b.w	80008e0 <chIQReadTimeout>
 80020aa:	bf00      	nop
 80020ac:	0000      	movs	r0, r0
	...

080020b0 <writet.lto_priv.75>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80020b0:	3030      	adds	r0, #48	; 0x30
 80020b2:	f7fe bb9d 	b.w	80007f0 <chOQWriteTimeout>
 80020b6:	bf00      	nop
	...

080020c0 <write.lto_priv.69>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80020c0:	3030      	adds	r0, #48	; 0x30
 80020c2:	f04f 33ff 	mov.w	r3, #4294967295
 80020c6:	f7fe bb93 	b.w	80007f0 <chOQWriteTimeout>
 80020ca:	bf00      	nop
 80020cc:	0000      	movs	r0, r0
	...

080020d0 <gett.lto_priv.74>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80020d0:	300c      	adds	r0, #12
 80020d2:	f7fe bc45 	b.w	8000960 <chIQGetTimeout>
 80020d6:	bf00      	nop
	...

080020e0 <get.lto_priv.72>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80020e0:	300c      	adds	r0, #12
 80020e2:	f04f 31ff 	mov.w	r1, #4294967295
 80020e6:	f7fe bc3b 	b.w	8000960 <chIQGetTimeout>
 80020ea:	bf00      	nop
 80020ec:	0000      	movs	r0, r0
	...

080020f0 <putt.lto_priv.73>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80020f0:	3030      	adds	r0, #48	; 0x30
 80020f2:	f7fe bbc5 	b.w	8000880 <chOQPutTimeout>
 80020f6:	bf00      	nop
	...

08002100 <put.lto_priv.71>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8002100:	3030      	adds	r0, #48	; 0x30
 8002102:	f04f 32ff 	mov.w	r2, #4294967295
 8002106:	f7fe bbbb 	b.w	8000880 <chOQPutTimeout>
 800210a:	bf00      	nop
 800210c:	0000      	movs	r0, r0
	...

08002110 <sdc_lld_collect_errors.isra.0.lto_priv.84>:
 * @notapi
 */
static void sdc_lld_collect_errors(SDCDriver *sdcp, uint32_t sta) {
  uint32_t errors = SDC_NO_ERROR;

  if (sta & SDIO_STA_CCRCFAIL)
 8002110:	f001 0301 	and.w	r3, r1, #1
    errors |= SDC_CMD_CRC_ERROR;
  if (sta & SDIO_STA_DCRCFAIL)
 8002114:	078a      	lsls	r2, r1, #30
    errors |= SDC_DATA_CRC_ERROR;
 8002116:	bf48      	it	mi
 8002118:	f043 0302 	orrmi.w	r3, r3, #2
  if (sta & SDIO_STA_CTIMEOUT)
 800211c:	074a      	lsls	r2, r1, #29
    errors |= SDC_COMMAND_TIMEOUT;
 800211e:	bf48      	it	mi
 8002120:	f043 0308 	orrmi.w	r3, r3, #8
  if (sta & SDIO_STA_DTIMEOUT)
 8002124:	070a      	lsls	r2, r1, #28
    errors |= SDC_DATA_TIMEOUT;
 8002126:	bf48      	it	mi
 8002128:	f043 0304 	orrmi.w	r3, r3, #4
  if (sta & SDIO_STA_TXUNDERR)
 800212c:	06ca      	lsls	r2, r1, #27
    errors |= SDC_TX_UNDERRUN;
 800212e:	bf48      	it	mi
 8002130:	f043 0310 	orrmi.w	r3, r3, #16
  if (sta & SDIO_STA_RXOVERR)
 8002134:	068a      	lsls	r2, r1, #26
    errors |= SDC_RX_OVERRUN;
 8002136:	bf48      	it	mi
 8002138:	f043 0320 	orrmi.w	r3, r3, #32
  if (sta & SDIO_STA_STBITERR)
 800213c:	058a      	lsls	r2, r1, #22
    errors |= SDC_STARTBIT_ERROR;

  sdcp->errors |= errors;
 800213e:	6802      	ldr	r2, [r0, #0]
  if (sta & SDIO_STA_TXUNDERR)
    errors |= SDC_TX_UNDERRUN;
  if (sta & SDIO_STA_RXOVERR)
    errors |= SDC_RX_OVERRUN;
  if (sta & SDIO_STA_STBITERR)
    errors |= SDC_STARTBIT_ERROR;
 8002140:	bf48      	it	mi
 8002142:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40

  sdcp->errors |= errors;
 8002146:	4313      	orrs	r3, r2
 8002148:	6003      	str	r3, [r0, #0]
 800214a:	4770      	bx	lr
 800214c:	0000      	movs	r0, r0
	...

08002150 <sdc_lld_send_cmd_long_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_long_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                               uint32_t *resp) {
 8002150:	b510      	push	{r4, lr}
  uint32_t sta;

  (void)sdcp;

  sdcp->sdio->ARG = arg;
 8002152:	6c84      	ldr	r4, [r0, #72]	; 0x48
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_WAITRESP_1 |
 8002154:	f441 6198 	orr.w	r1, r1, #1216	; 0x4c0
                               uint32_t *resp) {
  uint32_t sta;

  (void)sdcp;

  sdcp->sdio->ARG = arg;
 8002158:	60a2      	str	r2, [r4, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_WAITRESP_1 |
 800215a:	60e1      	str	r1, [r4, #12]
                                    SDIO_CMD_CPSMEN;
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 800215c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800215e:	f011 0245 	ands.w	r2, r1, #69	; 0x45
 8002162:	d0fb      	beq.n	800215c <sdc_lld_send_cmd_long_crc+0xc>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8002164:	63a2      	str	r2, [r4, #56]	; 0x38
                           SDIO_STA_CCRCFAIL);
  if ((sta & (STM32_SDIO_STA_ERROR_MASK)) != 0) {
 8002166:	f011 023f 	ands.w	r2, r1, #63	; 0x3f
 800216a:	d109      	bne.n	8002180 <sdc_lld_send_cmd_long_crc+0x30>
    sdc_lld_collect_errors(sdcp, sta);
    return HAL_FAILED;
  }
  /* Save bytes in reverse order because MSB in response comes first.*/
  *resp++ = sdcp->sdio->RESP4;
 800216c:	6a21      	ldr	r1, [r4, #32]
 800216e:	6019      	str	r1, [r3, #0]
  *resp++ = sdcp->sdio->RESP3;
 8002170:	69e1      	ldr	r1, [r4, #28]
 8002172:	6059      	str	r1, [r3, #4]
  *resp++ = sdcp->sdio->RESP2;
 8002174:	69a1      	ldr	r1, [r4, #24]
 8002176:	6099      	str	r1, [r3, #8]
  *resp   = sdcp->sdio->RESP1;
 8002178:	6961      	ldr	r1, [r4, #20]
 800217a:	60d9      	str	r1, [r3, #12]
  return HAL_SUCCESS;
 800217c:	4610      	mov	r0, r2
}
 800217e:	bd10      	pop	{r4, pc}
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
                           SDIO_STA_CCRCFAIL);
  if ((sta & (STM32_SDIO_STA_ERROR_MASK)) != 0) {
    sdc_lld_collect_errors(sdcp, sta);
 8002180:	3034      	adds	r0, #52	; 0x34
 8002182:	f7ff ffc5 	bl	8002110 <sdc_lld_collect_errors.isra.0.lto_priv.84>
    return HAL_FAILED;
 8002186:	2001      	movs	r0, #1
 8002188:	bd10      	pop	{r4, pc}
 800218a:	bf00      	nop
 800218c:	0000      	movs	r0, r0
	...

08002190 <sdc_lld_send_cmd_short_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                                uint32_t *resp) {
 8002190:	b510      	push	{r4, lr}
  uint32_t sta;

  sdcp->sdio->ARG = arg;
 8002192:	6c84      	ldr	r4, [r0, #72]	; 0x48
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8002194:	f441 6188 	orr.w	r1, r1, #1088	; 0x440
 */
bool sdc_lld_send_cmd_short_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                                uint32_t *resp) {
  uint32_t sta;

  sdcp->sdio->ARG = arg;
 8002198:	60a2      	str	r2, [r4, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 800219a:	60e1      	str	r1, [r4, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 800219c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800219e:	f011 0245 	ands.w	r2, r1, #69	; 0x45
 80021a2:	d0fb      	beq.n	800219c <sdc_lld_send_cmd_short_crc+0xc>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL);
 80021a4:	63a2      	str	r2, [r4, #56]	; 0x38
  if ((sta & (SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL)) != 0) {
 80021a6:	f011 0205 	ands.w	r2, r1, #5
 80021aa:	d103      	bne.n	80021b4 <sdc_lld_send_cmd_short_crc+0x24>
    sdc_lld_collect_errors(sdcp, sta);
    return HAL_FAILED;
  }
  *resp = sdcp->sdio->RESP1;
 80021ac:	6961      	ldr	r1, [r4, #20]
 80021ae:	6019      	str	r1, [r3, #0]
  return HAL_SUCCESS;
 80021b0:	4610      	mov	r0, r2
}
 80021b2:	bd10      	pop	{r4, pc}
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL);
  if ((sta & (SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL)) != 0) {
    sdc_lld_collect_errors(sdcp, sta);
 80021b4:	3034      	adds	r0, #52	; 0x34
 80021b6:	f7ff ffab 	bl	8002110 <sdc_lld_collect_errors.isra.0.lto_priv.84>
    return HAL_FAILED;
 80021ba:	2001      	movs	r0, #1
 80021bc:	bd10      	pop	{r4, pc}
 80021be:	bf00      	nop

080021c0 <sdc_lld_error_cleanup>:
 *
 * @notapi
 */
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
 80021c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80021c4:	4606      	mov	r6, r0
  uint32_t sta = sdcp->sdio->STA;

  dmaStreamClearInterrupt(sdcp->dma);
 80021c6:	6c40      	ldr	r0, [r0, #68]	; 0x44
 * @notapi
 */
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
  uint32_t sta = sdcp->sdio->STA;
 80021c8:	6cb5      	ldr	r5, [r6, #72]	; 0x48

  dmaStreamClearInterrupt(sdcp->dma);
 80021ca:	7a07      	ldrb	r7, [r0, #8]
 * @notapi
 */
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
  uint32_t sta = sdcp->sdio->STA;
 80021cc:	f8d5 c034 	ldr.w	ip, [r5, #52]	; 0x34

  dmaStreamClearInterrupt(sdcp->dma);
  dmaStreamDisable(sdcp->dma);
 80021d0:	e890 4008 	ldmia.w	r0, {r3, lr}
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
  uint32_t sta = sdcp->sdio->STA;

  dmaStreamClearInterrupt(sdcp->dma);
 80021d4:	243d      	movs	r4, #61	; 0x3d
 80021d6:	40bc      	lsls	r4, r7
 80021d8:	f8ce 4000 	str.w	r4, [lr]
  dmaStreamDisable(sdcp->dma);
 80021dc:	681c      	ldr	r4, [r3, #0]
 80021de:	f024 041f 	bic.w	r4, r4, #31
 *
 * @notapi
 */
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
 80021e2:	4688      	mov	r8, r1
 80021e4:	4617      	mov	r7, r2
  uint32_t sta = sdcp->sdio->STA;

  dmaStreamClearInterrupt(sdcp->dma);
  dmaStreamDisable(sdcp->dma);
 80021e6:	601c      	str	r4, [r3, #0]
 80021e8:	681a      	ldr	r2, [r3, #0]
 80021ea:	f012 0401 	ands.w	r4, r2, #1
 80021ee:	d1fb      	bne.n	80021e8 <sdc_lld_error_cleanup+0x28>
 80021f0:	7a01      	ldrb	r1, [r0, #8]
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80021f2:	4a0d      	ldr	r2, [pc, #52]	; (8002228 <sdc_lld_error_cleanup+0x68>)
                                  uint32_t n,
                                  uint32_t *resp) {
  uint32_t sta = sdcp->sdio->STA;

  dmaStreamClearInterrupt(sdcp->dma);
  dmaStreamDisable(sdcp->dma);
 80021f4:	233d      	movs	r3, #61	; 0x3d
 80021f6:	408b      	lsls	r3, r1
 80021f8:	f8ce 3000 	str.w	r3, [lr]
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
  sdcp->sdio->MASK  = 0;
  sdcp->sdio->DCTRL = 0;
  sdc_lld_collect_errors(sdcp, sta);
 80021fc:	4661      	mov	r1, ip
                                  uint32_t *resp) {
  uint32_t sta = sdcp->sdio->STA;

  dmaStreamClearInterrupt(sdcp->dma);
  dmaStreamDisable(sdcp->dma);
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80021fe:	63aa      	str	r2, [r5, #56]	; 0x38
  sdcp->sdio->MASK  = 0;
  sdcp->sdio->DCTRL = 0;
  sdc_lld_collect_errors(sdcp, sta);
 8002200:	f106 0034 	add.w	r0, r6, #52	; 0x34
  uint32_t sta = sdcp->sdio->STA;

  dmaStreamClearInterrupt(sdcp->dma);
  dmaStreamDisable(sdcp->dma);
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
  sdcp->sdio->MASK  = 0;
 8002204:	63ec      	str	r4, [r5, #60]	; 0x3c
  sdcp->sdio->DCTRL = 0;
 8002206:	62ec      	str	r4, [r5, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 8002208:	f7ff ff82 	bl	8002110 <sdc_lld_collect_errors.isra.0.lto_priv.84>
  if (n > 1)
 800220c:	f1b8 0f01 	cmp.w	r8, #1
 8002210:	d907      	bls.n	8002222 <sdc_lld_error_cleanup+0x62>
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 8002212:	4630      	mov	r0, r6
 8002214:	4622      	mov	r2, r4
 8002216:	463b      	mov	r3, r7
 8002218:	210c      	movs	r1, #12
}
 800221a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
  sdcp->sdio->MASK  = 0;
  sdcp->sdio->DCTRL = 0;
  sdc_lld_collect_errors(sdcp, sta);
  if (n > 1)
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 800221e:	f7ff bfb7 	b.w	8002190 <sdc_lld_send_cmd_short_crc>
 8002222:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002226:	bf00      	nop
 8002228:	00c007ff 	.word	0x00c007ff
 800222c:	00000000 	.word	0x00000000

08002230 <sdc_lld_wait_transaction_end>:
 * @return              The operation status.
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 */
static bool sdc_lld_wait_transaction_end(SDCDriver *sdcp, uint32_t n,
                                         uint32_t *resp) {
 8002230:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002234:	2320      	movs	r3, #32
 8002236:	4605      	mov	r5, r0
 8002238:	460e      	mov	r6, r1
 800223a:	4617      	mov	r7, r2
 800223c:	f383 8811 	msr	BASEPRI, r3

  /* Note the mask is checked before going to sleep because the interrupt
     may have occurred before reaching the critical zone.*/
  osalSysLock();
  if (sdcp->sdio->MASK != 0)
 8002240:	6c84      	ldr	r4, [r0, #72]	; 0x48
 8002242:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002244:	bb33      	cbnz	r3, 8002294 <sdc_lld_wait_transaction_end+0x64>
    osalThreadSuspendS(&sdcp->thread);
  if ((sdcp->sdio->STA & SDIO_STA_DATAEND) == 0) {
 8002246:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002248:	f412 7280 	ands.w	r2, r2, #256	; 0x100
 800224c:	d01d      	beq.n	800228a <sdc_lld_wait_transaction_end+0x5a>
 800224e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8002250:	6818      	ldr	r0, [r3, #0]
    return HAL_FAILED;
  }

#if (defined(STM32F4XX) || defined(STM32F2XX))
  /* Wait until DMA channel enabled to be sure that all data transferred.*/
  while (sdcp->dma->stream->CR & STM32_DMA_CR_EN)
 8002252:	6802      	ldr	r2, [r0, #0]
 8002254:	f012 0201 	ands.w	r2, r2, #1
 8002258:	d1fb      	bne.n	8002252 <sdc_lld_wait_transaction_end+0x22>
    ;

  /* DMA event flags must be manually cleared.*/
  dmaStreamClearInterrupt(sdcp->dma);
 800225a:	f893 e008 	ldrb.w	lr, [r3, #8]
 800225e:	6859      	ldr	r1, [r3, #4]

  sdcp->sdio->ICR = STM32_SDIO_ICR_ALL_FLAGS;
 8002260:	4b12      	ldr	r3, [pc, #72]	; (80022ac <sdc_lld_wait_transaction_end+0x7c>)
  /* Wait until DMA channel enabled to be sure that all data transferred.*/
  while (sdcp->dma->stream->CR & STM32_DMA_CR_EN)
    ;

  /* DMA event flags must be manually cleared.*/
  dmaStreamClearInterrupt(sdcp->dma);
 8002262:	203d      	movs	r0, #61	; 0x3d
 8002264:	fa00 f00e 	lsl.w	r0, r0, lr
 8002268:	6008      	str	r0, [r1, #0]

  sdcp->sdio->ICR = STM32_SDIO_ICR_ALL_FLAGS;
 800226a:	63a3      	str	r3, [r4, #56]	; 0x38
  sdcp->sdio->DCTRL = 0;
 800226c:	62e2      	str	r2, [r4, #44]	; 0x2c
 800226e:	f382 8811 	msr	BASEPRI, r2
  sdcp->sdio->DCTRL = 0;
  osalSysUnlock();
#endif

  /* Finalize transaction.*/
  if (n > 1)
 8002272:	2e01      	cmp	r6, #1
 8002274:	d906      	bls.n	8002284 <sdc_lld_wait_transaction_end+0x54>
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 8002276:	4628      	mov	r0, r5
 8002278:	463b      	mov	r3, r7
 800227a:	210c      	movs	r1, #12

  return HAL_SUCCESS;
}
 800227c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  osalSysUnlock();
#endif

  /* Finalize transaction.*/
  if (n > 1)
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 8002280:	f7ff bf86 	b.w	8002190 <sdc_lld_send_cmd_short_crc>

  return HAL_SUCCESS;
 8002284:	4610      	mov	r0, r2
}
 8002286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800228a:	f382 8811 	msr	BASEPRI, r2
  osalSysLock();
  if (sdcp->sdio->MASK != 0)
    osalThreadSuspendS(&sdcp->thread);
  if ((sdcp->sdio->STA & SDIO_STA_DATAEND) == 0) {
    osalSysUnlock();
    return HAL_FAILED;
 800228e:	2001      	movs	r0, #1
 8002290:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002294:	4a06      	ldr	r2, [pc, #24]	; (80022b0 <sdc_lld_wait_transaction_end+0x80>)
msg_t chThdSuspendS(thread_reference_t *trp) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 8002296:	4603      	mov	r3, r0
 8002298:	6992      	ldr	r2, [r2, #24]
 800229a:	f843 2f3c 	str.w	r2, [r3, #60]!
  tp->p_u.wttrp = trp;
  chSchGoSleepS(CH_STATE_SUSPENDED);
 800229e:	2003      	movs	r0, #3
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
  tp->p_u.wttrp = trp;
 80022a0:	6213      	str	r3, [r2, #32]
  chSchGoSleepS(CH_STATE_SUSPENDED);
 80022a2:	f7fe f9ed 	bl	8000680 <chSchGoSleepS>
 80022a6:	6cac      	ldr	r4, [r5, #72]	; 0x48
 80022a8:	e7cd      	b.n	8002246 <sdc_lld_wait_transaction_end+0x16>
 80022aa:	bf00      	nop
 80022ac:	00c007ff 	.word	0x00c007ff
 80022b0:	20001140 	.word	0x20001140
	...

080022c0 <sdc_lld_write_aligned.part.5>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
 80022c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80022c4:	461d      	mov	r5, r3
  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 80022c6:	6c43      	ldr	r3, [r0, #68]	; 0x44
  dmaStreamSetTransactionSize(sdcp->dma,
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 80022c8:	6c06      	ldr	r6, [r0, #64]	; 0x40
  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 80022ca:	681b      	ldr	r3, [r3, #0]
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80022cc:	f8df c094 	ldr.w	ip, [pc, #148]	; 8002364 <sdc_lld_write_aligned.part.5+0xa4>
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
 80022d0:	4604      	mov	r4, r0
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
  dmaStreamSetTransactionSize(sdcp->dma,
 80022d2:	026f      	lsls	r7, r5, #9
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 80022d4:	f046 0640 	orr.w	r6, r6, #64	; 0x40
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
  dmaStreamSetTransactionSize(sdcp->dma,
 80022d8:	ea4f 0897 	mov.w	r8, r7, lsr #2
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80022dc:	6c80      	ldr	r0, [r0, #72]	; 0x48
static bool sdc_lld_prepare_write(SDCDriver *sdcp, uint32_t startblk,
                                  uint32_t n, uint32_t *resp) {

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 80022de:	f8d4 e030 	ldr.w	lr, [r4, #48]	; 0x30
  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 80022e2:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 80022e4:	f8c3 8004 	str.w	r8, [r3, #4]
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 80022e8:	601e      	str	r6, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 80022ea:	681e      	ldr	r6, [r3, #0]
static bool sdc_lld_prepare_write(SDCDriver *sdcp, uint32_t startblk,
                                  uint32_t n, uint32_t *resp) {

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 80022ec:	f01e 0f10 	tst.w	lr, #16
  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
  dmaStreamSetTransactionSize(sdcp->dma,
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
  dmaStreamEnable(sdcp->dma);
 80022f0:	f046 0601 	orr.w	r6, r6, #1
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
 80022f4:	b082      	sub	sp, #8
  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
  dmaStreamSetTransactionSize(sdcp->dma,
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
  dmaStreamEnable(sdcp->dma);
 80022f6:	601e      	str	r6, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 80022f8:	f240 321a 	movw	r2, #794	; 0x31a
                                  uint32_t n, uint32_t *resp) {

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;
 80022fc:	bf08      	it	eq
 80022fe:	0249      	lsleq	r1, r1, #9

  if (n > 1) {
    /* Write multiple blocks command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 8002300:	ae01      	add	r6, sp, #4
  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;

  if (n > 1) {
 8002302:	2d01      	cmp	r5, #1
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8002304:	f8c0 c038 	str.w	ip, [r0, #56]	; 0x38
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;

  if (n > 1) {
    /* Write multiple blocks command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 8002308:	4633      	mov	r3, r6
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 800230a:	63c2      	str	r2, [r0, #60]	; 0x3c
                      SDIO_MASK_DTIMEOUTIE |
                      SDIO_MASK_STBITERRIE |
                      SDIO_MASK_TXUNDERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 800230c:	6287      	str	r7, [r0, #40]	; 0x28
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;

  if (n > 1) {
    /* Write multiple blocks command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 800230e:	460a      	mov	r2, r1
 8002310:	4620      	mov	r0, r4
  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;

  if (n > 1) {
 8002312:	d919      	bls.n	8002348 <sdc_lld_write_aligned.part.5+0x88>
    /* Write multiple blocks command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 8002314:	2119      	movs	r1, #25
 8002316:	f7ff ff3b 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 800231a:	b960      	cbnz	r0, 8002336 <sdc_lld_write_aligned.part.5+0x76>
      return HAL_FAILED;
  }
  else{
    /* Write single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_BLOCK,
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800231c:	9a01      	ldr	r2, [sp, #4]
 800231e:	4b10      	ldr	r3, [pc, #64]	; (8002360 <sdc_lld_write_aligned.part.5+0xa0>)
 8002320:	4013      	ands	r3, r2
 8002322:	b943      	cbnz	r3, 8002336 <sdc_lld_write_aligned.part.5+0x76>
  /* Talk to card what we want from it.*/
  if (sdc_lld_prepare_write(sdcp, startblk, blocks, resp) == TRUE)
    goto error;

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DBLOCKSIZE_3 |
 8002324:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002326:	2299      	movs	r2, #153	; 0x99
 8002328:	62da      	str	r2, [r3, #44]	; 0x2c
                      SDIO_DCTRL_DBLOCKSIZE_0 |
                      SDIO_DCTRL_DMAEN |
                      SDIO_DCTRL_DTEN;

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 800232a:	4620      	mov	r0, r4
 800232c:	4629      	mov	r1, r5
 800232e:	4632      	mov	r2, r6
 8002330:	f7ff ff7e 	bl	8002230 <sdc_lld_wait_transaction_end>
 8002334:	b128      	cbz	r0, 8002342 <sdc_lld_write_aligned.part.5+0x82>
    goto error;

  return HAL_SUCCESS;

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 8002336:	4620      	mov	r0, r4
 8002338:	4629      	mov	r1, r5
 800233a:	4632      	mov	r2, r6
 800233c:	f7ff ff40 	bl	80021c0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 8002340:	2001      	movs	r0, #1
}
 8002342:	b002      	add	sp, #8
 8002344:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
      return HAL_FAILED;
  }
  else{
    /* Write single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_BLOCK,
 8002348:	2118      	movs	r1, #24
 800234a:	f7ff ff21 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 800234e:	2800      	cmp	r0, #0
 8002350:	d1f1      	bne.n	8002336 <sdc_lld_write_aligned.part.5+0x76>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8002352:	9a01      	ldr	r2, [sp, #4]
 8002354:	4b02      	ldr	r3, [pc, #8]	; (8002360 <sdc_lld_write_aligned.part.5+0xa0>)
 8002356:	4013      	ands	r3, r2
 8002358:	2b00      	cmp	r3, #0
 800235a:	d0e3      	beq.n	8002324 <sdc_lld_write_aligned.part.5+0x64>
 800235c:	e7eb      	b.n	8002336 <sdc_lld_write_aligned.part.5+0x76>
 800235e:	bf00      	nop
 8002360:	fdffe008 	.word	0xfdffe008
 8002364:	00c007ff 	.word	0x00c007ff
	...

08002370 <sdcWrite>:
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcWrite(SDCDriver *sdcp, uint32_t startblk,
              const uint8_t *buf, uint32_t n) {
 8002370:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002374:	460e      	mov	r6, r1
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 8002376:	6a87      	ldr	r7, [r0, #40]	; 0x28
 8002378:	1e59      	subs	r1, r3, #1
 800237a:	4431      	add	r1, r6
 800237c:	42b9      	cmp	r1, r7
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcWrite(SDCDriver *sdcp, uint32_t startblk,
              const uint8_t *buf, uint32_t n) {
 800237e:	b082      	sub	sp, #8
 8002380:	4604      	mov	r4, r0
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 8002382:	d907      	bls.n	8002394 <sdcWrite+0x24>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8002384:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002386:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800238a:	6343      	str	r3, [r0, #52]	; 0x34
    return HAL_FAILED;
 800238c:	2001      	movs	r0, #1
  status = sdc_lld_write(sdcp, startblk, buf, n);

  /* Write operation finished.*/
  sdcp->state = BLK_READY;
  return status;
}
 800238e:	b002      	add	sp, #8
 8002390:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002394:	4615      	mov	r5, r2
    sdcp->errors |= SDC_OVERFLOW_ERROR;
    return HAL_FAILED;
  }

  /* Write operation in progress.*/
  sdcp->state = BLK_WRITING;
 8002396:	2207      	movs	r2, #7
 8002398:	7102      	strb	r2, [r0, #4]
 */
bool sdc_lld_write(SDCDriver *sdcp, uint32_t startblk,
                   const uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 800239a:	07aa      	lsls	r2, r5, #30
 800239c:	d024      	beq.n	80023e8 <sdcWrite+0x78>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800239e:	b30b      	cbz	r3, 80023e4 <sdcWrite+0x74>
                           const uint8_t *buf, uint32_t blocks) {
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;
 80023a0:	4f19      	ldr	r7, [pc, #100]	; (8002408 <sdcWrite+0x98>)
 80023a2:	eb06 0803 	add.w	r8, r6, r3

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
 80023a6:	4629      	mov	r1, r5
 80023a8:	f44f 7200 	mov.w	r2, #512	; 0x200
 80023ac:	4817      	ldr	r0, [pc, #92]	; (800240c <sdcWrite+0x9c>)
 80023ae:	f7fd ff7f 	bl	80002b0 <memcpy>
                           const uint8_t *buf, uint32_t blocks) {
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;
 80023b2:	6ca2      	ldr	r2, [r4, #72]	; 0x48

  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 80023b4:	4620      	mov	r0, r4
                           const uint8_t *buf, uint32_t blocks) {
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;
 80023b6:	6257      	str	r7, [r2, #36]	; 0x24
#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
      buf += MMCSD_BLOCK_SIZE;
 80023b8:	f505 7500 	add.w	r5, r5, #512	; 0x200
  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;

  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 80023bc:	f7fe fcf8 	bl	8000db0 <_sdc_wait_for_transfer_state>
 80023c0:	b128      	cbz	r0, 80023ce <sdcWrite+0x5e>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
      buf += MMCSD_BLOCK_SIZE;
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
        return HAL_FAILED;
 80023c2:	2001      	movs	r0, #1

  status = sdc_lld_write(sdcp, startblk, buf, n);

  /* Write operation finished.*/
  sdcp->state = BLK_READY;
 80023c4:	2305      	movs	r3, #5
 80023c6:	7123      	strb	r3, [r4, #4]
  return status;
}
 80023c8:	b002      	add	sp, #8
 80023ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80023ce:	4631      	mov	r1, r6
 80023d0:	4620      	mov	r0, r4
 80023d2:	4a0e      	ldr	r2, [pc, #56]	; (800240c <sdcWrite+0x9c>)
 80023d4:	2301      	movs	r3, #1
 80023d6:	f7ff ff73 	bl	80022c0 <sdc_lld_write_aligned.part.5>
      startblk++;
 80023da:	3601      	adds	r6, #1
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
      buf += MMCSD_BLOCK_SIZE;
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
 80023dc:	2800      	cmp	r0, #0
 80023de:	d1f0      	bne.n	80023c2 <sdcWrite+0x52>
                   const uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 80023e0:	4546      	cmp	r6, r8
 80023e2:	d1e0      	bne.n	80023a6 <sdcWrite+0x36>
      buf += MMCSD_BLOCK_SIZE;
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
        return HAL_FAILED;
      startblk++;
    }
    return HAL_SUCCESS;
 80023e4:	2000      	movs	r0, #0
 80023e6:	e7ed      	b.n	80023c4 <sdcWrite+0x54>
                           const uint8_t *buf, uint32_t blocks) {
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;
 80023e8:	6c82      	ldr	r2, [r0, #72]	; 0x48
 80023ea:	4907      	ldr	r1, [pc, #28]	; (8002408 <sdcWrite+0x98>)
 80023ec:	6251      	str	r1, [r2, #36]	; 0x24
 80023ee:	9301      	str	r3, [sp, #4]

  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 80023f0:	f7fe fcde 	bl	8000db0 <_sdc_wait_for_transfer_state>
 80023f4:	9b01      	ldr	r3, [sp, #4]
 80023f6:	2800      	cmp	r0, #0
 80023f8:	d1e3      	bne.n	80023c2 <sdcWrite+0x52>
 80023fa:	4631      	mov	r1, r6
 80023fc:	462a      	mov	r2, r5
 80023fe:	4620      	mov	r0, r4
 8002400:	f7ff ff5e 	bl	80022c0 <sdc_lld_write_aligned.part.5>
 8002404:	e7de      	b.n	80023c4 <sdcWrite+0x54>
 8002406:	bf00      	nop
 8002408:	005b8d80 	.word	0x005b8d80
 800240c:	20000800 	.word	0x20000800

08002410 <sdc_lld_read_aligned.part.4>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
 8002410:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002414:	461d      	mov	r5, r3
  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8002416:	6c43      	ldr	r3, [r0, #68]	; 0x44
  dmaStreamSetTransactionSize(sdcp->dma,
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 8002418:	6c06      	ldr	r6, [r0, #64]	; 0x40
  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800241a:	681b      	ldr	r3, [r3, #0]
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 800241c:	f8df 8090 	ldr.w	r8, [pc, #144]	; 80024b0 <sdc_lld_read_aligned.part.4+0xa0>
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
 8002420:	4604      	mov	r4, r0
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
  dmaStreamSetTransactionSize(sdcp->dma,
 8002422:	026f      	lsls	r7, r5, #9
 8002424:	ea4f 0c97 	mov.w	ip, r7, lsr #2
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8002428:	6c80      	ldr	r0, [r0, #72]	; 0x48
static bool sdc_lld_prepare_read(SDCDriver *sdcp, uint32_t startblk,
                                 uint32_t n, uint32_t *resp) {

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 800242a:	f8d4 e030 	ldr.w	lr, [r4, #48]	; 0x30
  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800242e:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 8002430:	f8c3 c004 	str.w	ip, [r3, #4]
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 8002434:	601e      	str	r6, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 8002436:	681e      	ldr	r6, [r3, #0]
static bool sdc_lld_prepare_read(SDCDriver *sdcp, uint32_t startblk,
                                 uint32_t n, uint32_t *resp) {

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 8002438:	f01e 0f10 	tst.w	lr, #16
  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
  dmaStreamSetTransactionSize(sdcp->dma,
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);
 800243c:	f046 0601 	orr.w	r6, r6, #1
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
 8002440:	b082      	sub	sp, #8
  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
  dmaStreamSetTransactionSize(sdcp->dma,
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);
 8002442:	601e      	str	r6, [r3, #0]
                      SDIO_MASK_RXOVERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = blocks * MMCSD_BLOCK_SIZE;

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 8002444:	f04f 029b 	mov.w	r2, #155	; 0x9b
                                 uint32_t n, uint32_t *resp) {

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;
 8002448:	bf08      	it	eq
 800244a:	0249      	lsleq	r1, r1, #9
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 800244c:	f240 3c2a 	movw	ip, #810	; 0x32a
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;

  if (n > 1) {
    /* Send read multiple blocks command to card.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 8002450:	ae01      	add	r6, sp, #4
  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;

  if (n > 1) {
 8002452:	2d01      	cmp	r5, #1
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8002454:	f8c0 8038 	str.w	r8, [r0, #56]	; 0x38
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;

  if (n > 1) {
    /* Send read multiple blocks command to card.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 8002458:	4633      	mov	r3, r6
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 800245a:	f8c0 c03c 	str.w	ip, [r0, #60]	; 0x3c
                      SDIO_MASK_DTIMEOUTIE |
                      SDIO_MASK_STBITERRIE |
                      SDIO_MASK_RXOVERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 800245e:	6287      	str	r7, [r0, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 8002460:	62c2      	str	r2, [r0, #44]	; 0x2c
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;

  if (n > 1) {
    /* Send read multiple blocks command to card.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 8002462:	460a      	mov	r2, r1
 8002464:	4620      	mov	r0, r4
  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
    startblk *= MMCSD_BLOCK_SIZE;

  if (n > 1) {
 8002466:	d916      	bls.n	8002496 <sdc_lld_read_aligned.part.4+0x86>
    /* Send read multiple blocks command to card.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 8002468:	2112      	movs	r1, #18
 800246a:	f7ff fe91 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 800246e:	b948      	cbnz	r0, 8002484 <sdc_lld_read_aligned.part.4+0x74>
      return HAL_FAILED;
  }
  else{
    /* Send read single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_SINGLE_BLOCK,
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8002470:	9a01      	ldr	r2, [sp, #4]
 8002472:	4b0e      	ldr	r3, [pc, #56]	; (80024ac <sdc_lld_read_aligned.part.4+0x9c>)
 8002474:	4013      	ands	r3, r2
 8002476:	b92b      	cbnz	r3, 8002484 <sdc_lld_read_aligned.part.4+0x74>
                      SDIO_DCTRL_DTEN;

  if (sdc_lld_prepare_read(sdcp, startblk, blocks, resp) == TRUE)
    goto error;

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 8002478:	4620      	mov	r0, r4
 800247a:	4629      	mov	r1, r5
 800247c:	4632      	mov	r2, r6
 800247e:	f7ff fed7 	bl	8002230 <sdc_lld_wait_transaction_end>
 8002482:	b128      	cbz	r0, 8002490 <sdc_lld_read_aligned.part.4+0x80>
    goto error;

  return HAL_SUCCESS;

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 8002484:	4620      	mov	r0, r4
 8002486:	4629      	mov	r1, r5
 8002488:	4632      	mov	r2, r6
 800248a:	f7ff fe99 	bl	80021c0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800248e:	2001      	movs	r0, #1
}
 8002490:	b002      	add	sp, #8
 8002492:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
      return HAL_FAILED;
  }
  else{
    /* Send read single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_SINGLE_BLOCK,
 8002496:	2111      	movs	r1, #17
 8002498:	f7ff fe7a 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 800249c:	2800      	cmp	r0, #0
 800249e:	d1f1      	bne.n	8002484 <sdc_lld_read_aligned.part.4+0x74>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 80024a0:	9a01      	ldr	r2, [sp, #4]
 80024a2:	4b02      	ldr	r3, [pc, #8]	; (80024ac <sdc_lld_read_aligned.part.4+0x9c>)
 80024a4:	4013      	ands	r3, r2
 80024a6:	2b00      	cmp	r3, #0
 80024a8:	d0e6      	beq.n	8002478 <sdc_lld_read_aligned.part.4+0x68>
 80024aa:	e7eb      	b.n	8002484 <sdc_lld_read_aligned.part.4+0x74>
 80024ac:	fdffe008 	.word	0xfdffe008
 80024b0:	00c007ff 	.word	0x00c007ff
	...

080024c0 <sdcRead>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 80024c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80024c4:	460e      	mov	r6, r1
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 80024c6:	6a87      	ldr	r7, [r0, #40]	; 0x28
 80024c8:	1e59      	subs	r1, r3, #1
 80024ca:	4431      	add	r1, r6
 80024cc:	42b9      	cmp	r1, r7
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 80024ce:	b082      	sub	sp, #8
 80024d0:	4604      	mov	r4, r0
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 80024d2:	d907      	bls.n	80024e4 <sdcRead+0x24>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 80024d4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80024d6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80024da:	6343      	str	r3, [r0, #52]	; 0x34
    return HAL_FAILED;
 80024dc:	2001      	movs	r0, #1
  status = sdc_lld_read(sdcp, startblk, buf, n);

  /* Read operation finished.*/
  sdcp->state = BLK_READY;
  return status;
}
 80024de:	b002      	add	sp, #8
 80024e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80024e4:	4615      	mov	r5, r2
    sdcp->errors |= SDC_OVERFLOW_ERROR;
    return HAL_FAILED;
  }

  /* Read operation in progress.*/
  sdcp->state = BLK_READING;
 80024e6:	2206      	movs	r2, #6
 80024e8:	7102      	strb	r2, [r0, #4]
 */
bool sdc_lld_read(SDCDriver *sdcp, uint32_t startblk,
                  uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 80024ea:	07aa      	lsls	r2, r5, #30
 80024ec:	d024      	beq.n	8002538 <sdcRead+0x78>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 80024ee:	b30b      	cbz	r3, 8002534 <sdcRead+0x74>
                          uint8_t *buf, uint32_t blocks) {
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 80024f0:	4f19      	ldr	r7, [pc, #100]	; (8002558 <sdcRead+0x98>)
 80024f2:	eb06 0803 	add.w	r8, r6, r3
 80024f6:	6ca2      	ldr	r2, [r4, #72]	; 0x48

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 80024f8:	4620      	mov	r0, r4
                          uint8_t *buf, uint32_t blocks) {
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 80024fa:	6257      	str	r7, [r2, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 80024fc:	f7fe fc58 	bl	8000db0 <_sdc_wait_for_transfer_state>
 8002500:	b128      	cbz	r0, 800250e <sdcRead+0x4e>
#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
        return HAL_FAILED;
 8002502:	2001      	movs	r0, #1

  status = sdc_lld_read(sdcp, startblk, buf, n);

  /* Read operation finished.*/
  sdcp->state = BLK_READY;
 8002504:	2305      	movs	r3, #5
 8002506:	7123      	strb	r3, [r4, #4]
  return status;
}
 8002508:	b002      	add	sp, #8
 800250a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800250e:	4631      	mov	r1, r6
 8002510:	4a12      	ldr	r2, [pc, #72]	; (800255c <sdcRead+0x9c>)
 8002512:	4620      	mov	r0, r4
 8002514:	2301      	movs	r3, #1
 8002516:	f7ff ff7b 	bl	8002410 <sdc_lld_read_aligned.part.4>
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
      buf += MMCSD_BLOCK_SIZE;
      startblk++;
 800251a:	3601      	adds	r6, #1
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
        return HAL_FAILED;
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
 800251c:	490f      	ldr	r1, [pc, #60]	; (800255c <sdcRead+0x9c>)
 800251e:	f44f 7200 	mov.w	r2, #512	; 0x200

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
 8002522:	2800      	cmp	r0, #0
 8002524:	d1ed      	bne.n	8002502 <sdcRead+0x42>
        return HAL_FAILED;
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
 8002526:	4628      	mov	r0, r5
 8002528:	f7fd fec2 	bl	80002b0 <memcpy>
                  uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800252c:	4546      	cmp	r6, r8
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
        return HAL_FAILED;
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
      buf += MMCSD_BLOCK_SIZE;
 800252e:	f505 7500 	add.w	r5, r5, #512	; 0x200
                  uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 8002532:	d1e0      	bne.n	80024f6 <sdcRead+0x36>
        return HAL_FAILED;
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
      buf += MMCSD_BLOCK_SIZE;
      startblk++;
    }
    return HAL_SUCCESS;
 8002534:	2000      	movs	r0, #0
 8002536:	e7e5      	b.n	8002504 <sdcRead+0x44>
                          uint8_t *buf, uint32_t blocks) {
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 8002538:	6c82      	ldr	r2, [r0, #72]	; 0x48
 800253a:	4907      	ldr	r1, [pc, #28]	; (8002558 <sdcRead+0x98>)
 800253c:	6251      	str	r1, [r2, #36]	; 0x24
 800253e:	9301      	str	r3, [sp, #4]

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 8002540:	f7fe fc36 	bl	8000db0 <_sdc_wait_for_transfer_state>
 8002544:	9b01      	ldr	r3, [sp, #4]
 8002546:	2800      	cmp	r0, #0
 8002548:	d1db      	bne.n	8002502 <sdcRead+0x42>
 800254a:	4631      	mov	r1, r6
 800254c:	462a      	mov	r2, r5
 800254e:	4620      	mov	r0, r4
 8002550:	f7ff ff5e 	bl	8002410 <sdc_lld_read_aligned.part.4>
 8002554:	e7d6      	b.n	8002504 <sdcRead+0x44>
 8002556:	bf00      	nop
 8002558:	000927c0 	.word	0x000927c0
 800255c:	20000800 	.word	0x20000800

08002560 <sdc_lld_read_special>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_special(SDCDriver *sdcp, uint8_t *buf, size_t bytes,
                          uint8_t cmd, uint32_t arg) {
 8002560:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 */
static bool sdc_lld_prepare_read_bytes(SDCDriver *sdcp,
                                       uint8_t *buf, uint32_t bytes) {
  osalDbgCheck(bytes < 0x1000000);

  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 8002564:	6c85      	ldr	r5, [r0, #72]	; 0x48
 8002566:	4e22      	ldr	r6, [pc, #136]	; (80025f0 <sdc_lld_read_special+0x90>)
 8002568:	626e      	str	r6, [r5, #36]	; 0x24
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_special(SDCDriver *sdcp, uint8_t *buf, size_t bytes,
                          uint8_t cmd, uint32_t arg) {
 800256a:	b083      	sub	sp, #12
 800256c:	4604      	mov	r4, r0
 800256e:	460e      	mov	r6, r1
 8002570:	4617      	mov	r7, r2
 8002572:	4698      	mov	r8, r3
  osalDbgCheck(bytes < 0x1000000);

  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 8002574:	f7fe fc1c 	bl	8000db0 <_sdc_wait_for_transfer_state>
 8002578:	2800      	cmp	r0, #0
 800257a:	d136      	bne.n	80025ea <sdc_lld_read_special+0x8a>
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800257c:	6c62      	ldr	r2, [r4, #68]	; 0x44
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 800257e:	6c23      	ldr	r3, [r4, #64]	; 0x40
  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8002580:	6812      	ldr	r2, [r2, #0]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8002582:	6ca5      	ldr	r5, [r4, #72]	; 0x48
  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
    return HAL_FAILED;

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8002584:	60d6      	str	r6, [r2, #12]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
 8002586:	08b9      	lsrs	r1, r7, #2
 8002588:	6051      	str	r1, [r2, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 800258a:	6013      	str	r3, [r2, #0]
  dmaStreamEnable(sdcp->dma);
 800258c:	6810      	ldr	r0, [r2, #0]

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 800258e:	f8df 9068 	ldr.w	r9, [pc, #104]	; 80025f8 <sdc_lld_read_special+0x98>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);
 8002592:	f040 0001 	orr.w	r0, r0, #1

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 8002596:	f240 3c2a 	movw	ip, #810	; 0x32a
                      SDIO_MASK_RXOVERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = bytes;

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 800259a:	f04f 0e0f 	mov.w	lr, #15
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
    goto error;

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 800259e:	ae01      	add	r6, sp, #4

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);
 80025a0:	6010      	str	r0, [r2, #0]
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
    goto error;

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 80025a2:	4641      	mov	r1, r8
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80025a4:	f8c5 9038 	str.w	r9, [r5, #56]	; 0x38
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
    goto error;

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 80025a8:	4633      	mov	r3, r6
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  dmaStreamEnable(sdcp->dma);

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 80025aa:	f8c5 c03c 	str.w	ip, [r5, #60]	; 0x3c
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
    goto error;

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 80025ae:	4620      	mov	r0, r4
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
                      SDIO_MASK_DTIMEOUTIE |
                      SDIO_MASK_STBITERRIE |
                      SDIO_MASK_RXOVERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = bytes;
 80025b0:	62af      	str	r7, [r5, #40]	; 0x28
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
    goto error;

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 80025b2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
                      SDIO_MASK_RXOVERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = bytes;

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 80025b4:	f8c5 e02c 	str.w	lr, [r5, #44]	; 0x2c
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
    goto error;

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 80025b8:	f7ff fdea 	bl	8002190 <sdc_lld_send_cmd_short_crc>
 80025bc:	b140      	cbz	r0, 80025d0 <sdc_lld_read_special+0x70>
    goto error;

  return HAL_SUCCESS;

error:
  sdc_lld_error_cleanup(sdcp, 1, resp);
 80025be:	4620      	mov	r0, r4
 80025c0:	4632      	mov	r2, r6
 80025c2:	2101      	movs	r1, #1
 80025c4:	f7ff fdfc 	bl	80021c0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 80025c8:	2001      	movs	r0, #1
}
 80025ca:	b003      	add	sp, #12
 80025cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
    goto error;

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
                                 || MMCSD_R1_ERROR(resp[0]))
 80025d0:	9a01      	ldr	r2, [sp, #4]
 80025d2:	4b08      	ldr	r3, [pc, #32]	; (80025f4 <sdc_lld_read_special+0x94>)
 80025d4:	4013      	ands	r3, r2
 80025d6:	2b00      	cmp	r3, #0
 80025d8:	d1f1      	bne.n	80025be <sdc_lld_read_special+0x5e>
    goto error;

  if (sdc_lld_wait_transaction_end(sdcp, 1, resp))
 80025da:	4620      	mov	r0, r4
 80025dc:	2101      	movs	r1, #1
 80025de:	4632      	mov	r2, r6
 80025e0:	f7ff fe26 	bl	8002230 <sdc_lld_wait_transaction_end>
 80025e4:	2800      	cmp	r0, #0
 80025e6:	d1ea      	bne.n	80025be <sdc_lld_read_special+0x5e>
 80025e8:	e7ef      	b.n	80025ca <sdc_lld_read_special+0x6a>
 80025ea:	ae01      	add	r6, sp, #4
 80025ec:	e7e7      	b.n	80025be <sdc_lld_read_special+0x5e>
 80025ee:	bf00      	nop
 80025f0:	000927c0 	.word	0x000927c0
 80025f4:	fdffe008 	.word	0xfdffe008
 80025f8:	00c007ff 	.word	0x00c007ff
 80025fc:	00000000 	.word	0x00000000

08002600 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8002600:	b5f0      	push	{r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 8002602:	4f29      	ldr	r7, [pc, #164]	; (80026a8 <dmaStreamAllocate+0xa8>)
 8002604:	7a46      	ldrb	r6, [r0, #9]
 8002606:	683d      	ldr	r5, [r7, #0]
 8002608:	2401      	movs	r4, #1
 800260a:	fa04 fe06 	lsl.w	lr, r4, r6
 800260e:	ea1e 0f05 	tst.w	lr, r5
 8002612:	d144      	bne.n	800269e <dmaStreamAllocate+0x9e>
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002614:	4c25      	ldr	r4, [pc, #148]	; (80026ac <dmaStreamAllocate+0xac>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8002616:	ea4e 0505 	orr.w	r5, lr, r5
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800261a:	eb04 0cc6 	add.w	ip, r4, r6, lsl #3
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 800261e:	f015 0fff 	tst.w	r5, #255	; 0xff
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8002622:	603d      	str	r5, [r7, #0]
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002624:	f844 2036 	str.w	r2, [r4, r6, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002628:	f8cc 3004 	str.w	r3, [ip, #4]
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 800262c:	d004      	beq.n	8002638 <dmaStreamAllocate+0x38>
    rccEnableDMA1(FALSE);
 800262e:	4c20      	ldr	r4, [pc, #128]	; (80026b0 <dmaStreamAllocate+0xb0>)
 8002630:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002632:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002636:	6323      	str	r3, [r4, #48]	; 0x30
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
 8002638:	f415 4f7f 	tst.w	r5, #65280	; 0xff00
 800263c:	d129      	bne.n	8002692 <dmaStreamAllocate+0x92>
    rccEnableDMA2(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800263e:	6805      	ldr	r5, [r0, #0]
 8002640:	682b      	ldr	r3, [r5, #0]
 8002642:	f023 031f 	bic.w	r3, r3, #31
 8002646:	602b      	str	r3, [r5, #0]
 8002648:	682b      	ldr	r3, [r5, #0]
 800264a:	f013 0301 	ands.w	r3, r3, #1
 800264e:	d1fb      	bne.n	8002648 <dmaStreamAllocate+0x48>
 8002650:	7a07      	ldrb	r7, [r0, #8]
 8002652:	6844      	ldr	r4, [r0, #4]
 8002654:	263d      	movs	r6, #61	; 0x3d
 8002656:	40be      	lsls	r6, r7
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8002658:	2721      	movs	r7, #33	; 0x21
    rccEnableDMA1(FALSE);
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
    rccEnableDMA2(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800265a:	6026      	str	r6, [r4, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 800265c:	602b      	str	r3, [r5, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800265e:	616f      	str	r7, [r5, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 8002660:	b1fa      	cbz	r2, 80026a2 <dmaStreamAllocate+0xa2>
    nvicEnableVector(dmastp->vector, priority);
 8002662:	7a80      	ldrb	r0, [r0, #10]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8002664:	0942      	lsrs	r2, r0, #5
 8002666:	0092      	lsls	r2, r2, #2
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8002668:	f100 4560 	add.w	r5, r0, #3758096384	; 0xe0000000
 800266c:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 8002670:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8002674:	f505 4561 	add.w	r5, r5, #57600	; 0xe100
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8002678:	f000 001f 	and.w	r0, r0, #31
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800267c:	0109      	lsls	r1, r1, #4
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800267e:	2401      	movs	r4, #1
 8002680:	4084      	lsls	r4, r0
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8002682:	b2c9      	uxtb	r1, r1
 8002684:	f885 1300 	strb.w	r1, [r5, #768]	; 0x300
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8002688:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 800268c:	6014      	str	r4, [r2, #0]
 800268e:	4618      	mov	r0, r3
 8002690:	bdf0      	pop	{r4, r5, r6, r7, pc}

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
    rccEnableDMA1(FALSE);
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
    rccEnableDMA2(FALSE);
 8002692:	4c07      	ldr	r4, [pc, #28]	; (80026b0 <dmaStreamAllocate+0xb0>)
 8002694:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002696:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800269a:	6323      	str	r3, [r4, #48]	; 0x30
 800269c:	e7cf      	b.n	800263e <dmaStreamAllocate+0x3e>

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;
 800269e:	4620      	mov	r0, r4
 80026a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  dmaStreamDisable(dmastp);
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 80026a2:	4610      	mov	r0, r2
    nvicEnableVector(dmastp->vector, priority);

  return FALSE;
}
 80026a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80026a6:	bf00      	nop
 80026a8:	20001038 	.word	0x20001038
 80026ac:	20000fb8 	.word	0x20000fb8
 80026b0:	40023800 	.word	0x40023800
	...

080026c0 <Thread1>:

/*
 * LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 80026c0:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80026c2:	4b09      	ldr	r3, [pc, #36]	; (80026e8 <Thread1+0x28>)
 80026c4:	4a09      	ldr	r2, [pc, #36]	; (80026ec <Thread1+0x2c>)
 80026c6:	699b      	ldr	r3, [r3, #24]

  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palClearPad(GPIOD, 12);
 80026c8:	4c09      	ldr	r4, [pc, #36]	; (80026f0 <Thread1+0x30>)
 80026ca:	619a      	str	r2, [r3, #24]
 80026cc:	f44f 5580 	mov.w	r5, #4096	; 0x1000
 80026d0:	462e      	mov	r6, r5
 80026d2:	8366      	strh	r6, [r4, #26]
    chThdSleepMilliseconds(500);
 80026d4:	f241 3088 	movw	r0, #5000	; 0x1388
 80026d8:	f7fe f96a 	bl	80009b0 <chThdSleep>
    palSetPad(GPIOD, 12);
 80026dc:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(500);
 80026de:	f241 3088 	movw	r0, #5000	; 0x1388
 80026e2:	f7fe f965 	bl	80009b0 <chThdSleep>
 80026e6:	e7f4      	b.n	80026d2 <Thread1+0x12>
 80026e8:	20001140 	.word	0x20001140
 80026ec:	08004570 	.word	0x08004570
 80026f0:	40020c00 	.word	0x40020c00
	...

08002700 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8002700:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8002704:	b097      	sub	sp, #92	; 0x5c
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8002706:	4bc2      	ldr	r3, [pc, #776]	; (8002a10 <main+0x310>)
  arra[1] = 0x22;
  arra[2] = 0x33;
  arra[3] = 0x44;
  arra[4] = 0x55;
  arra[5] = 0x66;
  arra[6] = 0x77;
 8002708:	2477      	movs	r4, #119	; 0x77
  arra[7] = 0x88;
 800270a:	2088      	movs	r0, #136	; 0x88
  arra[8] = 0x99;
 800270c:	2199      	movs	r1, #153	; 0x99
  arra[9] = 0xBB;
 800270e:	22bb      	movs	r2, #187	; 0xbb
/*
 * Application entry point.
 */
int main(void) {
  uint8_t arra[10];
  arra[0] = 0x11;
 8002710:	f04f 0811 	mov.w	r8, #17
  arra[1] = 0x22;
 8002714:	f04f 0c22 	mov.w	ip, #34	; 0x22
  arra[2] = 0x33;
 8002718:	f04f 0e33 	mov.w	lr, #51	; 0x33
  arra[3] = 0x44;
 800271c:	2744      	movs	r7, #68	; 0x44
  arra[4] = 0x55;
 800271e:	2655      	movs	r6, #85	; 0x55
  arra[5] = 0x66;
 8002720:	2566      	movs	r5, #102	; 0x66
  arra[6] = 0x77;
 8002722:	f88d 401e 	strb.w	r4, [sp, #30]
  arra[7] = 0x88;
  arra[8] = 0x99;
 8002726:	f88d 1020 	strb.w	r1, [sp, #32]
  arra[9] = 0xBB;
 800272a:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
/*
 * Application entry point.
 */
int main(void) {
  uint8_t arra[10];
  arra[0] = 0x11;
 800272e:	f88d 8018 	strb.w	r8, [sp, #24]
  arra[1] = 0x22;
 8002732:	f88d c019 	strb.w	ip, [sp, #25]
  arra[2] = 0x33;
 8002736:	f88d e01a 	strb.w	lr, [sp, #26]
  arra[3] = 0x44;
 800273a:	f88d 701b 	strb.w	r7, [sp, #27]
  arra[4] = 0x55;
 800273e:	f88d 601c 	strb.w	r6, [sp, #28]
  arra[5] = 0x66;
 8002742:	f88d 501d 	strb.w	r5, [sp, #29]
  arra[6] = 0x77;
  arra[7] = 0x88;
 8002746:	f88d 001f 	strb.w	r0, [sp, #31]
 800274a:	f04f 31ff 	mov.w	r1, #4294967295
 800274e:	2200      	movs	r2, #0
 8002750:	6918      	ldr	r0, [r3, #16]
 8002752:	6119      	str	r1, [r3, #16]
 8002754:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8002756:	6958      	ldr	r0, [r3, #20]
 8002758:	6159      	str	r1, [r3, #20]
 800275a:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800275c:	6a18      	ldr	r0, [r3, #32]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800275e:	4cad      	ldr	r4, [pc, #692]	; (8002a14 <main+0x314>)

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
  rccResetAHB2(~0);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8002760:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8002764:	6218      	str	r0, [r3, #32]
 8002766:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8002768:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800276a:	6259      	str	r1, [r3, #36]	; 0x24
 800276c:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800276e:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8002770:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8002774:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002776:	6821      	ldr	r1, [r4, #0]
 8002778:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800277c:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800277e:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8002780:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8002784:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8002788:	d003      	beq.n	8002792 <main+0x92>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800278a:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800278e:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8002790:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8002792:	48a0      	ldr	r0, [pc, #640]	; (8002a14 <main+0x314>)
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8002794:	4ca0      	ldr	r4, [pc, #640]	; (8002a18 <main+0x318>)
 8002796:	6843      	ldr	r3, [r0, #4]
 8002798:	4ea0      	ldr	r6, [pc, #640]	; (8002a1c <main+0x31c>)
 800279a:	4da1      	ldr	r5, [pc, #644]	; (8002a20 <main+0x320>)
 800279c:	2100      	movs	r1, #0
 800279e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80027a2:	6043      	str	r3, [r0, #4]
 80027a4:	460a      	mov	r2, r1
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80027a6:	468c      	mov	ip, r1
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 80027a8:	6021      	str	r1, [r4, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
 80027aa:	58b3      	ldr	r3, [r6, r2]
 80027ac:	f8df 926c 	ldr.w	r9, [pc, #620]	; 8002a1c <main+0x31c>
 80027b0:	6019      	str	r1, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
 80027b2:	f845 103c 	str.w	r1, [r5, ip, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80027b6:	f10c 0c01 	add.w	ip, ip, #1
 80027ba:	f1bc 0f10 	cmp.w	ip, #16
 80027be:	f102 020c 	add.w	r2, r2, #12
    _stm32_dma_streams[i].stream->CR = 0;
 80027c2:	f04f 0300 	mov.w	r3, #0
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80027c6:	d1f0      	bne.n	80027aa <main+0xaa>
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 80027c8:	f8df b2b0 	ldr.w	fp, [pc, #688]	; 8002a7c <main+0x37c>
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
 80027cc:	4f95      	ldr	r7, [pc, #596]	; (8002a24 <main+0x324>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80027ce:	f8df 8240 	ldr.w	r8, [pc, #576]	; 8002a10 <main+0x310>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80027d2:	4995      	ldr	r1, [pc, #596]	; (8002a28 <main+0x328>)
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 80027d4:	4d95      	ldr	r5, [pc, #596]	; (8002a2c <main+0x32c>)
 80027d6:	f8df a2a8 	ldr.w	sl, [pc, #680]	; 8002a80 <main+0x380>
 80027da:	4e95      	ldr	r6, [pc, #596]	; (8002a30 <main+0x330>)
 80027dc:	4c95      	ldr	r4, [pc, #596]	; (8002a34 <main+0x334>)
 80027de:	4896      	ldr	r0, [pc, #600]	; (8002a38 <main+0x338>)
 80027e0:	4a96      	ldr	r2, [pc, #600]	; (8002a3c <main+0x33c>)
  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 80027e2:	f04f 3eff 	mov.w	lr, #4294967295
 80027e6:	f8cb e008 	str.w	lr, [fp, #8]
  DMA1->HIFCR = 0xFFFFFFFF;
 80027ea:	f8cb e00c 	str.w	lr, [fp, #12]
  DMA2->LIFCR = 0xFFFFFFFF;
 80027ee:	f8c7 e008 	str.w	lr, [r7, #8]
  DMA2->HIFCR = 0xFFFFFFFF;
 80027f2:	f8c7 e00c 	str.w	lr, [r7, #12]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80027f6:	f8d8 7030 	ldr.w	r7, [r8, #48]	; 0x30
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80027fa:	f8df b288 	ldr.w	fp, [pc, #648]	; 8002a84 <main+0x384>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80027fe:	f047 079f 	orr.w	r7, r7, #159	; 0x9f
 8002802:	f8c8 7030 	str.w	r7, [r8, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8002806:	f8d8 7050 	ldr.w	r7, [r8, #80]	; 0x50
 800280a:	f047 079f 	orr.w	r7, r7, #159	; 0x9f
 800280e:	f8c8 7050 	str.w	r7, [r8, #80]	; 0x50
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8002812:	f46f 678a 	mvn.w	r7, #1104	; 0x450
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002816:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002818:	608f      	str	r7, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 800281a:	4f89      	ldr	r7, [pc, #548]	; (8002a40 <main+0x340>)
 800281c:	60cf      	str	r7, [r1, #12]
  gpiop->ODR     = config->odr;
 800281e:	f64f 77df 	movw	r7, #65503	; 0xffdf
 8002822:	614f      	str	r7, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8002824:	f44f 47ee 	mov.w	r7, #30464	; 0x7700
 8002828:	620f      	str	r7, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800282a:	f44f 272a 	mov.w	r7, #696320	; 0xaa000
 800282e:	624f      	str	r7, [r1, #36]	; 0x24
 8002830:	9500      	str	r5, [sp, #0]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8002832:	4f84      	ldr	r7, [pc, #528]	; (8002a44 <main+0x344>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8002834:	f8c1 b000 	str.w	fp, [r1]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8002838:	f46f 2182 	mvn.w	r1, #266240	; 0x41000
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800283c:	f8ca 3004 	str.w	r3, [sl, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002840:	f8ca 1008 	str.w	r1, [sl, #8]
  gpiop->PUPDR   = config->pupdr;
 8002844:	f8ca 700c 	str.w	r7, [sl, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8002848:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800284c:	f64f 77ff 	movw	r7, #65535	; 0xffff
 8002850:	f8ca 7014 	str.w	r7, [sl, #20]
  gpiop->AFRL    = config->afrl;
 8002854:	f8ca 1020 	str.w	r1, [sl, #32]
  gpiop->AFRH    = config->afrh;
 8002858:	2740      	movs	r7, #64	; 0x40
  gpiop->MODER   = config->moder;
 800285a:	497b      	ldr	r1, [pc, #492]	; (8002a48 <main+0x348>)
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 800285c:	f8ca 7024 	str.w	r7, [sl, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002860:	f8ca 1000 	str.w	r1, [sl]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8002864:	4979      	ldr	r1, [pc, #484]	; (8002a4c <main+0x34c>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002866:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002868:	f8c6 e008 	str.w	lr, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 800286c:	60f1      	str	r1, [r6, #12]
  gpiop->ODR     = config->odr;
 800286e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8002872:	6171      	str	r1, [r6, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8002874:	f06f 4baa 	mvn.w	fp, #1426063360	; 0x55000000
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8002878:	6233      	str	r3, [r6, #32]
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800287a:	f640 71ff 	movw	r1, #4095	; 0xfff
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 800287e:	6273      	str	r3, [r6, #36]	; 0x24

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8002880:	4f73      	ldr	r7, [pc, #460]	; (8002a50 <main+0x350>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8002882:	6033      	str	r3, [r6, #0]
 8002884:	f04f 46aa 	mov.w	r6, #1426063360	; 0x55000000
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002888:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800288a:	f8c4 b008 	str.w	fp, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 800288e:	60e7      	str	r7, [r4, #12]
 8002890:	f04f 0b45 	mov.w	fp, #69	; 0x45
  gpiop->ODR     = config->odr;
 8002894:	6161      	str	r1, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8002896:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8002898:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800289a:	6026      	str	r6, [r4, #0]
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800289c:	f64f 74ff 	movw	r4, #65535	; 0xffff
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80028a0:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80028a2:	f8c0 e008 	str.w	lr, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 80028a6:	f8c0 b00c 	str.w	fp, [r0, #12]
  gpiop->ODR     = config->odr;
 80028aa:	6144      	str	r4, [r0, #20]
  gpiop->AFRL    = config->afrl;
 80028ac:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 80028ae:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80028b0:	6003      	str	r3, [r0, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80028b2:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80028b4:	f8c2 e008 	str.w	lr, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80028b8:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 80028ba:	6154      	str	r4, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80028bc:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80028be:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80028c0:	6013      	str	r3, [r2, #0]
 80028c2:	9a00      	ldr	r2, [sp, #0]
 80028c4:	4963      	ldr	r1, [pc, #396]	; (8002a54 <main+0x354>)
 80028c6:	f842 1b04 	str.w	r1, [r2], #4
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 80028ca:	4e63      	ldr	r6, [pc, #396]	; (8002a58 <main+0x358>)
 *
 * @init
 */
void sdcObjectInit(SDCDriver *sdcp) {

  sdcp->vmt      = &sdc_vmt;
 80028cc:	4f63      	ldr	r7, [pc, #396]	; (8002a5c <main+0x35c>)
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80028ce:	616b      	str	r3, [r5, #20]
 80028d0:	4611      	mov	r1, r2
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80028d2:	6069      	str	r1, [r5, #4]
#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 80028d4:	f109 0148 	add.w	r1, r9, #72	; 0x48
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80028d8:	f105 0a0c 	add.w	sl, r5, #12
 80028dc:	6331      	str	r1, [r6, #48]	; 0x30
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 80028de:	4a60      	ldr	r2, [pc, #384]	; (8002a60 <main+0x360>)
 *
 * @notapi
 */
void spi_lld_init(void) {

  dummytx = 0xFFFF;
 80028e0:	4960      	ldr	r1, [pc, #384]	; (8002a64 <main+0x364>)
 80028e2:	f8c5 a00c 	str.w	sl, [r5, #12]
  iqp->q_buffer  = bp;
 80028e6:	f105 0454 	add.w	r4, r5, #84	; 0x54
  tqp->p_prev = (thread_t *)tqp;
 80028ea:	f8c5 a010 	str.w	sl, [r5, #16]
 80028ee:	6372      	str	r2, [r6, #52]	; 0x34
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80028f0:	f106 0a0c 	add.w	sl, r6, #12
 80028f4:	2201      	movs	r2, #1
 80028f6:	61ac      	str	r4, [r5, #24]
  iqp->q_rdptr   = bp;
 80028f8:	626c      	str	r4, [r5, #36]	; 0x24
  i2cp->config = NULL;
 80028fa:	6073      	str	r3, [r6, #4]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 80028fc:	6173      	str	r3, [r6, #20]
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 80028fe:	61f3      	str	r3, [r6, #28]
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8002900:	f8c6 902c 	str.w	r9, [r6, #44]	; 0x2c
 8002904:	f8c6 a00c 	str.w	sl, [r6, #12]
  tqp->p_prev = (thread_t *)tqp;
 8002908:	f8c6 a010 	str.w	sl, [r6, #16]
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 800290c:	7032      	strb	r2, [r6, #0]
 800290e:	f8a1 e000 	strh.w	lr, [r1]
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8002912:	4955      	ldr	r1, [pc, #340]	; (8002a68 <main+0x368>)
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 8002914:	4855      	ldr	r0, [pc, #340]	; (8002a6c <main+0x36c>)
  iqp->q_wrptr   = bp;
 8002916:	622c      	str	r4, [r5, #32]
 8002918:	f8df b16c 	ldr.w	fp, [pc, #364]	; 8002a88 <main+0x388>
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 800291c:	f8df a16c 	ldr.w	sl, [pc, #364]	; 8002a8c <main+0x38c>
 8002920:	f8c7 b000 	str.w	fp, [r7]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8002924:	f105 0474 	add.w	r4, r5, #116	; 0x74
 8002928:	642c      	str	r4, [r5, #64]	; 0x40
  oqp->q_notify  = onfy;
 800292a:	f8c5 a04c 	str.w	sl, [r5, #76]	; 0x4c

#if STM32_SPI_USE_SPI3
  spiObjectInit(&SPID3);
  SPID3.spi       = SPI3;
  SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
  SPID3.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI3_TX_DMA_STREAM);
 800292e:	f109 0454 	add.w	r4, r9, #84	; 0x54
 */
void sdc_lld_init(void) {

  sdcObjectInit(&SDCD1);
  SDCD1.thread = NULL;
  SDCD1.dma    = STM32_DMA_STREAM(STM32_SDC_SDIO_DMA_STREAM);
 8002932:	f109 0a84 	add.w	sl, r9, #132	; 0x84
 8002936:	6769      	str	r1, [r5, #116]	; 0x74
  SDCD1.sdio   = SDIO;
 8002938:	f8df b154 	ldr.w	fp, [pc, #340]	; 8002a90 <main+0x390>
#endif

#if STM32_SPI_USE_SPI3
  spiObjectInit(&SPID3);
  SPID3.spi       = SPI3;
  SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
 800293c:	f8c0 9020 	str.w	r9, [r0, #32]
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI3
  spiObjectInit(&SPID3);
  SPID3.spi       = SPI3;
 8002940:	f5a1 6100 	sub.w	r1, r1, #2048	; 0x800
 8002944:	61c1      	str	r1, [r0, #28]
  SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
  SPID3.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI3_TX_DMA_STREAM);
 8002946:	6244      	str	r4, [r0, #36]	; 0x24
 */
void sdc_lld_init(void) {

  sdcObjectInit(&SDCD1);
  SDCD1.thread = NULL;
  SDCD1.dma    = STM32_DMA_STREAM(STM32_SDC_SDIO_DMA_STREAM);
 8002948:	f8c7 a044 	str.w	sl, [r7, #68]	; 0x44
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800294c:	f100 040c 	add.w	r4, r0, #12
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8002950:	f105 0a64 	add.w	sl, r5, #100	; 0x64
  SDCD1.sdio   = SDIO;
 8002954:	f8c7 b048 	str.w	fp, [r7, #72]	; 0x48
                    STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID3.txdmamode = STM32_DMA_CR_CHSEL(SPI3_TX_DMA_CHANNEL) |
 8002958:	f8df 9138 	ldr.w	r9, [pc, #312]	; 8002a94 <main+0x394>
#if STM32_SPI_USE_SPI3
  spiObjectInit(&SPID3);
  SPID3.spi       = SPI3;
  SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
  SPID3.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI3_TX_DMA_STREAM);
  SPID3.rxdmamode = STM32_DMA_CR_CHSEL(SPI3_RX_DMA_CHANNEL) |
 800295c:	4944      	ldr	r1, [pc, #272]	; (8002a70 <main+0x370>)
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800295e:	f8c5 c038 	str.w	ip, [r5, #56]	; 0x38
 8002962:	f105 0b30 	add.w	fp, r5, #48	; 0x30
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8002966:	722a      	strb	r2, [r5, #8]
 8002968:	7002      	strb	r2, [r0, #0]
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 800296a:	62ab      	str	r3, [r5, #40]	; 0x28
  spip->config = NULL;
 800296c:	6043      	str	r3, [r0, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 800296e:	6083      	str	r3, [r0, #8]
 8002970:	6143      	str	r3, [r0, #20]
  sdcp->state    = BLK_STOP;
 8002972:	713a      	strb	r2, [r7, #4]
  sdcp->errors   = SDC_NO_ERROR;
 8002974:	637b      	str	r3, [r7, #52]	; 0x34
  sdcp->config   = NULL;
 8002976:	62fb      	str	r3, [r7, #44]	; 0x2c
  sdcp->capacity = 0;
 8002978:	62bb      	str	r3, [r7, #40]	; 0x28
 * @notapi
 */
void sdc_lld_init(void) {

  sdcObjectInit(&SDCD1);
  SDCD1.thread = NULL;
 800297a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800297c:	6281      	str	r1, [r0, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID3.txdmamode = STM32_DMA_CR_CHSEL(SPI3_TX_DMA_CHANNEL) |
 800297e:	f8c0 902c 	str.w	r9, [r0, #44]	; 0x2c
 8002982:	60c4      	str	r4, [r0, #12]
  tqp->p_prev = (thread_t *)tqp;
 8002984:	6104      	str	r4, [r0, #16]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8002986:	f8c5 a01c 	str.w	sl, [r5, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 800298a:	f8c5 a03c 	str.w	sl, [r5, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 800298e:	f8c5 a048 	str.w	sl, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8002992:	f8c5 a044 	str.w	sl, [r5, #68]	; 0x44
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8002996:	62ed      	str	r5, [r5, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8002998:	652d      	str	r5, [r5, #80]	; 0x50
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800299a:	f8c5 b030 	str.w	fp, [r5, #48]	; 0x30

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800299e:	f8d8 0040 	ldr.w	r0, [r8, #64]	; 0x40
  tqp->p_prev = (thread_t *)tqp;
 80029a2:	f8c5 b034 	str.w	fp, [r5, #52]	; 0x34
 80029a6:	4310      	orrs	r0, r2

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80029a8:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 8002a98 <main+0x398>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80029ac:	f8c8 0040 	str.w	r0, [r8, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80029b0:	f8db 0008 	ldr.w	r0, [fp, #8]
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80029b4:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 8002a9c <main+0x39c>
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 80029b8:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 8002aa0 <main+0x3a0>
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 80029bc:	4c2d      	ldr	r4, [pc, #180]	; (8002a74 <main+0x374>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80029be:	492e      	ldr	r1, [pc, #184]	; (8002a78 <main+0x378>)
 80029c0:	4310      	orrs	r0, r2
 80029c2:	f8cb 0008 	str.w	r0, [fp, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80029c6:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80029ca:	f242 0bcf 	movw	fp, #8399	; 0x20cf
 80029ce:	f8c0 b028 	str.w	fp, [r0, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80029d2:	f8c0 e02c 	str.w	lr, [r0, #44]	; 0x2c
 80029d6:	f04f 0b80 	mov.w	fp, #128	; 0x80
  STM32_ST_TIM->CCMR1  = 0;
 80029da:	6183      	str	r3, [r0, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80029dc:	6343      	str	r3, [r0, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80029de:	60c3      	str	r3, [r0, #12]
  STM32_ST_TIM->CR2    = 0;
 80029e0:	6043      	str	r3, [r0, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80029e2:	6142      	str	r2, [r0, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80029e4:	6002      	str	r2, [r0, #0]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80029e6:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 80029ea:	9201      	str	r2, [sp, #4]
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 80029ec:	f889 b31c 	strb.w	fp, [r9, #796]	; 0x31c
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80029f0:	f8c9 0180 	str.w	r0, [r9, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 80029f4:	f8c9 0000 	str.w	r0, [r9]
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80029f8:	f8ca 3008 	str.w	r3, [sl, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80029fc:	f8da b00c 	ldr.w	fp, [sl, #12]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 8002a00:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
 8002a04:	ea0b 0000 	and.w	r0, fp, r0
  reg_value  =  (reg_value                                 |
 8002a08:	4304      	orrs	r4, r0
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8002a0a:	f8ca 400c 	str.w	r4, [sl, #12]
 8002a0e:	e049      	b.n	8002aa4 <main+0x3a4>
 8002a10:	40023800 	.word	0x40023800
 8002a14:	40007000 	.word	0x40007000
 8002a18:	20001038 	.word	0x20001038
 8002a1c:	080044b0 	.word	0x080044b0
 8002a20:	20000fb8 	.word	0x20000fb8
 8002a24:	40026400 	.word	0x40026400
 8002a28:	40020000 	.word	0x40020000
 8002a2c:	200010c4 	.word	0x200010c4
 8002a30:	40020800 	.word	0x40020800
 8002a34:	40020c00 	.word	0x40020c00
 8002a38:	40021000 	.word	0x40021000
 8002a3c:	40021c00 	.word	0x40021c00
 8002a40:	64155105 	.word	0x64155105
 8002a44:	55514555 	.word	0x55514555
 8002a48:	00082080 	.word	0x00082080
 8002a4c:	51555555 	.word	0x51555555
 8002a50:	00555555 	.word	0x00555555
 8002a54:	080045a0 	.word	0x080045a0
 8002a58:	2000103c 	.word	0x2000103c
 8002a5c:	20001078 	.word	0x20001078
 8002a60:	40005400 	.word	0x40005400
 8002a64:	20000e34 	.word	0x20000e34
 8002a68:	40004400 	.word	0x40004400
 8002a6c:	20000f88 	.word	0x20000f88
 8002a70:	00010016 	.word	0x00010016
 8002a74:	05fa0300 	.word	0x05fa0300
 8002a78:	e000edf0 	.word	0xe000edf0
 8002a7c:	40026000 	.word	0x40026000
 8002a80:	40020400 	.word	0x40020400
 8002a84:	2a8004a0 	.word	0x2a8004a0
 8002a88:	08004480 	.word	0x08004480
 8002a8c:	080010c1 	.word	0x080010c1
 8002a90:	40012c00 	.word	0x40012c00
 8002a94:	00010046 	.word	0x00010046
 8002a98:	e0042000 	.word	0xe0042000
 8002a9c:	e000ed00 	.word	0xe000ed00
 8002aa0:	e000e100 	.word	0xe000e100

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8002aa4:	68c8      	ldr	r0, [r1, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8002aa6:	f8df b374 	ldr.w	fp, [pc, #884]	; 8002e1c <main+0x71c>
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002aaa:	4cd0      	ldr	r4, [pc, #832]	; (8002dec <main+0x6ec>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8002aac:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
 8002ab0:	60c8      	str	r0, [r1, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8002ab2:	f8db 0000 	ldr.w	r0, [fp]
  tqp->p_prev = (thread_t *)tqp;
 8002ab6:	6064      	str	r4, [r4, #4]
 8002ab8:	4310      	orrs	r0, r2
 8002aba:	f8cb 0000 	str.w	r0, [fp]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8002abe:	f04f 0220 	mov.w	r2, #32
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8002ac2:	f104 0b1c 	add.w	fp, r4, #28
 8002ac6:	f88a c01f 	strb.w	ip, [sl, #31]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8002aca:	a80c      	add	r0, sp, #48	; 0x30
 8002acc:	f88a 2022 	strb.w	r2, [sl, #34]	; 0x22
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 8002ad0:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8002ad4:	60a3      	str	r3, [r4, #8]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8002ad6:	62a3      	str	r3, [r4, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002ad8:	6024      	str	r4, [r4, #0]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8002ada:	6124      	str	r4, [r4, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8002adc:	6164      	str	r4, [r4, #20]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8002ade:	f04f 0a00 	mov.w	sl, #0
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8002ae2:	f8c4 b01c 	str.w	fp, [r4, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8002ae6:	f8c4 b020 	str.w	fp, [r4, #32]
 8002aea:	f04f 0b00 	mov.w	fp, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8002aee:	f8cd e030 	str.w	lr, [sp, #48]	; 0x30
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8002af2:	e9cd ab10 	strd	sl, fp, [sp, #64]	; 0x40
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8002af6:	6763      	str	r3, [r4, #116]	; 0x74
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8002af8:	930d      	str	r3, [sp, #52]	; 0x34
  tmp->last       = (rtcnt_t)0;
 8002afa:	930e      	str	r3, [sp, #56]	; 0x38
  tmp->n          = (ucnt_t)0;
 8002afc:	930f      	str	r3, [sp, #60]	; 0x3c
 8002afe:	9300      	str	r3, [sp, #0]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8002b00:	f000 fb8e 	bl	8003220 <chTMStartMeasurementX.constprop.51>
  chTMStopMeasurementX(&tm);
 8002b04:	a80c      	add	r0, sp, #48	; 0x30
 8002b06:	f7fd fd8b 	bl	8000620 <chTMStopMeasurementX>
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8002b0a:	48b9      	ldr	r0, [pc, #740]	; (8002df0 <main+0x6f0>)
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002b0c:	f8d4 a014 	ldr.w	sl, [r4, #20]
  ch.tm.offset = tm.last;
 8002b10:	990e      	ldr	r1, [sp, #56]	; 0x38
 8002b12:	f8c4 a044 	str.w	sl, [r4, #68]	; 0x44
 8002b16:	f100 0c10 	add.w	ip, r0, #16
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002b1a:	2340      	movs	r3, #64	; 0x40
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002b1c:	2240      	movs	r2, #64	; 0x40
 8002b1e:	f8c0 c010 	str.w	ip, [r0, #16]
  tqp->p_prev = (thread_t *)tqp;
 8002b22:	f8c0 c014 	str.w	ip, [r0, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002b26:	63a3      	str	r3, [r4, #56]	; 0x38
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002b28:	f104 0c30 	add.w	ip, r4, #48	; 0x30
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002b2c:	9b00      	ldr	r3, [sp, #0]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002b2e:	66e2      	str	r2, [r4, #108]	; 0x6c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002b30:	9a01      	ldr	r2, [sp, #4]
 8002b32:	6183      	str	r3, [r0, #24]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002b34:	f884 304d 	strb.w	r3, [r4, #77]	; 0x4d
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002b38:	66a3      	str	r3, [r4, #104]	; 0x68
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002b3a:	6663      	str	r3, [r4, #100]	; 0x64
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002b3c:	f884 204e 	strb.w	r2, [r4, #78]	; 0x4e
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002b40:	64a3      	str	r3, [r4, #72]	; 0x48
  REG_INSERT(tp);
 8002b42:	6424      	str	r4, [r4, #64]	; 0x40
 8002b44:	6761      	str	r1, [r4, #116]	; 0x74
 8002b46:	f8ca c010 	str.w	ip, [sl, #16]
 8002b4a:	f8c4 c014 	str.w	ip, [r4, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8002b4e:	f8c4 c018 	str.w	ip, [r4, #24]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002b52:	f104 0c54 	add.w	ip, r4, #84	; 0x54
 8002b56:	f8c4 c054 	str.w	ip, [r4, #84]	; 0x54
 8002b5a:	f8df c2c4 	ldr.w	ip, [pc, #708]	; 8002e20 <main+0x720>
 8002b5e:	f8c0 c000 	str.w	ip, [r0]
  default_heap.h_free.h.u.next = NULL;
 8002b62:	6083      	str	r3, [r0, #8]
  default_heap.h_free.h.size = 0;
 8002b64:	60c3      	str	r3, [r0, #12]
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002b66:	f8df e2bc 	ldr.w	lr, [pc, #700]	; 8002e24 <main+0x724>
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002b6a:	f8df b2bc 	ldr.w	fp, [pc, #700]	; 8002e28 <main+0x728>
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002b6e:	f8df a2bc 	ldr.w	sl, [pc, #700]	; 8002e2c <main+0x72c>
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8002b72:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002b76:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8002b7a:	65a0      	str	r0, [r4, #88]	; 0x58
  tqp->p_prev = (thread_t *)tqp;
 8002b7c:	65e0      	str	r0, [r4, #92]	; 0x5c
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002b7e:	489d      	ldr	r0, [pc, #628]	; (8002df4 <main+0x6f4>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002b80:	f02e 0e07 	bic.w	lr, lr, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002b84:	f02b 0b07 	bic.w	fp, fp, #7
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002b88:	f8ca e000 	str.w	lr, [sl]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002b8c:	f8c0 b000 	str.w	fp, [r0]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002b90:	f04f 0c02 	mov.w	ip, #2
 8002b94:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b98:	b662      	cpsie	i
 8002b9a:	69a1      	ldr	r1, [r4, #24]
 8002b9c:	4896      	ldr	r0, [pc, #600]	; (8002df8 <main+0x6f8>)
 8002b9e:	6188      	str	r0, [r1, #24]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002ba0:	2120      	movs	r1, #32
 8002ba2:	f381 8811 	msr	BASEPRI, r1
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002ba6:	f8d4 e014 	ldr.w	lr, [r4, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002baa:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
  tp->p_state = CH_STATE_WTSTART;
 8002bae:	f884 c094 	strb.w	ip, [r4, #148]	; 0x94
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002bb2:	f8c4 20b4 	str.w	r2, [r4, #180]	; 0xb4
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002bb6:	f884 2096 	strb.w	r2, [r4, #150]	; 0x96

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002bba:	f504 7c96 	add.w	ip, r4, #300	; 0x12c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002bbe:	f104 0278 	add.w	r2, r4, #120	; 0x78

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002bc2:	488e      	ldr	r0, [pc, #568]	; (8002dfc <main+0x6fc>)
 8002bc4:	f8df b268 	ldr.w	fp, [pc, #616]	; 8002e30 <main+0x730>
 8002bc8:	f8c4 3130 	str.w	r3, [r4, #304]	; 0x130
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002bcc:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002bd0:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002bd4:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002bd8:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002bdc:	f8c4 c084 	str.w	ip, [r4, #132]	; 0x84
 8002be0:	f8c4 012c 	str.w	r0, [r4, #300]	; 0x12c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002be4:	f8c4 e08c 	str.w	lr, [r4, #140]	; 0x8c
 8002be8:	f8c4 4088 	str.w	r4, [r4, #136]	; 0x88

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002bec:	f8c4 b14c 	str.w	fp, [r4, #332]	; 0x14c
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002bf0:	f104 0c9c 	add.w	ip, r4, #156	; 0x9c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002bf4:	f8ce 2010 	str.w	r2, [lr, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002bf8:	f104 0ea0 	add.w	lr, r4, #160	; 0xa0
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8002bfc:	4610      	mov	r0, r2
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002bfe:	f8c4 c09c 	str.w	ip, [r4, #156]	; 0x9c
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002c02:	f8c4 e0a0 	str.w	lr, [r4, #160]	; 0xa0
  tqp->p_prev = (thread_t *)tqp;
 8002c06:	f8c4 e0a4 	str.w	lr, [r4, #164]	; 0xa4
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002c0a:	9300      	str	r3, [sp, #0]
  REG_INSERT(tp);
 8002c0c:	6162      	str	r2, [r4, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8002c0e:	f000 fad7 	bl	80031c0 <chSchWakeupS.constprop.54>
 8002c12:	9b00      	ldr	r3, [sp, #0]
 8002c14:	f383 8811 	msr	BASEPRI, r3
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8002c18:	4a79      	ldr	r2, [pc, #484]	; (8002e00 <main+0x700>)
 8002c1a:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90

static uint8_t txbuf[2]={0}, rxbuf[2]={0};

void codec_hw_init(void)
{
  palSetPadMode(GPIOB,6,4);
 8002c1e:	2040      	movs	r0, #64	; 0x40
 8002c20:	9300      	str	r3, [sp, #0]
 8002c22:	f000 fb8d 	bl	8003340 <_pal_lld_setgroupmode.constprop.24>
  palSetPadMode(GPIOB,9,4);
 8002c26:	f44f 7000 	mov.w	r0, #512	; 0x200
 8002c2a:	f000 fb89 	bl	8003340 <_pal_lld_setgroupmode.constprop.24>
 8002c2e:	2320      	movs	r3, #32
 8002c30:	f383 8811 	msr	BASEPRI, r3
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8002c34:	f896 c000 	ldrb.w	ip, [r6]
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 8002c38:	4972      	ldr	r1, [pc, #456]	; (8002e04 <main+0x704>)
 8002c3a:	6071      	str	r1, [r6, #4]
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8002c3c:	f240 4056 	movw	r0, #1110	; 0x456
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8002c40:	f240 4216 	movw	r2, #1046	; 0x416
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8002c44:	f1bc 0f01 	cmp.w	ip, #1
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8002c48:	62b0      	str	r0, [r6, #40]	; 0x28
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8002c4a:	6272      	str	r2, [r6, #36]	; 0x24
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8002c4c:	f8d6 a034 	ldr.w	sl, [r6, #52]	; 0x34
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8002c50:	9b00      	ldr	r3, [sp, #0]
 8002c52:	f000 8228 	beq.w	80030a6 <main+0x9a6>
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8002c56:	4652      	mov	r2, sl
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8002c58:	6af0      	ldr	r0, [r6, #44]	; 0x2c
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8002c5a:	6b33      	ldr	r3, [r6, #48]	; 0x30
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8002c5c:	f8d0 8000 	ldr.w	r8, [r0]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8002c60:	f8d3 e000 	ldr.w	lr, [r3]
 * @notapi
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
 8002c64:	6848      	ldr	r0, [r1, #4]
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 8002c66:	f891 c008 	ldrb.w	ip, [r1, #8]
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8002c6a:	f10a 0310 	add.w	r3, sl, #16
 8002c6e:	f8c8 3008 	str.w	r3, [r8, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8002c72:	f8ce 3008 	str.w	r3, [lr, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8002c76:	f44f 4800 	mov.w	r8, #32768	; 0x8000
  dp->CR1 = 0;
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8002c7a:	f44f 6e10 	mov.w	lr, #2304	; 0x900
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
 8002c7e:	2300      	movs	r3, #0
  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8002c80:	f8ca 8000 	str.w	r8, [sl]
  dp->CR1 = 0;
 8002c84:	f8ca 3000 	str.w	r3, [sl]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8002c88:	f8ca e004 	str.w	lr, [sl, #4]
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 8002c8c:	f8d2 8004 	ldr.w	r8, [r2, #4]
 8002c90:	f64f 7ec0 	movw	lr, #65472	; 0xffc0
 8002c94:	ea08 0e0e 	and.w	lr, r8, lr
 8002c98:	f8c2 e004 	str.w	lr, [r2, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8002c9c:	f8d2 e004 	ldr.w	lr, [r2, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8002ca0:	f8df 8190 	ldr.w	r8, [pc, #400]	; 8002e34 <main+0x734>
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8002ca4:	f04e 0e2a 	orr.w	lr, lr, #42	; 0x2a

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8002ca8:	4540      	cmp	r0, r8
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8002caa:	f8c2 e004 	str.w	lr, [r2, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8002cae:	f340 81ef 	ble.w	8003090 <main+0x990>
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
  }
  else if (clock_speed <= 400000) {
 8002cb2:	f8df e184 	ldr.w	lr, [pc, #388]	; 8002e38 <main+0x738>
 8002cb6:	4570      	cmp	r0, lr
 8002cb8:	dc0b      	bgt.n	8002cd2 <main+0x5d2>
    /* Configure clock_div in fast mode.*/
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
 8002cba:	f1bc 0f02 	cmp.w	ip, #2
 8002cbe:	f000 8257 	beq.w	8003170 <main+0xa70>
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
 8002cc2:	f1bc 0f03 	cmp.w	ip, #3
 8002cc6:	f000 822b 	beq.w	8003120 <main+0xa20>
 8002cca:	f648 73ff 	movw	r3, #36863	; 0x8fff
    osalDbgAssert(clock_div >= 0x01,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 8002cce:	200d      	movs	r0, #13
 8002cd0:	6210      	str	r0, [r2, #32]
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");

  dp->CCR = regCCR;
 8002cd2:	61d3      	str	r3, [r2, #28]
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
 8002cd4:	7809      	ldrb	r1, [r1, #0]
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8002cd6:	6813      	ldr	r3, [r2, #0]
  switch (opmode) {
 8002cd8:	2902      	cmp	r1, #2
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8002cda:	b29b      	uxth	r3, r3
  switch (opmode) {
 8002cdc:	f000 81d2 	beq.w	8003084 <main+0x984>
 8002ce0:	2903      	cmp	r1, #3
 8002ce2:	f000 81cc 	beq.w	800307e <main+0x97e>
 8002ce6:	2901      	cmp	r1, #1
 8002ce8:	f000 81c5 	beq.w	8003076 <main+0x976>
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  }
  dp->CR1 = regCR1;
 8002cec:	6013      	str	r3, [r2, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8002cee:	f8da 3000 	ldr.w	r3, [sl]
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 8002cf2:	f04f 0902 	mov.w	r9, #2
 8002cf6:	f043 0301 	orr.w	r3, r3, #1
 8002cfa:	f8ca 3000 	str.w	r3, [sl]
 8002cfe:	f04f 0800 	mov.w	r8, #0
 8002d02:	f886 9000 	strb.w	r9, [r6]
 8002d06:	f388 8811 	msr	BASEPRI, r8
	codec_writeReg(0x1C, 0x80);
}

void codec_hw_reset(void)
{
	palClearPad(GPIOD, 4);
 8002d0a:	4e3f      	ldr	r6, [pc, #252]	; (8002e08 <main+0x708>)
 8002d0c:	f04f 0a10 	mov.w	sl, #16
 8002d10:	f8a6 a01a 	strh.w	sl, [r6, #26]
	chThdSleepMilliseconds(100);
 8002d14:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002d18:	f7fd fe4a 	bl	80009b0 <chThdSleep>
void codec_pwrCtl(uint8_t pwr)
{
	if (pwr)
		codec_writeReg(0x02, 0x9E);
	else
		codec_writeReg(0x02, 0x01);
 8002d1c:	4648      	mov	r0, r9

void codec_hw_reset(void)
{
	palClearPad(GPIOD, 4);
	chThdSleepMilliseconds(100);
	palSetPad(GPIOD, 4);
 8002d1e:	f8a6 a018 	strh.w	sl, [r6, #24]
void codec_pwrCtl(uint8_t pwr)
{
	if (pwr)
		codec_writeReg(0x02, 0x9E);
	else
		codec_writeReg(0x02, 0x01);
 8002d22:	2101      	movs	r1, #1
 8002d24:	f000 fee4 	bl	8003af0 <codec_writeReg>
void codec_muteCtl(uint8_t mute)
{
	if (mute)
		codec_writeReg(0x04, 0xFF);
	else
		codec_writeReg(0x04, 0xAF);
 8002d28:	2004      	movs	r0, #4
 8002d2a:	21af      	movs	r1, #175	; 0xaf
 8002d2c:	f000 fee0 	bl	8003af0 <codec_writeReg>
	codec_pwrCtl(0);

	codec_muteCtl(0);

	// Auto Detect Clock, MCLK/2
	codec_writeReg(0x05, 0x81);
 8002d30:	2005      	movs	r0, #5
 8002d32:	2181      	movs	r1, #129	; 0x81
 8002d34:	f000 fedc 	bl	8003af0 <codec_writeReg>

	// Slave Mode, I2S Data Format
	codec_writeReg(0x06, 0x04);
 8002d38:	2006      	movs	r0, #6
 8002d3a:	2104      	movs	r1, #4
 8002d3c:	f000 fed8 	bl	8003af0 <codec_writeReg>
}

void codec_pwrCtl(uint8_t pwr)
{
	if (pwr)
		codec_writeReg(0x02, 0x9E);
 8002d40:	4648      	mov	r0, r9
 8002d42:	219e      	movs	r1, #158	; 0x9e
 8002d44:	f000 fed4 	bl	8003af0 <codec_writeReg>
		codec_writeReg(0x20, vol-0xE7);
		codec_writeReg(0x21, vol-0xE7);
	}
	else
	{
		codec_writeReg(0x20, vol+0x19);
 8002d48:	2020      	movs	r0, #32
 8002d4a:	21e1      	movs	r1, #225	; 0xe1
 8002d4c:	f000 fed0 	bl	8003af0 <codec_writeReg>
		codec_writeReg(0x21, vol+0x19);
 8002d50:	2021      	movs	r0, #33	; 0x21
 8002d52:	21e1      	movs	r1, #225	; 0xe1
 8002d54:	f000 fecc 	bl	8003af0 <codec_writeReg>
	codec_pwrCtl(1);

	codec_volCtl(200);

	// Adjust PCM Volume
	codec_writeReg(0x1A, 0x0A);
 8002d58:	201a      	movs	r0, #26
 8002d5a:	210a      	movs	r1, #10
 8002d5c:	f000 fec8 	bl	8003af0 <codec_writeReg>
	codec_writeReg(0x1B, 0x0A);
 8002d60:	201b      	movs	r0, #27
 8002d62:	210a      	movs	r1, #10
 8002d64:	f000 fec4 	bl	8003af0 <codec_writeReg>

	// Disable the analog soft ramp
	codec_writeReg(0x0A, 0x00);
 8002d68:	4641      	mov	r1, r8
 8002d6a:	200a      	movs	r0, #10
 8002d6c:	f000 fec0 	bl	8003af0 <codec_writeReg>

	// Disable the digital soft ramp
	codec_writeReg(0x0E, 0x04);
 8002d70:	200e      	movs	r0, #14
 8002d72:	2104      	movs	r1, #4
 8002d74:	f000 febc 	bl	8003af0 <codec_writeReg>

	// Disable the limiter attack level
	codec_writeReg(0x27, 0x00);
 8002d78:	4641      	mov	r1, r8
 8002d7a:	2027      	movs	r0, #39	; 0x27
 8002d7c:	f000 feb8 	bl	8003af0 <codec_writeReg>

	codec_writeReg(0x1C, 0x80);
 8002d80:	201c      	movs	r0, #28
 8002d82:	2180      	movs	r1, #128	; 0x80
 8002d84:	f000 feb4 	bl	8003af0 <codec_writeReg>
 8002d88:	2320      	movs	r3, #32
 8002d8a:	f383 8811 	msr	BASEPRI, r3
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8002d8e:	7a2b      	ldrb	r3, [r5, #8]
 8002d90:	2b01      	cmp	r3, #1
 8002d92:	f000 8162 	beq.w	800305a <main+0x95a>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8002d96:	6f6b      	ldr	r3, [r5, #116]	; 0x74

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8002d98:	4a1c      	ldr	r2, [pc, #112]	; (8002e0c <main+0x70c>)
 8002d9a:	4293      	cmp	r3, r2
 8002d9c:	f000 8159 	beq.w	8003052 <main+0x952>
 8002da0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002da4:	4293      	cmp	r3, r2
 8002da6:	f000 8154 	beq.w	8003052 <main+0x952>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8002daa:	f240 4245 	movw	r2, #1093	; 0x445
 8002dae:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002db0:	f244 0140 	movw	r1, #16448	; 0x4040
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002db4:	2601      	movs	r6, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002db6:	f242 102c 	movw	r0, #8492	; 0x212c
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8002dba:	2200      	movs	r2, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002dbc:	6119      	str	r1, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002dbe:	615e      	str	r6, [r3, #20]

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8002dc0:	2102      	movs	r1, #2
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002dc2:	60d8      	str	r0, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8002dc4:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8002dc6:	6818      	ldr	r0, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8002dc8:	685b      	ldr	r3, [r3, #4]
 8002dca:	7229      	strb	r1, [r5, #8]
 8002dcc:	f382 8811 	msr	BASEPRI, r2
 8002dd0:	2320      	movs	r3, #32
 8002dd2:	f383 8811 	msr	BASEPRI, r3
  sdcp->dmamode |= STM32_DMA_CR_PFCTRL |
                   STM32_DMA_CR_PBURST_INCR4 |
                   STM32_DMA_CR_MBURST_INCR4;
#endif

  if (sdcp->state == BLK_STOP) {
 8002dd6:	793b      	ldrb	r3, [r7, #4]
  osalDbgCheck(sdcp != NULL);

  osalSysLock();
  osalDbgAssert((sdcp->state == BLK_STOP) || (sdcp->state == BLK_ACTIVE),
                "invalid state");
  sdcp->config = config;
 8002dd8:	480d      	ldr	r0, [pc, #52]	; (8002e10 <main+0x710>)
                  STM32_DMA_CR_PSIZE_WORD |
                  STM32_DMA_CR_MSIZE_WORD |
                  STM32_DMA_CR_MINC;

#if (defined(STM32F4XX) || defined(STM32F2XX))
  sdcp->dmamode |= STM32_DMA_CR_PFCTRL |
 8002dda:	490e      	ldr	r1, [pc, #56]	; (8002e14 <main+0x714>)
 8002ddc:	62f8      	str	r0, [r7, #44]	; 0x2c
                   STM32_DMA_CR_PBURST_INCR4 |
                   STM32_DMA_CR_MBURST_INCR4;
#endif

  if (sdcp->state == BLK_STOP) {
 8002dde:	42b3      	cmp	r3, r6
                  STM32_DMA_CR_PSIZE_WORD |
                  STM32_DMA_CR_MSIZE_WORD |
                  STM32_DMA_CR_MINC;

#if (defined(STM32F4XX) || defined(STM32F2XX))
  sdcp->dmamode |= STM32_DMA_CR_PFCTRL |
 8002de0:	6439      	str	r1, [r7, #64]	; 0x40
 8002de2:	4d0d      	ldr	r5, [pc, #52]	; (8002e18 <main+0x718>)
                   STM32_DMA_CR_PBURST_INCR4 |
                   STM32_DMA_CR_MBURST_INCR4;
#endif

  if (sdcp->state == BLK_STOP) {
 8002de4:	f000 8116 	beq.w	8003014 <main+0x914>
 8002de8:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8002dea:	e027      	b.n	8002e3c <main+0x73c>
 8002dec:	20001140 	.word	0x20001140
 8002df0:	20001290 	.word	0x20001290
 8002df4:	20000c30 	.word	0x20000c30
 8002df8:	08004460 	.word	0x08004460
 8002dfc:	08000571 	.word	0x08000571
 8002e00:	08004578 	.word	0x08004578
 8002e04:	080045c0 	.word	0x080045c0
 8002e08:	40020c00 	.word	0x40020c00
 8002e0c:	40011000 	.word	0x40011000
 8002e10:	080044a0 	.word	0x080044a0
 8002e14:	08a35420 	.word	0x08a35420
 8002e18:	20001078 	.word	0x20001078
 8002e1c:	e0001000 	.word	0xe0001000
 8002e20:	080004c1 	.word	0x080004c1
 8002e24:	200014e3 	.word	0x200014e3
 8002e28:	20018000 	.word	0x20018000
 8002e2c:	20001074 	.word	0x20001074
 8002e30:	08000291 	.word	0x08000291
 8002e34:	000186a0 	.word	0x000186a0
 8002e38:	00061a80 	.word	0x00061a80
    nvicEnableVector(STM32_SDIO_NUMBER, STM32_SDC_SDIO_IRQ_PRIORITY);
    rccEnableSDIO(FALSE);
  }

  /* Configuration, card clock is initially stopped.*/
  sdcp->sdio->POWER  = 0;
 8002e3c:	2500      	movs	r5, #0
  sdc_lld_start(sdcp);
  sdcp->state = BLK_ACTIVE;
 8002e3e:	2202      	movs	r2, #2
 8002e40:	601d      	str	r5, [r3, #0]
  sdcp->sdio->CLKCR  = 0;
 8002e42:	605d      	str	r5, [r3, #4]
  sdcp->sdio->DCTRL  = 0;
 8002e44:	62dd      	str	r5, [r3, #44]	; 0x2c
 8002e46:	713a      	strb	r2, [r7, #4]
  sdcp->sdio->DTIMER = 0;
 8002e48:	625d      	str	r5, [r3, #36]	; 0x24
 8002e4a:	f385 8811 	msr	BASEPRI, r5
  FRESULT err;
  DIR dir;

  sdcStart(&SDCD1, &sdccfg);
  /* Card presence check.*/
  if (!blkIsInserted(&SDCD1)) {
 8002e4e:	683b      	ldr	r3, [r7, #0]
 8002e50:	48ba      	ldr	r0, [pc, #744]	; (800313c <main+0xa3c>)
 8002e52:	681b      	ldr	r3, [r3, #0]
 8002e54:	4798      	blx	r3
//    print("Card not inserted, aborting.\r\n");
  }

  /* Connection to the card.*/
//  print("MMC Connecting...-");
  if (sdcConnect(&SDCD1)) {
 8002e56:	48b9      	ldr	r0, [pc, #740]	; (800313c <main+0xa3c>)
 8002e58:	f7fd fdba 	bl	80009d0 <sdcConnect>
 8002e5c:	4bb8      	ldr	r3, [pc, #736]	; (8003140 <main+0xa40>)
 8002e5e:	4ab9      	ldr	r2, [pc, #740]	; (8003144 <main+0xa44>)
 8002e60:	9203      	str	r2, [sp, #12]
	int vol;
	FRESULT res;
	const TCHAR *rp = path;


	vol = get_ldnumber(&rp);
 8002e62:	a80c      	add	r0, sp, #48	; 0x30
 8002e64:	9302      	str	r3, [sp, #8]
)
{
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 8002e66:	930c      	str	r3, [sp, #48]	; 0x30


	vol = get_ldnumber(&rp);
 8002e68:	f7fe fb62 	bl	8001530 <get_ldnumber.lto_priv.77>
	if (vol < 0) return FR_INVALID_DRIVE;
 8002e6c:	1e07      	subs	r7, r0, #0
 8002e6e:	db10      	blt.n	8002e92 <main+0x792>
	cfs = FatFs[vol];					/* Pointer to fs object */
 8002e70:	4eb5      	ldr	r6, [pc, #724]	; (8003148 <main+0xa48>)
 8002e72:	f856 3027 	ldr.w	r3, [r6, r7, lsl #2]

	if (cfs) {
 8002e76:	b103      	cbz	r3, 8002e7a <main+0x77a>
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 8002e78:	701d      	strb	r5, [r3, #0]
	}

	if (fs) {
 8002e7a:	9b03      	ldr	r3, [sp, #12]
 8002e7c:	2b00      	cmp	r3, #0
 8002e7e:	f000 8085 	beq.w	8002f8c <main+0x88c>
		fs->fs_type = 0;				/* Clear new fs object */
 8002e82:	2200      	movs	r2, #0
 8002e84:	701a      	strb	r2, [r3, #0]
	}
	FatFs[vol] = fs;					/* Register new fs object */

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
 8002e86:	a803      	add	r0, sp, #12
 8002e88:	a902      	add	r1, sp, #8
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 8002e8a:	f846 3027 	str.w	r3, [r6, r7, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
 8002e8e:	f001 f867 	bl	8003f60 <find_volume.lto_priv.57>
 8002e92:	2300      	movs	r3, #0


	if (!dp) return FR_INVALID_OBJECT;

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
 8002e94:	461a      	mov	r2, r3
 8002e96:	a804      	add	r0, sp, #16
 8002e98:	a905      	add	r1, sp, #20
 8002e9a:	9305      	str	r3, [sp, #20]
 8002e9c:	f001 f860 	bl	8003f60 <find_volume.lto_priv.57>
	if (res == FR_OK) {
 8002ea0:	2800      	cmp	r0, #0
 8002ea2:	d07c      	beq.n	8002f9e <main+0x89e>
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
 8002ea4:	2300      	movs	r3, #0
 8002ea6:	930c      	str	r3, [sp, #48]	; 0x30
  err = f_opendir(&dir, path);
  if(FR_OK == err)
  {
//    print("Error while opening directory\r\n");
  }
  if (f_open(&files, "0:file.txt", FA_READ | FA_WRITE | FA_OPEN_ALWAYS) == FR_OK)
 8002ea8:	48a8      	ldr	r0, [pc, #672]	; (800314c <main+0xa4c>)
 8002eaa:	2113      	movs	r1, #19
 8002eac:	f000 fb60 	bl	8003570 <f_open.constprop.7>
 8002eb0:	2800      	cmp	r0, #0
 8002eb2:	d071      	beq.n	8002f98 <main+0x898>
//      f_puts("----------------------------------------------------\n", &files);
      /* Close USB file */
      f_close(&files);
    }

  if (f_open(&files, "0:filese.txt", FA_READ | FA_OPEN_ALWAYS) == FR_OK)
 8002eb4:	48a6      	ldr	r0, [pc, #664]	; (8003150 <main+0xa50>)
 8002eb6:	2111      	movs	r1, #17
 8002eb8:	f000 fb5a 	bl	8003570 <f_open.constprop.7>
 8002ebc:	2800      	cmp	r0, #0
 8002ebe:	d068      	beq.n	8002f92 <main+0x892>
 8002ec0:	2320      	movs	r3, #32
 8002ec2:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002ec6:	4ba3      	ldr	r3, [pc, #652]	; (8003154 <main+0xa54>)
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002ec8:	6962      	ldr	r2, [r4, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002eca:	4fa3      	ldr	r7, [pc, #652]	; (8003158 <main+0xa58>)
 8002ecc:	f8c3 7124 	str.w	r7, [r3, #292]	; 0x124
 8002ed0:	2500      	movs	r5, #0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002ed2:	2140      	movs	r1, #64	; 0x40
  tp->p_state = CH_STATE_WTSTART;
 8002ed4:	2602      	movs	r6, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002ed6:	2001      	movs	r0, #1
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002ed8:	771e      	strb	r6, [r3, #28]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002eda:	7798      	strb	r0, [r3, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002edc:	615a      	str	r2, [r3, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002ede:	f8c3 b144 	str.w	fp, [r3, #324]	; 0x144
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002ee2:	611c      	str	r4, [r3, #16]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002ee4:	f503 7792 	add.w	r7, r3, #292	; 0x124
 8002ee8:	f8c3 5128 	str.w	r5, [r3, #296]	; 0x128
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002eec:	775d      	strb	r5, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002eee:	639d      	str	r5, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002ef0:	635d      	str	r5, [r3, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002ef2:	619d      	str	r5, [r3, #24]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002ef4:	63d9      	str	r1, [r3, #60]	; 0x3c
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002ef6:	f103 0624 	add.w	r6, r3, #36	; 0x24
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002efa:	6113      	str	r3, [r2, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002efc:	f103 0228 	add.w	r2, r3, #40	; 0x28
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8002f00:	4618      	mov	r0, r3

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002f02:	60df      	str	r7, [r3, #12]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002f04:	6099      	str	r1, [r3, #8]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002f06:	625e      	str	r6, [r3, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002f08:	629a      	str	r2, [r3, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8002f0a:	62da      	str	r2, [r3, #44]	; 0x2c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002f0c:	6163      	str	r3, [r4, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8002f0e:	f000 f957 	bl	80031c0 <chSchWakeupS.constprop.54>
 8002f12:	f385 8811 	msr	BASEPRI, r5
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  codec_i2s_init(100,10);
  while (true) {
    arra[0] = 0x11;
 8002f16:	2711      	movs	r7, #17
 8002f18:	ae06      	add	r6, sp, #24
    arra[1] = 0x22;
 8002f1a:	2522      	movs	r5, #34	; 0x22
    arra[2] = 0x33;
 8002f1c:	2433      	movs	r4, #51	; 0x33
}

// Send data to the codec via I2S
void codec_audio_send(void* txbuf, size_t n)
{
	dmaStreamSetMemory0(i2sdma, txbuf);
 8002f1e:	2200      	movs	r2, #0
    arra[3] = 0x44;
 8002f20:	f04f 0944 	mov.w	r9, #68	; 0x44
    arra[4] = 0x55;
 8002f24:	f04f 0855 	mov.w	r8, #85	; 0x55
    arra[5] = 0x66;
 8002f28:	f04f 0c66 	mov.w	ip, #102	; 0x66
    arra[6] = 0x77;
 8002f2c:	f04f 0e77 	mov.w	lr, #119	; 0x77
    arra[7] = 0x88;
 8002f30:	2088      	movs	r0, #136	; 0x88
    arra[8] = 0x99;
 8002f32:	2199      	movs	r1, #153	; 0x99
    arra[9] = 0xBB;
 8002f34:	23bb      	movs	r3, #187	; 0xbb
    arra[1] = 0x22;
    arra[2] = 0x33;
    arra[3] = 0x44;
    arra[4] = 0x55;
    arra[5] = 0x66;
    arra[6] = 0x77;
 8002f36:	f88d e01e 	strb.w	lr, [sp, #30]
    arra[7] = 0x88;
 8002f3a:	f88d 001f 	strb.w	r0, [sp, #31]
  codec_i2s_init(100,10);
  while (true) {
    arra[0] = 0x11;
    arra[1] = 0x22;
    arra[2] = 0x33;
    arra[3] = 0x44;
 8002f3e:	f88d 901b 	strb.w	r9, [sp, #27]
    arra[4] = 0x55;
 8002f42:	f88d 801c 	strb.w	r8, [sp, #28]
    arra[5] = 0x66;
 8002f46:	f88d c01d 	strb.w	ip, [sp, #29]
    arra[6] = 0x77;
    arra[7] = 0x88;
    arra[8] = 0x99;
 8002f4a:	f88d 1020 	strb.w	r1, [sp, #32]
    arra[9] = 0xBB;
 8002f4e:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  codec_i2s_init(100,10);
  while (true) {
    arra[0] = 0x11;
 8002f52:	f88d 7018 	strb.w	r7, [sp, #24]
    arra[1] = 0x22;
 8002f56:	f88d 5019 	strb.w	r5, [sp, #25]
    arra[2] = 0x33;
 8002f5a:	f88d 401a 	strb.w	r4, [sp, #26]
 8002f5e:	6813      	ldr	r3, [r2, #0]
	dmaStreamSetTransactionSize(i2sdma, n);
	dmaStreamSetMode(i2sdma, i2stxdmamode | STM32_DMA_CR_MINC);
	dmaStreamClearInterrupt(i2sdma);
 8002f60:	6851      	ldr	r1, [r2, #4]
}

// Send data to the codec via I2S
void codec_audio_send(void* txbuf, size_t n)
{
	dmaStreamSetMemory0(i2sdma, txbuf);
 8002f62:	60de      	str	r6, [r3, #12]
	dmaStreamSetTransactionSize(i2sdma, n);
 8002f64:	f04f 0e0a 	mov.w	lr, #10
	dmaStreamSetMode(i2sdma, i2stxdmamode | STM32_DMA_CR_MINC);
 8002f68:	f44f 6080 	mov.w	r0, #1024	; 0x400

// Send data to the codec via I2S
void codec_audio_send(void* txbuf, size_t n)
{
	dmaStreamSetMemory0(i2sdma, txbuf);
	dmaStreamSetTransactionSize(i2sdma, n);
 8002f6c:	f8c3 e004 	str.w	lr, [r3, #4]
	dmaStreamSetMode(i2sdma, i2stxdmamode | STM32_DMA_CR_MINC);
 8002f70:	6018      	str	r0, [r3, #0]
	dmaStreamClearInterrupt(i2sdma);
 8002f72:	7a10      	ldrb	r0, [r2, #8]
 8002f74:	223d      	movs	r2, #61	; 0x3d
 8002f76:	4082      	lsls	r2, r0
 8002f78:	600a      	str	r2, [r1, #0]
	dmaStreamEnable(i2sdma);
 8002f7a:	681a      	ldr	r2, [r3, #0]
 8002f7c:	f042 0201 	orr.w	r2, r2, #1
 8002f80:	601a      	str	r2, [r3, #0]
    arra[6] = 0x77;
    arra[7] = 0x88;
    arra[8] = 0x99;
    arra[9] = 0xBB;
    codec_audio_send(&arra[0],10);
    chThdSleepMilliseconds(500);
 8002f82:	f241 3088 	movw	r0, #5000	; 0x1388
 8002f86:	f7fd fd13 	bl	80009b0 <chThdSleep>
 8002f8a:	e7c8      	b.n	8002f1e <main+0x81e>
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 8002f8c:	f846 3027 	str.w	r3, [r6, r7, lsl #2]
 8002f90:	e77f      	b.n	8002e92 <main+0x792>
    {
//    f_gets(&read_data,100,&files);
//    print(&read_data);
      f_close(&files);
 8002f92:	f000 fa2d 	bl	80033f0 <f_close.constprop.9>
 8002f96:	e793      	b.n	8002ec0 <main+0x7c0>
//      f_puts("with USB MSC HOST library from stm32f4-discovery.com\n", &files);
//      f_puts("----------------------------------------------------\n", &files);
//      f_puts("USB total and free space:\n\n", &files);
//      f_puts("----------------------------------------------------\n", &files);
      /* Close USB file */
      f_close(&files);
 8002f98:	f000 fa2a 	bl	80033f0 <f_close.constprop.9>
 8002f9c:	e78a      	b.n	8002eb4 <main+0x7b4>
	if (!dp) return FR_INVALID_OBJECT;

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
	if (res == FR_OK) {
		dp->fs = fs;
 8002f9e:	9b04      	ldr	r3, [sp, #16]
 8002fa0:	930c      	str	r3, [sp, #48]	; 0x30
/*------------------------------------------------------------------------*/
/* Allocate a memory block                                                */
/*------------------------------------------------------------------------*/
void *ff_memalloc(UINT size) {

  return chHeapAlloc(NULL, size);
 8002fa2:	f000 f97d 	bl	80032a0 <chHeapAlloc.constprop.41>
		INIT_BUF(*dp);
 8002fa6:	4605      	mov	r5, r0
 8002fa8:	2800      	cmp	r0, #0
 8002faa:	f43f af7d 	beq.w	8002ea8 <main+0x7a8>
 8002fae:	ab09      	add	r3, sp, #36	; 0x24
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8002fb0:	a80c      	add	r0, sp, #48	; 0x30
 8002fb2:	9905      	ldr	r1, [sp, #20]

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
	if (res == FR_OK) {
		dp->fs = fs;
		INIT_BUF(*dp);
 8002fb4:	9513      	str	r5, [sp, #76]	; 0x4c
 8002fb6:	9312      	str	r3, [sp, #72]	; 0x48
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8002fb8:	f7fe fc3a 	bl	8001830 <follow_path.lto_priv.58>
 8002fbc:	4606      	mov	r6, r0
/*------------------------------------------------------------------------*/
/* Free a memory block                                                    */
/*------------------------------------------------------------------------*/
void ff_memfree(void *mblock) {

  chHeapFree(mblock);
 8002fbe:	4628      	mov	r0, r5
 8002fc0:	f7fd ffce 	bl	8000f60 <chHeapFree>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
 8002fc4:	2e00      	cmp	r6, #0
 8002fc6:	f47f af6d 	bne.w	8002ea4 <main+0x7a4>
			if (dp->dir) {						/* It is not the origin directory itself */
 8002fca:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8002fcc:	b303      	cbz	r3, 8003010 <main+0x910>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
 8002fce:	7ada      	ldrb	r2, [r3, #11]
 8002fd0:	06d2      	lsls	r2, r2, #27
 8002fd2:	f57f af67 	bpl.w	8002ea4 <main+0x7a4>
					dp->sclust = ld_clust(fs, dp->dir);
 8002fd6:	9904      	ldr	r1, [sp, #16]
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8002fd8:	7edd      	ldrb	r5, [r3, #27]
	if (fs->fs_type == FS_FAT32)
 8002fda:	7808      	ldrb	r0, [r1, #0]
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8002fdc:	7e9a      	ldrb	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32)
 8002fde:	2803      	cmp	r0, #3
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8002fe0:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
	if (fs->fs_type == FS_FAT32)
 8002fe4:	d105      	bne.n	8002ff2 <main+0x8f2>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 8002fe6:	7d58      	ldrb	r0, [r3, #21]
 8002fe8:	7d1b      	ldrb	r3, [r3, #20]
 8002fea:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8002fee:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
		res = follow_path(dp, path);			/* Follow the path to the directory */
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
			if (dp->dir) {						/* It is not the origin directory itself */
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
					dp->sclust = ld_clust(fs, dp->dir);
 8002ff2:	920e      	str	r2, [sp, #56]	; 0x38
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
 8002ff4:	88cb      	ldrh	r3, [r1, #6]
 8002ff6:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
				res = dir_sdi(dp, 0);			/* Rewind directory */
 8002ffa:	a80c      	add	r0, sp, #48	; 0x30
 8002ffc:	2100      	movs	r1, #0
 8002ffe:	f7fe fbc7 	bl	8001790 <dir_sdi.lto_priv.60>
					}
				}
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8003002:	2804      	cmp	r0, #4
 8003004:	f43f af4e 	beq.w	8002ea4 <main+0x7a4>
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
 8003008:	2800      	cmp	r0, #0
 800300a:	f43f af4d 	beq.w	8002ea8 <main+0x7a8>
 800300e:	e749      	b.n	8002ea4 <main+0x7a4>
 8003010:	9904      	ldr	r1, [sp, #16]
 8003012:	e7ef      	b.n	8002ff4 <main+0x8f4>
#endif

  if (sdcp->state == BLK_STOP) {
    /* Note, the DMA must be enabled before the IRQs.*/
    bool b;
    b = dmaStreamAllocate(sdcp->dma, STM32_SDC_SDIO_IRQ_PRIORITY, NULL, NULL);
 8003014:	4613      	mov	r3, r2
 8003016:	6c68      	ldr	r0, [r5, #68]	; 0x44
 8003018:	2109      	movs	r1, #9
 800301a:	f7ff faf1 	bl	8002600 <dmaStreamAllocate>
    osalDbgAssert(!b, "stream already allocated");
    dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdio->FIFO);
 800301e:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8003020:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8003022:	6815      	ldr	r5, [r2, #0]
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8003024:	4a4d      	ldr	r2, [pc, #308]	; (800315c <main+0xa5c>)
#if (defined(STM32F4XX) || defined(STM32F2XX))
    dmaStreamSetFIFO(sdcp->dma, STM32_DMA_FCR_DMDIS | STM32_DMA_FCR_FTH_FULL);
#endif
    nvicEnableVector(STM32_SDIO_NUMBER, STM32_SDC_SDIO_IRQ_PRIORITY);
    rccEnableSDIO(FALSE);
 8003026:	494e      	ldr	r1, [pc, #312]	; (8003160 <main+0xa60>)
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8003028:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  if (sdcp->state == BLK_STOP) {
    /* Note, the DMA must be enabled before the IRQs.*/
    bool b;
    b = dmaStreamAllocate(sdcp->dma, STM32_SDC_SDIO_IRQ_PRIORITY, NULL, NULL);
    osalDbgAssert(!b, "stream already allocated");
    dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdio->FIFO);
 800302c:	f103 0c80 	add.w	ip, r3, #128	; 0x80
#if (defined(STM32F4XX) || defined(STM32F2XX))
    dmaStreamSetFIFO(sdcp->dma, STM32_DMA_FCR_DMDIS | STM32_DMA_FCR_FTH_FULL);
 8003030:	f04f 0e07 	mov.w	lr, #7
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8003034:	2690      	movs	r6, #144	; 0x90
  if (sdcp->state == BLK_STOP) {
    /* Note, the DMA must be enabled before the IRQs.*/
    bool b;
    b = dmaStreamAllocate(sdcp->dma, STM32_SDC_SDIO_IRQ_PRIORITY, NULL, NULL);
    osalDbgAssert(!b, "stream already allocated");
    dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdio->FIFO);
 8003036:	f8c5 c008 	str.w	ip, [r5, #8]
#if (defined(STM32F4XX) || defined(STM32F2XX))
    dmaStreamSetFIFO(sdcp->dma, STM32_DMA_FCR_DMDIS | STM32_DMA_FCR_FTH_FULL);
 800303a:	f8c5 e014 	str.w	lr, [r5, #20]
 800303e:	f882 6331 	strb.w	r6, [r2, #817]	; 0x331
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8003042:	f8c2 0184 	str.w	r0, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 8003046:	6050      	str	r0, [r2, #4]
#endif
    nvicEnableVector(STM32_SDIO_NUMBER, STM32_SDC_SDIO_IRQ_PRIORITY);
    rccEnableSDIO(FALSE);
 8003048:	6c4a      	ldr	r2, [r1, #68]	; 0x44
 800304a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800304e:	644a      	str	r2, [r1, #68]	; 0x44
 8003050:	e6f4      	b.n	8002e3c <main+0x73c>
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8003052:	f640 028b 	movw	r2, #2187	; 0x88b
 8003056:	609a      	str	r2, [r3, #8]
 8003058:	e6aa      	b.n	8002db0 <main+0x6b0>
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(FALSE);
 800305a:	4841      	ldr	r0, [pc, #260]	; (8003160 <main+0xa60>)
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800305c:	4b3f      	ldr	r3, [pc, #252]	; (800315c <main+0xa5c>)
 800305e:	6c02      	ldr	r2, [r0, #64]	; 0x40
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8003060:	2140      	movs	r1, #64	; 0x40
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8003062:	26c0      	movs	r6, #192	; 0xc0
 8003064:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8003068:	6402      	str	r2, [r0, #64]	; 0x40
 800306a:	f883 6326 	strb.w	r6, [r3, #806]	; 0x326
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800306e:	f8c3 1184 	str.w	r1, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 8003072:	6059      	str	r1, [r3, #4]
 8003074:	e68f      	b.n	8002d96 <main+0x696>
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8003076:	f023 030a 	bic.w	r3, r3, #10
 800307a:	b29b      	uxth	r3, r3
 800307c:	e636      	b.n	8002cec <main+0x5ec>
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 800307e:	f043 030a 	orr.w	r3, r3, #10
 8003082:	e633      	b.n	8002cec <main+0x5ec>
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 8003084:	f023 0308 	bic.w	r3, r3, #8
 8003088:	b29b      	uxth	r3, r3
 800308a:	f043 0302 	orr.w	r3, r3, #2
 800308e:	e62d      	b.n	8002cec <main+0x5ec>
    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8003090:	f04f 0e2b 	mov.w	lr, #43	; 0x2b
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 8003094:	0040      	lsls	r0, r0, #1
 8003096:	4b33      	ldr	r3, [pc, #204]	; (8003164 <main+0xa64>)
    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8003098:	f8c2 e020 	str.w	lr, [r2, #32]
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 800309c:	fb93 f3f0 	sdiv	r3, r3, r0
 80030a0:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80030a4:	e615      	b.n	8002cd2 <main+0x5d2>

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 80030a6:	f8d8 1020 	ldr.w	r1, [r8, #32]
 80030aa:	f8cd c000 	str.w	ip, [sp]
 80030ae:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
      b = dmaStreamAllocate(i2cp->dmarx,
 80030b2:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80030b4:	4a2c      	ldr	r2, [pc, #176]	; (8003168 <main+0xa68>)

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 80030b6:	f8c8 1020 	str.w	r1, [r8, #32]
 80030ba:	f8c8 3020 	str.w	r3, [r8, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 80030be:	2106      	movs	r1, #6
 80030c0:	4633      	mov	r3, r6
 80030c2:	f7ff fa9d 	bl	8002600 <dmaStreamAllocate>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(i2cp->dmatx,
 80030c6:	4a29      	ldr	r2, [pc, #164]	; (800316c <main+0xa6c>)
 80030c8:	6b30      	ldr	r0, [r6, #48]	; 0x30
 80030ca:	2106      	movs	r1, #6
 80030cc:	4633      	mov	r3, r6
 80030ce:	f7ff fa97 	bl	8002600 <dmaStreamAllocate>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 80030d2:	f8d8 e040 	ldr.w	lr, [r8, #64]	; 0x40
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80030d6:	6a70      	ldr	r0, [r6, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80030d8:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80030da:	6871      	ldr	r1, [r6, #4]
 80030dc:	6b72      	ldr	r2, [r6, #52]	; 0x34
      b = dmaStreamAllocate(i2cp->dmatx,
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 80030de:	f44e 1e00 	orr.w	lr, lr, #2097152	; 0x200000
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80030e2:	f040 7000 	orr.w	r0, r0, #33554432	; 0x2000000
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80030e6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
      b = dmaStreamAllocate(i2cp->dmatx,
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 80030ea:	f8c8 e040 	str.w	lr, [r8, #64]	; 0x40
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80030ee:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 80030f2:	f04f 0e60 	mov.w	lr, #96	; 0x60
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80030f6:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80030fa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 80030fe:	f889 e31f 	strb.w	lr, [r9, #799]	; 0x31f
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8003102:	6270      	str	r0, [r6, #36]	; 0x24
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8003104:	f8c9 8180 	str.w	r8, [r9, #384]	; 0x180
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8003108:	62b3      	str	r3, [r6, #40]	; 0x28
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 800310a:	f8c9 8000 	str.w	r8, [r9]
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800310e:	f889 e320 	strb.w	lr, [r9, #800]	; 0x320
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8003112:	f8dd c000 	ldr.w	ip, [sp]
 8003116:	f8c9 c184 	str.w	ip, [r9, #388]	; 0x184
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 800311a:	f8c9 c004 	str.w	ip, [r9, #4]
 800311e:	e59b      	b.n	8002c58 <main+0x558>
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 16/9.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 8003120:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 8003124:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 8003128:	4b0e      	ldr	r3, [pc, #56]	; (8003164 <main+0xa64>)
 800312a:	fb93 f3f0 	sdiv	r3, r3, r0
 800312e:	ea6f 4383 	mvn.w	r3, r3, lsl #18
 8003132:	ea6f 4393 	mvn.w	r3, r3, lsr #18
 8003136:	b29b      	uxth	r3, r3
 8003138:	e5c9      	b.n	8002cce <main+0x5ce>
 800313a:	bf00      	nop
 800313c:	20001078 	.word	0x20001078
 8003140:	08004580 	.word	0x08004580
 8003144:	20000a00 	.word	0x20000a00
 8003148:	20000e38 	.word	0x20000e38
 800314c:	08004584 	.word	0x08004584
 8003150:	08004590 	.word	0x08004590
 8003154:	20000e40 	.word	0x20000e40
 8003158:	080026c1 	.word	0x080026c1
 800315c:	e000e100 	.word	0xe000e100
 8003160:	40023800 	.word	0x40023800
 8003164:	0280de80 	.word	0x0280de80
 8003168:	080014c1 	.word	0x080014c1
 800316c:	080010d1 	.word	0x080010d1

    if (duty == FAST_DUTY_CYCLE_2) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 8003170:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003174:	4b04      	ldr	r3, [pc, #16]	; (8003188 <main+0xa88>)
 8003176:	fb93 f3f0 	sdiv	r3, r3, r0
 800317a:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800317e:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8003182:	b29b      	uxth	r3, r3
 8003184:	e5a3      	b.n	8002cce <main+0x5ce>
 8003186:	bf00      	nop
 8003188:	0280de80 	.word	0x0280de80
 800318c:	00000000 	.word	0x00000000

08003190 <validate.constprop.12>:
)
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8003190:	4a0a      	ldr	r2, [pc, #40]	; (80031bc <validate.constprop.12+0x2c>)
/*-----------------------------------------------------------------------*/
/* Check if the file/directory object is valid or not                    */
/*-----------------------------------------------------------------------*/

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
 8003192:	b508      	push	{r3, lr}
)
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8003194:	6813      	ldr	r3, [r2, #0]
 8003196:	b10b      	cbz	r3, 800319c <validate.constprop.12+0xc>
 8003198:	7819      	ldrb	r1, [r3, #0]
 800319a:	b909      	cbnz	r1, 80031a0 <validate.constprop.12+0x10>
		return FR_INVALID_OBJECT;
 800319c:	2009      	movs	r0, #9

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
 800319e:	bd08      	pop	{r3, pc}
)
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80031a0:	8892      	ldrh	r2, [r2, #4]
 80031a2:	88d9      	ldrh	r1, [r3, #6]
 80031a4:	4291      	cmp	r1, r2
 80031a6:	d1f9      	bne.n	800319c <validate.constprop.12+0xc>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
 80031a8:	7858      	ldrb	r0, [r3, #1]
 80031aa:	f7fe fce1 	bl	8001b70 <disk_status>
 80031ae:	f010 0f01 	tst.w	r0, #1
		return FR_NOT_READY;

	return FR_OK;
 80031b2:	bf14      	ite	ne
 80031b4:	2003      	movne	r0, #3
 80031b6:	2000      	moveq	r0, #0
 80031b8:	bd08      	pop	{r3, pc}
 80031ba:	bf00      	nop
 80031bc:	200012b0 	.word	0x200012b0

080031c0 <chSchWakeupS.constprop.54>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80031c0:	4b14      	ldr	r3, [pc, #80]	; (8003214 <chSchWakeupS.constprop.54+0x54>)
 80031c2:	6881      	ldr	r1, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80031c4:	b470      	push	{r4, r5, r6}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80031c6:	699d      	ldr	r5, [r3, #24]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80031c8:	4604      	mov	r4, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80031ca:	68a8      	ldr	r0, [r5, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80031cc:	2200      	movs	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80031ce:	4281      	cmp	r1, r0

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80031d0:	6222      	str	r2, [r4, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80031d2:	d80b      	bhi.n	80031ec <chSchWakeupS.constprop.54+0x2c>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80031d4:	7722      	strb	r2, [r4, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80031d6:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80031d8:	689a      	ldr	r2, [r3, #8]
 80031da:	4291      	cmp	r1, r2
 80031dc:	d9fb      	bls.n	80031d6 <chSchWakeupS.constprop.54+0x16>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80031de:	685a      	ldr	r2, [r3, #4]
 80031e0:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80031e2:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80031e4:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 80031e6:	605c      	str	r4, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80031e8:	bc70      	pop	{r4, r5, r6}
 80031ea:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80031ec:	772a      	strb	r2, [r5, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 80031ee:	461a      	mov	r2, r3
  do {
    cp = cp->p_next;
 80031f0:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 80031f2:	6891      	ldr	r1, [r2, #8]
 80031f4:	4288      	cmp	r0, r1
 80031f6:	d9fb      	bls.n	80031f0 <chSchWakeupS.constprop.54+0x30>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80031f8:	6850      	ldr	r0, [r2, #4]
 80031fa:	6068      	str	r0, [r5, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 80031fc:	2601      	movs	r6, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80031fe:	602a      	str	r2, [r5, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8003200:	6005      	str	r5, [r0, #0]
  cp->p_prev = tp;
 8003202:	6055      	str	r5, [r2, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8003204:	7726      	strb	r6, [r4, #28]
    chSysSwitch(ntp, otp);
 8003206:	4629      	mov	r1, r5
 8003208:	4620      	mov	r0, r4
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 800320a:	619c      	str	r4, [r3, #24]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800320c:	bc70      	pop	{r4, r5, r6}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 800320e:	f7fd b837 	b.w	8000280 <_port_switch>
 8003212:	bf00      	nop
 8003214:	20001140 	.word	0x20001140
	...

08003220 <chTMStartMeasurementX.constprop.51>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8003220:	4b01      	ldr	r3, [pc, #4]	; (8003228 <chTMStartMeasurementX.constprop.51+0x8>)
 8003222:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8003224:	6083      	str	r3, [r0, #8]
 8003226:	4770      	bx	lr
 8003228:	e0001000 	.word	0xe0001000
 800322c:	00000000 	.word	0x00000000

08003230 <chEvtBroadcastFlagsI.constprop.46>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8003230:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8003232:	4f17      	ldr	r7, [pc, #92]	; (8003290 <chEvtBroadcastFlagsI.constprop.46+0x60>)
 8003234:	f857 4f04 	ldr.w	r4, [r7, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8003238:	42bc      	cmp	r4, r7
 800323a:	d020      	beq.n	800327e <chEvtBroadcastFlagsI.constprop.46+0x4e>
 800323c:	4606      	mov	r6, r0
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800323e:	2500      	movs	r5, #0
 8003240:	e002      	b.n	8003248 <chEvtBroadcastFlagsI.constprop.46+0x18>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8003242:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8003244:	42bc      	cmp	r4, r7
 8003246:	d01a      	beq.n	800327e <chEvtBroadcastFlagsI.constprop.46+0x4e>
  /*lint -restore*/
    elp->el_flags |= flags;
 8003248:	68e3      	ldr	r3, [r4, #12]
 800324a:	4333      	orrs	r3, r6
 800324c:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800324e:	b116      	cbz	r6, 8003256 <chEvtBroadcastFlagsI.constprop.46+0x26>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8003250:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8003252:	4213      	tst	r3, r2
 8003254:	d0f5      	beq.n	8003242 <chEvtBroadcastFlagsI.constprop.46+0x12>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8003256:	6860      	ldr	r0, [r4, #4]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8003258:	68a3      	ldr	r3, [r4, #8]
 800325a:	6b41      	ldr	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800325c:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 800325e:	430b      	orrs	r3, r1
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003260:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8003262:	6343      	str	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003264:	d00c      	beq.n	8003280 <chEvtBroadcastFlagsI.constprop.46+0x50>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8003266:	2a0b      	cmp	r2, #11
 8003268:	d1eb      	bne.n	8003242 <chEvtBroadcastFlagsI.constprop.46+0x12>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 800326a:	6a02      	ldr	r2, [r0, #32]
 800326c:	4013      	ands	r3, r2

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800326e:	429a      	cmp	r2, r3
 8003270:	d1e7      	bne.n	8003242 <chEvtBroadcastFlagsI.constprop.46+0x12>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8003272:	6205      	str	r5, [r0, #32]
    (void) chSchReadyI(tp);
 8003274:	f7fd fdbc 	bl	8000df0 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8003278:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800327a:	42bc      	cmp	r4, r7
 800327c:	d1e4      	bne.n	8003248 <chEvtBroadcastFlagsI.constprop.46+0x18>
 800327e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8003280:	6a02      	ldr	r2, [r0, #32]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003282:	4213      	tst	r3, r2
 8003284:	d0dd      	beq.n	8003242 <chEvtBroadcastFlagsI.constprop.46+0x12>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8003286:	6205      	str	r5, [r0, #32]
    (void) chSchReadyI(tp);
 8003288:	f7fd fdb2 	bl	8000df0 <chSchReadyI>
 800328c:	e7f4      	b.n	8003278 <chEvtBroadcastFlagsI.constprop.46+0x48>
 800328e:	bf00      	nop
 8003290:	200010c4 	.word	0x200010c4
	...

080032a0 <chHeapAlloc.constprop.41>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 80032a0:	b510      	push	{r4, lr}
 80032a2:	2320      	movs	r3, #32
 80032a4:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 80032a8:	481f      	ldr	r0, [pc, #124]	; (8003328 <chHeapAlloc.constprop.41+0x88>)
 80032aa:	f7fd fdf1 	bl	8000e90 <chMtxLockS>
 80032ae:	2300      	movs	r3, #0
 80032b0:	f383 8811 	msr	BASEPRI, r3
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
 80032b4:	4b1d      	ldr	r3, [pc, #116]	; (800332c <chHeapAlloc.constprop.41+0x8c>)
 80032b6:	e004      	b.n	80032c2 <chHeapAlloc.constprop.41+0x22>

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 80032b8:	6842      	ldr	r2, [r0, #4]
 80032ba:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 80032be:	d216      	bcs.n	80032ee <chHeapAlloc.constprop.41+0x4e>
 80032c0:	4603      	mov	r3, r0

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 80032c2:	6818      	ldr	r0, [r3, #0]
 80032c4:	2800      	cmp	r0, #0
 80032c6:	d1f7      	bne.n	80032b8 <chHeapAlloc.constprop.41+0x18>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 80032c8:	4c19      	ldr	r4, [pc, #100]	; (8003330 <chHeapAlloc.constprop.41+0x90>)
 80032ca:	f104 0010 	add.w	r0, r4, #16
 80032ce:	f7fd fda7 	bl	8000e20 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 80032d2:	6823      	ldr	r3, [r4, #0]
 80032d4:	b333      	cbz	r3, 8003324 <chHeapAlloc.constprop.41+0x84>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 80032d6:	f44f 7002 	mov.w	r0, #520	; 0x208
 80032da:	4798      	blx	r3
    if (hp != NULL) {
 80032dc:	b310      	cbz	r0, 8003324 <chHeapAlloc.constprop.41+0x84>
      hp->h.u.heap = heapp;
      hp->h.size = size;
 80032de:	f44f 7300 	mov.w	r3, #512	; 0x200
  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
    hp = heapp->h_provider(size + sizeof(union heap_header));
    if (hp != NULL) {
      hp->h.u.heap = heapp;
 80032e2:	6004      	str	r4, [r0, #0]
      hp->h.size = size;
 80032e4:	6043      	str	r3, [r0, #4]
      hp++;
 80032e6:	f100 0408 	add.w	r4, r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 80032ea:	4620      	mov	r0, r4
 80032ec:	bd10      	pop	{r4, pc}

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
      if (hp->h.size < (size + sizeof(union heap_header))) {
 80032ee:	f5b2 7f02 	cmp.w	r2, #520	; 0x208
 80032f2:	d209      	bcs.n	8003308 <chHeapAlloc.constprop.41+0x68>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 80032f4:	6802      	ldr	r2, [r0, #0]
 80032f6:	601a      	str	r2, [r3, #0]
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 80032f8:	4604      	mov	r4, r0
 80032fa:	480d      	ldr	r0, [pc, #52]	; (8003330 <chHeapAlloc.constprop.41+0x90>)
 80032fc:	f844 0b08 	str.w	r0, [r4], #8
      H_UNLOCK(heapp);
 8003300:	3010      	adds	r0, #16
 8003302:	f7fd fd8d 	bl	8000e20 <chMtxUnlock>
 8003306:	e7f0      	b.n	80032ea <chHeapAlloc.constprop.41+0x4a>
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 8003308:	6804      	ldr	r4, [r0, #0]
 800330a:	f8c0 4208 	str.w	r4, [r0, #520]	; 0x208
 800330e:	f500 7102 	add.w	r1, r0, #520	; 0x208
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8003312:	f5a2 7202 	sub.w	r2, r2, #520	; 0x208
        qp->h.u.next = fp;
        hp->h.size = size;
 8003316:	f44f 7400 	mov.w	r4, #512	; 0x200
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 800331a:	f8c0 220c 	str.w	r2, [r0, #524]	; 0x20c
        qp->h.u.next = fp;
 800331e:	6019      	str	r1, [r3, #0]
        hp->h.size = size;
 8003320:	6044      	str	r4, [r0, #4]
 8003322:	e7e9      	b.n	80032f8 <chHeapAlloc.constprop.41+0x58>
      return (void *)hp;
      /*lint -restore*/
    }
  }

  return NULL;
 8003324:	2400      	movs	r4, #0
 8003326:	e7e0      	b.n	80032ea <chHeapAlloc.constprop.41+0x4a>
 8003328:	200012a0 	.word	0x200012a0
 800332c:	20001298 	.word	0x20001298
 8003330:	20001290 	.word	0x20001290
	...

08003340 <_pal_lld_setgroupmode.constprop.24>:
 * @param[in] mode      the mode
 *
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
 8003340:	b5f0      	push	{r4, r5, r6, r7, lr}
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8003342:	2401      	movs	r4, #1
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8003344:	4b1d      	ldr	r3, [pc, #116]	; (80033bc <_pal_lld_setgroupmode.constprop.24+0x7c>)
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 8003346:	4627      	mov	r7, r4
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8003348:	2200      	movs	r2, #0
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
 800334a:	250f      	movs	r5, #15
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 800334c:	2603      	movs	r6, #3
 800334e:	e024      	b.n	800339a <_pal_lld_setgroupmode.constprop.24+0x5a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8003350:	f8d3 e020 	ldr.w	lr, [r3, #32]
 8003354:	ea2e 0101 	bic.w	r1, lr, r1
 8003358:	6219      	str	r1, [r3, #32]
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800335a:	6859      	ldr	r1, [r3, #4]
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 800335c:	fa07 fe02 	lsl.w	lr, r7, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8003360:	ea21 010e 	bic.w	r1, r1, lr
 8003364:	4321      	orrs	r1, r4
 8003366:	6059      	str	r1, [r3, #4]
 8003368:	0051      	lsls	r1, r2, #1
      m2 = 3 << (bit * 2);
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800336a:	f8d3 e008 	ldr.w	lr, [r3, #8]
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 800336e:	fa06 f101 	lsl.w	r1, r6, r1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8003372:	43c9      	mvns	r1, r1
 8003374:	ea01 0e0e 	and.w	lr, r1, lr
 8003378:	f8c3 e008 	str.w	lr, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800337c:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 8003380:	ea01 0e0e 	and.w	lr, r1, lr
 8003384:	f8c3 e00c 	str.w	lr, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 8003388:	f8d3 e000 	ldr.w	lr, [r3]
 800338c:	ea01 010e 	and.w	r1, r1, lr
 8003390:	6019      	str	r1, [r3, #0]
    }
    mask >>= 1;
    if (!mask)
 8003392:	0840      	lsrs	r0, r0, #1
 8003394:	d011      	beq.n	80033ba <_pal_lld_setgroupmode.constprop.24+0x7a>
      return;
    otyper <<= 1;
 8003396:	0064      	lsls	r4, r4, #1
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
 8003398:	3201      	adds	r2, #1
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800339a:	f002 0107 	and.w	r1, r2, #7
 800339e:	0089      	lsls	r1, r1, #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 80033a0:	f010 0f01 	tst.w	r0, #1
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
 80033a4:	fa05 f101 	lsl.w	r1, r5, r1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 80033a8:	d0f3      	beq.n	8003392 <_pal_lld_setgroupmode.constprop.24+0x52>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
 80033aa:	2a07      	cmp	r2, #7
 80033ac:	d9d0      	bls.n	8003350 <_pal_lld_setgroupmode.constprop.24+0x10>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 80033ae:	f8d3 e024 	ldr.w	lr, [r3, #36]	; 0x24
 80033b2:	ea2e 0101 	bic.w	r1, lr, r1
 80033b6:	6259      	str	r1, [r3, #36]	; 0x24
 80033b8:	e7cf      	b.n	800335a <_pal_lld_setgroupmode.constprop.24+0x1a>
 80033ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80033bc:	40020400 	.word	0x40020400

080033c0 <disk_write.constprop.16>:

/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */

#if _USE_WRITE
DRESULT disk_write (
 80033c0:	460b      	mov	r3, r1
    const BYTE *buff,    /* Data to be written */
    DWORD sector,        /* Sector address (LBA) */
    UINT count            /* Number of sectors to write (1..255) */
)
{
  switch (pdrv) {
 80033c2:	b108      	cbz	r0, 80033c8 <disk_write.constprop.16+0x8>
    if (sdcWrite(&SDCD1, sector, buff, count))
      return RES_ERROR;
    return RES_OK;
#endif
  }
  return RES_PARERR;
 80033c4:	2004      	movs	r0, #4
 80033c6:	4770      	bx	lr
    if (mmcStopSequentialWrite(&MMCD1))
        return RES_ERROR;
    return RES_OK;
#else
  case SDC:
    if (blkGetDriverState(&SDCD1) != BLK_READY)
 80033c8:	4805      	ldr	r0, [pc, #20]	; (80033e0 <disk_write.constprop.16+0x20>)
 80033ca:	7901      	ldrb	r1, [r0, #4]
 80033cc:	2905      	cmp	r1, #5
 80033ce:	d001      	beq.n	80033d4 <disk_write.constprop.16+0x14>
      return RES_NOTRDY;
 80033d0:	2003      	movs	r0, #3
      return RES_ERROR;
    return RES_OK;
#endif
  }
  return RES_PARERR;
}
 80033d2:	4770      	bx	lr
    return RES_OK;
#else
  case SDC:
    if (blkGetDriverState(&SDCD1) != BLK_READY)
      return RES_NOTRDY;
    if (sdcWrite(&SDCD1, sector, buff, count))
 80033d4:	4611      	mov	r1, r2
 80033d6:	461a      	mov	r2, r3
 80033d8:	2301      	movs	r3, #1
 80033da:	f7fe bfc9 	b.w	8002370 <sdcWrite>
 80033de:	bf00      	nop
 80033e0:	20001078 	.word	0x20001078
	...

080033f0 <f_close.constprop.9>:

/*-----------------------------------------------------------------------*/
/* Close File                                                            */
/*-----------------------------------------------------------------------*/

FRESULT f_close (
 80033f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
 80033f4:	f7ff fecc 	bl	8003190 <validate.constprop.12>
	if (res == FR_OK) {
 80033f8:	b9c8      	cbnz	r0, 800342e <f_close.constprop.9+0x3e>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 80033fa:	4c59      	ldr	r4, [pc, #356]	; (8003560 <f_close.constprop.9+0x170>)
 80033fc:	79a3      	ldrb	r3, [r4, #6]
 80033fe:	069a      	lsls	r2, r3, #26
 8003400:	d558      	bpl.n	80034b4 <f_close.constprop.9+0xc4>
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
 8003402:	065b      	lsls	r3, r3, #25
 8003404:	d50c      	bpl.n	8003420 <f_close.constprop.9+0x30>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
 8003406:	4621      	mov	r1, r4
 8003408:	69a2      	ldr	r2, [r4, #24]
 800340a:	f851 3b24 	ldr.w	r3, [r1], #36
 800340e:	7858      	ldrb	r0, [r3, #1]
 8003410:	f7ff ffd6 	bl	80033c0 <disk_write.constprop.16>
 8003414:	2800      	cmp	r0, #0
 8003416:	d151      	bne.n	80034bc <f_close.constprop.9+0xcc>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 8003418:	79a3      	ldrb	r3, [r4, #6]
 800341a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800341e:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 8003420:	6820      	ldr	r0, [r4, #0]
 8003422:	69e1      	ldr	r1, [r4, #28]
 8003424:	4e4e      	ldr	r6, [pc, #312]	; (8003560 <f_close.constprop.9+0x170>)
 8003426:	f7fe fb7b 	bl	8001b20 <move_window.lto_priv.55>
 800342a:	4602      	mov	r2, r0
			if (res == FR_OK) {
 800342c:	b10a      	cbz	r2, 8003432 <f_close.constprop.9+0x42>
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 800342e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
 8003432:	6a33      	ldr	r3, [r6, #32]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
				ST_WORD(dir+DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
 8003434:	79b1      	ldrb	r1, [r6, #6]
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 8003436:	7ad8      	ldrb	r0, [r3, #11]
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
				ST_WORD(dir+DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
				fp->fs->wflag = 1;
 8003438:	6835      	ldr	r5, [r6, #0]
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
 800343a:	759a      	strb	r2, [r3, #22]
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 800343c:	f040 0020 	orr.w	r0, r0, #32
 8003440:	72d8      	strb	r0, [r3, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
 8003442:	6930      	ldr	r0, [r6, #16]
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 8003444:	f8d6 c00c 	ldr.w	ip, [r6, #12]
 8003448:	f883 c01c 	strb.w	ip, [r3, #28]
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 800344c:	0c07      	lsrs	r7, r0, #16
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 800344e:	f3cc 2e07 	ubfx	lr, ip, #8, #8
 8003452:	ea4f 4b1c 	mov.w	fp, ip, lsr #16
 8003456:	ea4f 6a1c 	mov.w	sl, ip, lsr #24
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 800345a:	f3c0 2907 	ubfx	r9, r0, #8, #8
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 800345e:	f883 e01d 	strb.w	lr, [r3, #29]
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
				ST_WORD(dir+DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
 8003462:	f021 0120 	bic.w	r1, r1, #32
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8003466:	ea4f 2817 	mov.w	r8, r7, lsr #8
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
 800346a:	f04f 0c21 	mov.w	ip, #33	; 0x21
				ST_WORD(dir+DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
				fp->fs->wflag = 1;
 800346e:	f04f 0e01 	mov.w	lr, #1
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 8003472:	7698      	strb	r0, [r3, #26]
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
 8003474:	75da      	strb	r2, [r3, #23]
 8003476:	765a      	strb	r2, [r3, #25]
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 8003478:	f883 b01e 	strb.w	fp, [r3, #30]
 800347c:	f883 a01f 	strb.w	sl, [r3, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
				ST_WORD(dir+DIR_LstAccDate, 0);
 8003480:	749a      	strb	r2, [r3, #18]
 8003482:	74da      	strb	r2, [r3, #19]
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 8003484:	f883 901b 	strb.w	r9, [r3, #27]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8003488:	751f      	strb	r7, [r3, #20]
 800348a:	f883 8015 	strb.w	r8, [r3, #21]
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
 800348e:	f883 c018 	strb.w	ip, [r3, #24]
				ST_WORD(dir+DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
 8003492:	71b1      	strb	r1, [r6, #6]
 8003494:	4628      	mov	r0, r5
				fp->fs->wflag = 1;
 8003496:	f885 e004 	strb.w	lr, [r5, #4]
 800349a:	f000 fd31 	bl	8003f00 <sync_window.part.1.lto_priv.56>
{
	FRESULT res;


	res = sync_window(fs);
	if (res == FR_OK) {
 800349e:	2800      	cmp	r0, #0
 80034a0:	d1c5      	bne.n	800342e <f_close.constprop.9+0x3e>
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 80034a2:	782b      	ldrb	r3, [r5, #0]
 80034a4:	2b03      	cmp	r3, #3
 80034a6:	d00c      	beq.n	80034c2 <f_close.constprop.9+0xd2>
    BYTE pdrv,        /* Physical drive nmuber (0..) */
    BYTE cmd,        /* Control code */
    void *buff        /* Buffer to send/receive control data */
)
{
  switch (pdrv) {
 80034a8:	786b      	ldrb	r3, [r5, #1]
 80034aa:	b93b      	cbnz	r3, 80034bc <f_close.constprop.9+0xcc>
#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
	if (res == FR_OK)
#endif
	{
		res = validate(fp);				/* Lock volume */
 80034ac:	f7ff fe70 	bl	8003190 <validate.constprop.12>
		if (res == FR_OK) {
 80034b0:	2800      	cmp	r0, #0
 80034b2:	d1bc      	bne.n	800342e <f_close.constprop.9+0x3e>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
 80034b4:	2000      	movs	r0, #0
 80034b6:	6020      	str	r0, [r4, #0]
 80034b8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 80034bc:	2001      	movs	r0, #1
 80034be:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}


	res = sync_window(fs);
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 80034c2:	796b      	ldrb	r3, [r5, #5]
 80034c4:	2b01      	cmp	r3, #1
 80034c6:	d1ef      	bne.n	80034a8 <f_close.constprop.9+0xb8>
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
 80034c8:	f105 0130 	add.w	r1, r5, #48	; 0x30
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
 80034cc:	460b      	mov	r3, r1
 80034ce:	f505 720c 	add.w	r2, r5, #560	; 0x230

	while (cnt--)
		*d++ = (BYTE)val;
 80034d2:	f803 0b01 	strb.w	r0, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 80034d6:	4293      	cmp	r3, r2
		*d++ = (BYTE)val;
 80034d8:	f04f 0600 	mov.w	r6, #0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 80034dc:	d1f9      	bne.n	80034d2 <f_close.constprop.9+0xe2>
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 80034de:	692b      	ldr	r3, [r5, #16]
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 80034e0:	68e8      	ldr	r0, [r5, #12]
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 80034e2:	69ea      	ldr	r2, [r5, #28]
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 80034e4:	f885 3218 	strb.w	r3, [r5, #536]	; 0x218
 80034e8:	f3c3 2e07 	ubfx	lr, r3, #8, #8
 80034ec:	0c1f      	lsrs	r7, r3, #16
 80034ee:	0e1b      	lsrs	r3, r3, #24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 80034f0:	f3c0 2a07 	ubfx	sl, r0, #8, #8
 80034f4:	ea4f 4910 	mov.w	r9, r0, lsr #16
 80034f8:	ea4f 6810 	mov.w	r8, r0, lsr #24
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 80034fc:	3201      	adds	r2, #1
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 80034fe:	f04f 0c55 	mov.w	ip, #85	; 0x55
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 8003502:	f885 e219 	strb.w	lr, [r5, #537]	; 0x219
 8003506:	f885 721a 	strb.w	r7, [r5, #538]	; 0x21a
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 800350a:	f04f 0e52 	mov.w	lr, #82	; 0x52
 800350e:	2761      	movs	r7, #97	; 0x61
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 8003510:	f885 321b 	strb.w	r3, [r5, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8003514:	f885 021c 	strb.w	r0, [r5, #540]	; 0x21c
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 8003518:	2341      	movs	r3, #65	; 0x41
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 800351a:	2072      	movs	r0, #114	; 0x72
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 800351c:	f04f 0baa 	mov.w	fp, #170	; 0xaa
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 8003520:	f885 0214 	strb.w	r0, [r5, #532]	; 0x214
 8003524:	f885 0215 	strb.w	r0, [r5, #533]	; 0x215
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8003528:	f885 a21d 	strb.w	sl, [r5, #541]	; 0x21d
 800352c:	f885 921e 	strb.w	r9, [r5, #542]	; 0x21e
 8003530:	f885 821f 	strb.w	r8, [r5, #543]	; 0x21f
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 8003534:	62ea      	str	r2, [r5, #44]	; 0x2c
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 8003536:	f885 c22e 	strb.w	ip, [r5, #558]	; 0x22e
 800353a:	f885 b22f 	strb.w	fp, [r5, #559]	; 0x22f
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 800353e:	f885 e030 	strb.w	lr, [r5, #48]	; 0x30
 8003542:	f885 e031 	strb.w	lr, [r5, #49]	; 0x31
 8003546:	f885 7032 	strb.w	r7, [r5, #50]	; 0x32
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 800354a:	f885 7217 	strb.w	r7, [r5, #535]	; 0x217
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 800354e:	f885 3033 	strb.w	r3, [r5, #51]	; 0x33
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 8003552:	f885 3216 	strb.w	r3, [r5, #534]	; 0x216
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8003556:	7868      	ldrb	r0, [r5, #1]
 8003558:	f7ff ff32 	bl	80033c0 <disk_write.constprop.16>
			fs->fsi_flag = 0;
 800355c:	716e      	strb	r6, [r5, #5]
 800355e:	e7a3      	b.n	80034a8 <f_close.constprop.9+0xb8>
 8003560:	200012b0 	.word	0x200012b0
	...

08003570 <f_open.constprop.7>:

/*-----------------------------------------------------------------------*/
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_open (
 8003570:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003574:	b097      	sub	sp, #92	; 0x5c
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
	fp->fs = 0;			/* Clear file object */
 8003576:	4cab      	ldr	r4, [pc, #684]	; (8003824 <f_open.constprop.7+0x2b4>)

/*-----------------------------------------------------------------------*/
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_open (
 8003578:	9003      	str	r0, [sp, #12]
	fp->fs = 0;			/* Clear file object */

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
 800357a:	f001 021e 	and.w	r2, r1, #30
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
	fp->fs = 0;			/* Clear file object */
 800357e:	2300      	movs	r3, #0

/*-----------------------------------------------------------------------*/
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_open (
 8003580:	460f      	mov	r7, r1
	fp->fs = 0;			/* Clear file object */

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
 8003582:	a80d      	add	r0, sp, #52	; 0x34
 8003584:	a903      	add	r1, sp, #12
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
	fp->fs = 0;			/* Clear file object */
 8003586:	6023      	str	r3, [r4, #0]

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
 8003588:	f000 fcea 	bl	8003f60 <find_volume.lto_priv.57>
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
 800358c:	4681      	mov	r9, r0
 800358e:	b110      	cbz	r0, 8003596 <f_open.constprop.7+0x26>
			fp->id = fp->fs->id;
		}
	}

	LEAVE_FF(dj.fs, res);
}
 8003590:	b017      	add	sp, #92	; 0x5c
 8003592:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
/*------------------------------------------------------------------------*/
/* Allocate a memory block                                                */
/*------------------------------------------------------------------------*/
void *ff_memalloc(UINT size) {

  return chHeapAlloc(NULL, size);
 8003596:	f7ff fe83 	bl	80032a0 <chHeapAlloc.constprop.41>
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
 800359a:	4605      	mov	r5, r0
 800359c:	2800      	cmp	r0, #0
 800359e:	d05d      	beq.n	800365c <f_open.constprop.7+0xec>
 80035a0:	ab07      	add	r3, sp, #28
		res = follow_path(&dj, path);	/* Follow the file path */
 80035a2:	a80d      	add	r0, sp, #52	; 0x34
 80035a4:	9903      	ldr	r1, [sp, #12]
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
 80035a6:	9514      	str	r5, [sp, #80]	; 0x50
 80035a8:	9313      	str	r3, [sp, #76]	; 0x4c
		res = follow_path(&dj, path);	/* Follow the file path */
 80035aa:	f7fe f941 	bl	8001830 <follow_path.lto_priv.58>
	if (!fp) return FR_INVALID_OBJECT;
	fp->fs = 0;			/* Clear file object */

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
 80035ae:	f007 061f 	and.w	r6, r7, #31
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
		dir = dj.dir;
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 80035b2:	4682      	mov	sl, r0
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
		dir = dj.dir;
 80035b4:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 80035b8:	2800      	cmp	r0, #0
 80035ba:	d151      	bne.n	8003660 <f_open.constprop.7+0xf0>
			if (!dir)	/* Default directory itself */
 80035bc:	f1b8 0f00 	cmp.w	r8, #0
 80035c0:	f000 8114 	beq.w	80037ec <f_open.constprop.7+0x27c>
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 80035c4:	f017 0f1c 	tst.w	r7, #28
 80035c8:	f000 808b 	beq.w	80036e2 <f_open.constprop.7+0x172>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 80035cc:	f898 300b 	ldrb.w	r3, [r8, #11]
 80035d0:	f013 0f11 	tst.w	r3, #17
 80035d4:	f040 80fb 	bne.w	80037ce <f_open.constprop.7+0x25e>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
 80035d8:	0778      	lsls	r0, r7, #29
 80035da:	f100 810a 	bmi.w	80037f2 <f_open.constprop.7+0x282>
 80035de:	9f0d      	ldr	r7, [sp, #52]	; 0x34
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 80035e0:	0731      	lsls	r1, r6, #28
 80035e2:	f140 808c 	bpl.w	80036fe <f_open.constprop.7+0x18e>
				dw = get_fattime();				/* Created time */
				ST_DWORD(dir+DIR_CrtTime, dw);
 80035e6:	2300      	movs	r3, #0
 80035e8:	2221      	movs	r2, #33	; 0x21
 80035ea:	f888 2010 	strb.w	r2, [r8, #16]
 80035ee:	f888 300e 	strb.w	r3, [r8, #14]
 80035f2:	f888 300f 	strb.w	r3, [r8, #15]
 80035f6:	f888 3011 	strb.w	r3, [r8, #17]
				dir[DIR_Attr] = 0;				/* Reset attribute */
 80035fa:	f888 300b 	strb.w	r3, [r8, #11]
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
 80035fe:	f888 301c 	strb.w	r3, [r8, #28]
 8003602:	f888 301d 	strb.w	r3, [r8, #29]
 8003606:	f888 301e 	strb.w	r3, [r8, #30]
 800360a:	f888 301f 	strb.w	r3, [r8, #31]
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32)
 800360e:	783b      	ldrb	r3, [r7, #0]
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8003610:	f898 901b 	ldrb.w	r9, [r8, #27]
 8003614:	f898 201a 	ldrb.w	r2, [r8, #26]
	if (fs->fs_type == FS_FAT32)
 8003618:	2b03      	cmp	r3, #3
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 800361a:	ea42 2909 	orr.w	r9, r2, r9, lsl #8
	if (fs->fs_type == FS_FAT32)
 800361e:	f000 8146 	beq.w	80038ae <f_open.constprop.7+0x33e>
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 8003622:	2300      	movs	r3, #0
				ST_DWORD(dir+DIR_CrtTime, dw);
				dir[DIR_Attr] = 0;				/* Reset attribute */
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
 8003624:	2201      	movs	r2, #1
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 8003626:	f888 301a 	strb.w	r3, [r8, #26]
 800362a:	f888 301b 	strb.w	r3, [r8, #27]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 800362e:	f888 3014 	strb.w	r3, [r8, #20]
 8003632:	f888 3015 	strb.w	r3, [r8, #21]
				ST_DWORD(dir+DIR_CrtTime, dw);
				dir[DIR_Attr] = 0;				/* Reset attribute */
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
 8003636:	713a      	strb	r2, [r7, #4]
				if (cl) {						/* Remove the cluster chain if exist */
 8003638:	f1b9 0f00 	cmp.w	r9, #0
 800363c:	d05d      	beq.n	80036fa <f_open.constprop.7+0x18a>
					dw = dj.fs->winsect;
 800363e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003640:	9300      	str	r3, [sp, #0]
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8003642:	4591      	cmp	r9, r2
 8003644:	d903      	bls.n	800364e <f_open.constprop.7+0xde>
 8003646:	697b      	ldr	r3, [r7, #20]
 8003648:	4599      	cmp	r9, r3
 800364a:	f0c0 81c8 	bcc.w	80039de <f_open.constprop.7+0x46e>
		res = FR_INT_ERR;
 800364e:	f04f 0a02 	mov.w	sl, #2
/*------------------------------------------------------------------------*/
/* Free a memory block                                                    */
/*------------------------------------------------------------------------*/
void ff_memfree(void *mblock) {

  chHeapFree(mblock);
 8003652:	4628      	mov	r0, r5
 8003654:	f7fd fc84 	bl	8000f60 <chHeapFree>
 8003658:	4650      	mov	r0, sl
 800365a:	e799      	b.n	8003590 <f_open.constprop.7+0x20>
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
 800365c:	2011      	movs	r0, #17
 800365e:	e797      	b.n	8003590 <f_open.constprop.7+0x20>
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8003660:	f017 0f1c 	tst.w	r7, #28
 8003664:	d0f5      	beq.n	8003652 <f_open.constprop.7+0xe2>
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 8003666:	f1ba 0f04 	cmp.w	sl, #4
 800366a:	d1f2      	bne.n	8003652 <f_open.constprop.7+0xe2>
	UINT n, nent;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dp->fn; lfn = dp->lfn;
 800366c:	9f13      	ldr	r7, [sp, #76]	; 0x4c
 800366e:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
 8003672:	463b      	mov	r3, r7
 8003674:	f10d 0b28 	add.w	fp, sp, #40	; 0x28
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
 8003678:	f813 2b01 	ldrb.w	r2, [r3], #1
 800367c:	f80b 2009 	strb.w	r2, [fp, r9]
 8003680:	f109 0901 	add.w	r9, r9, #1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 8003684:	f1b9 0f0c 	cmp.w	r9, #12
 8003688:	d1f6      	bne.n	8003678 <f_open.constprop.7+0x108>
	mem_cpy(sn, fn, 12);

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 800368a:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
 800368e:	9300      	str	r3, [sp, #0]
 8003690:	07db      	lsls	r3, r3, #31
 8003692:	f140 80ba 	bpl.w	800380a <f_open.constprop.7+0x29a>
		fn[NS] = 0; dp->lfn = 0;			/* Find only SFN */
 8003696:	2300      	movs	r3, #0
 8003698:	72fb      	strb	r3, [r7, #11]
		for (n = 1; n < 100; n++) {
 800369a:	f04f 0901 	mov.w	r9, #1

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dp->lfn = 0;			/* Find only SFN */
 800369e:	9314      	str	r3, [sp, #80]	; 0x50
	UINT n, nent;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dp->fn; lfn = dp->lfn;
 80036a0:	2300      	movs	r3, #0
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
 80036a2:	f81b 2003 	ldrb.w	r2, [fp, r3]
 80036a6:	54fa      	strb	r2, [r7, r3]
 80036a8:	3301      	adds	r3, #1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 80036aa:	2b0b      	cmp	r3, #11
 80036ac:	d1f9      	bne.n	80036a2 <f_open.constprop.7+0x132>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
 80036ae:	f1b9 0f05 	cmp.w	r9, #5
 80036b2:	d94f      	bls.n	8003754 <f_open.constprop.7+0x1e4>
 80036b4:	f1a8 0e02 	sub.w	lr, r8, #2
 80036b8:	464b      	mov	r3, r9
		WCHAR wc;
		DWORD sr = seq;

		while (*lfn) {	/* Create a CRC */
 80036ba:	f83e 2f02 	ldrh.w	r2, [lr, #2]!
 80036be:	2a00      	cmp	r2, #0
 80036c0:	d049      	beq.n	8003756 <f_open.constprop.7+0x1e6>
 80036c2:	2110      	movs	r1, #16
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
				sr = (sr << 1) + (wc & 1);
 80036c4:	f002 0001 	and.w	r0, r2, #1
 80036c8:	eb00 0343 	add.w	r3, r0, r3, lsl #1
				wc >>= 1;
				if (sr & 0x10000) sr ^= 0x11021;
 80036cc:	03d8      	lsls	r0, r3, #15
 80036ce:	bf44      	itt	mi
 80036d0:	f483 3388 	eormi.w	r3, r3, #69632	; 0x11000
 80036d4:	f083 0321 	eormi.w	r3, r3, #33	; 0x21
		WCHAR wc;
		DWORD sr = seq;

		while (*lfn) {	/* Create a CRC */
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
 80036d8:	3901      	subs	r1, #1
				sr = (sr << 1) + (wc & 1);
				wc >>= 1;
 80036da:	ea4f 0252 	mov.w	r2, r2, lsr #1
		WCHAR wc;
		DWORD sr = seq;

		while (*lfn) {	/* Create a CRC */
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
 80036de:	d1f1      	bne.n	80036c4 <f_open.constprop.7+0x154>
 80036e0:	e7eb      	b.n	80036ba <f_open.constprop.7+0x14a>
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
 80036e2:	f898 300b 	ldrb.w	r3, [r8, #11]
 80036e6:	06d8      	lsls	r0, r3, #27
 80036e8:	d47d      	bmi.n	80037e6 <f_open.constprop.7+0x276>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 80036ea:	07b9      	lsls	r1, r7, #30
 80036ec:	d501      	bpl.n	80036f2 <f_open.constprop.7+0x182>
 80036ee:	07da      	lsls	r2, r3, #31
 80036f0:	d46d      	bmi.n	80037ce <f_open.constprop.7+0x25e>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 80036f2:	073b      	lsls	r3, r7, #28
 80036f4:	f140 81ad 	bpl.w	8003a52 <f_open.constprop.7+0x4e2>
 80036f8:	9f0d      	ldr	r7, [sp, #52]	; 0x34
				mode |= FA__WRITTEN;
 80036fa:	f046 0620 	orr.w	r6, r6, #32
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 80036fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003700:	61e3      	str	r3, [r4, #28]
 8003702:	4628      	mov	r0, r5
			fp->dir_ptr = dir;
 8003704:	f8c4 8020 	str.w	r8, [r4, #32]
 8003708:	f7fd fc2a 	bl	8000f60 <chHeapFree>
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
 800370c:	2300      	movs	r3, #0
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 800370e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
 8003710:	71e3      	strb	r3, [r4, #7]
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
 8003712:	71a6      	strb	r6, [r4, #6]
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32)
 8003714:	782a      	ldrb	r2, [r5, #0]
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8003716:	f898 001b 	ldrb.w	r0, [r8, #27]
 800371a:	f898 301a 	ldrb.w	r3, [r8, #26]
	if (fs->fs_type == FS_FAT32)
 800371e:	2a03      	cmp	r2, #3
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8003720:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
	if (fs->fs_type == FS_FAT32)
 8003724:	d056      	beq.n	80037d4 <f_open.constprop.7+0x264>

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 8003726:	f898 101e 	ldrb.w	r1, [r8, #30]
 800372a:	f898 301f 	ldrb.w	r3, [r8, #31]
 800372e:	f898 201c 	ldrb.w	r2, [r8, #28]
 8003732:	f898 701d 	ldrb.w	r7, [r8, #29]
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
 8003736:	88ee      	ldrh	r6, [r5, #6]
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 8003738:	6120      	str	r0, [r4, #16]
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 800373a:	0409      	lsls	r1, r1, #16
 800373c:	ea41 6303 	orr.w	r3, r1, r3, lsl #24
 8003740:	4313      	orrs	r3, r2
			fp->fptr = 0;						/* File pointer */
 8003742:	2000      	movs	r0, #0

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 8003744:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
			fp->fptr = 0;						/* File pointer */
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
 8003748:	6025      	str	r5, [r4, #0]
			fp->id = fp->fs->id;
 800374a:	80a6      	strh	r6, [r4, #4]

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 800374c:	60e3      	str	r3, [r4, #12]
			fp->fptr = 0;						/* File pointer */
 800374e:	60a0      	str	r0, [r4, #8]
			fp->dsect = 0;
 8003750:	61a0      	str	r0, [r4, #24]
 8003752:	e71d      	b.n	8003590 <f_open.constprop.7+0x20>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
 8003754:	464b      	mov	r3, r9
 8003756:	2207      	movs	r2, #7
	}

	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
 8003758:	f003 000f 	and.w	r0, r3, #15
 800375c:	a905      	add	r1, sp, #20
		if (c > '9') c += 7;
		ns[i--] = c;
 800375e:	3a01      	subs	r2, #1
 8003760:	eb01 0e02 	add.w	lr, r1, r2
	}

	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
 8003764:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
 8003768:	2939      	cmp	r1, #57	; 0x39
 800376a:	bf88      	it	hi
 800376c:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
		ns[i--] = c;
		seq /= 16;
	} while (seq);
 8003770:	091b      	lsrs	r3, r3, #4
	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
		if (c > '9') c += 7;
		ns[i--] = c;
 8003772:	f88e 1001 	strb.w	r1, [lr, #1]
		seq /= 16;
	} while (seq);
 8003776:	d1ef      	bne.n	8003758 <f_open.constprop.7+0x1e8>
	ns[i] = '~';
 8003778:	a916      	add	r1, sp, #88	; 0x58
 800377a:	4411      	add	r1, r2
 800377c:	207e      	movs	r0, #126	; 0x7e
 800377e:	f801 0c44 	strb.w	r0, [r1, #-68]
 8003782:	e003      	b.n	800378c <f_open.constprop.7+0x21c>

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
 8003784:	5cf9      	ldrb	r1, [r7, r3]
 8003786:	2920      	cmp	r1, #32
 8003788:	d002      	beq.n	8003790 <f_open.constprop.7+0x220>
 800378a:	3301      	adds	r3, #1
 800378c:	4293      	cmp	r3, r2
 800378e:	d1f9      	bne.n	8003784 <f_open.constprop.7+0x214>
 8003790:	443b      	add	r3, r7
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 8003792:	a916      	add	r1, sp, #88	; 0x58
 8003794:	4411      	add	r1, r2
 8003796:	2a07      	cmp	r2, #7
 8003798:	bf94      	ite	ls
 800379a:	f811 1c44 	ldrbls.w	r1, [r1, #-68]
 800379e:	2120      	movhi	r1, #32
 80037a0:	f803 1b01 	strb.w	r1, [r3], #1
 80037a4:	eba3 0107 	sub.w	r1, r3, r7
 80037a8:	bf98      	it	ls
 80037aa:	3201      	addls	r2, #1
	} while (j < 8);
 80037ac:	2907      	cmp	r1, #7
 80037ae:	d9f0      	bls.n	8003792 <f_open.constprop.7+0x222>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 80037b0:	a80d      	add	r0, sp, #52	; 0x34
 80037b2:	2100      	movs	r1, #0
 80037b4:	f7fd ffec 	bl	8001790 <dir_sdi.lto_priv.60>
	if (res != FR_OK) return res;
 80037b8:	b9f0      	cbnz	r0, 80037f8 <f_open.constprop.7+0x288>
 80037ba:	a80d      	add	r0, sp, #52	; 0x34
 80037bc:	f000 f9f8 	bl	8003bb0 <dir_find.part.7.lto_priv.61>
	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dp->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
 80037c0:	b9d0      	cbnz	r0, 80037f8 <f_open.constprop.7+0x288>
	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dp->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
 80037c2:	f109 0901 	add.w	r9, r9, #1
 80037c6:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 80037ca:	f47f af69 	bne.w	80036a0 <f_open.constprop.7+0x130>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 80037ce:	f04f 0a07 	mov.w	sl, #7
 80037d2:	e73e      	b.n	8003652 <f_open.constprop.7+0xe2>
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32)
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 80037d4:	f898 2015 	ldrb.w	r2, [r8, #21]
 80037d8:	f898 3014 	ldrb.w	r3, [r8, #20]
 80037dc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80037e0:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 80037e4:	e79f      	b.n	8003726 <f_open.constprop.7+0x1b6>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
					res = FR_NO_FILE;
 80037e6:	f04f 0a04 	mov.w	sl, #4
 80037ea:	e732      	b.n	8003652 <f_open.constprop.7+0xe2>
		res = follow_path(&dj, path);	/* Follow the file path */
		dir = dj.dir;
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
			if (!dir)	/* Default directory itself */
				res = FR_INVALID_NAME;
 80037ec:	f04f 0a06 	mov.w	sl, #6
 80037f0:	e72f      	b.n	8003652 <f_open.constprop.7+0xe2>
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
 80037f2:	f04f 0a08 	mov.w	sl, #8
 80037f6:	e72c      	b.n	8003652 <f_open.constprop.7+0xe2>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 80037f8:	2804      	cmp	r0, #4
 80037fa:	4682      	mov	sl, r0
 80037fc:	f47f af29 	bne.w	8003652 <f_open.constprop.7+0xe2>
		fn[NS] = sn[NS]; dp->lfn = lfn;
 8003800:	f89d 3000 	ldrb.w	r3, [sp]
 8003804:	72fb      	strb	r3, [r7, #11]
 8003806:	f8cd 8050 	str.w	r8, [sp, #80]	; 0x50
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
 800380a:	9b00      	ldr	r3, [sp, #0]
 800380c:	079f      	lsls	r7, r3, #30
 800380e:	d465      	bmi.n	80038dc <f_open.constprop.7+0x36c>
		for (n = 0; lfn[n]; n++) ;
		nent = (n + 25) / 13;
	} else {						/* Otherwise allocate an entry for an SFN  */
		nent = 1;
 8003810:	2701      	movs	r7, #1
{
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
 8003812:	a80d      	add	r0, sp, #52	; 0x34
 8003814:	2100      	movs	r1, #0
 8003816:	f7fd ffbb 	bl	8001790 <dir_sdi.lto_priv.60>
	if (res == FR_OK) {
 800381a:	4682      	mov	sl, r0
 800381c:	2800      	cmp	r0, #0
 800381e:	d150      	bne.n	80038c2 <f_open.constprop.7+0x352>
 8003820:	4680      	mov	r8, r0
 8003822:	e007      	b.n	8003834 <f_open.constprop.7+0x2c4>
 8003824:	200012b0 	.word	0x200012b0
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a blank entry? */
				if (++n == nent) break;	/* A block of contiguous entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
 8003828:	4698      	mov	r8, r3
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
 800382a:	f7fd fea9 	bl	8001580 <dir_next.lto_priv.59>
		} while (res == FR_OK);
 800382e:	4603      	mov	r3, r0
 8003830:	2800      	cmp	r0, #0
 8003832:	d145      	bne.n	80038c0 <f_open.constprop.7+0x350>

	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
 8003834:	9911      	ldr	r1, [sp, #68]	; 0x44
 8003836:	980d      	ldr	r0, [sp, #52]	; 0x34
 8003838:	f7fe f972 	bl	8001b20 <move_window.lto_priv.55>
			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a blank entry? */
				if (++n == nent) break;	/* A block of contiguous entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
 800383c:	2101      	movs	r1, #1
	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
 800383e:	4603      	mov	r3, r0
			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a blank entry? */
				if (++n == nent) break;	/* A block of contiguous entries is found */
 8003840:	4488      	add	r8, r1
	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
 8003842:	2800      	cmp	r0, #0
 8003844:	d13c      	bne.n	80038c0 <f_open.constprop.7+0x350>
			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a blank entry? */
 8003846:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8003848:	7812      	ldrb	r2, [r2, #0]
 800384a:	2ae5      	cmp	r2, #229	; 0xe5
				if (++n == nent) break;	/* A block of contiguous entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
 800384c:	a80d      	add	r0, sp, #52	; 0x34
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a blank entry? */
 800384e:	d001      	beq.n	8003854 <f_open.constprop.7+0x2e4>
 8003850:	2a00      	cmp	r2, #0
 8003852:	d1e9      	bne.n	8003828 <f_open.constprop.7+0x2b8>
				if (++n == nent) break;	/* A block of contiguous entries is found */
 8003854:	4547      	cmp	r7, r8
 8003856:	d1e8      	bne.n	800382a <f_open.constprop.7+0x2ba>
	} else {						/* Otherwise allocate an entry for an SFN  */
		nent = 1;
	}
	res = dir_alloc(dp, nent);		/* Allocate entries */

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 8003858:	1e7b      	subs	r3, r7, #1
 800385a:	9300      	str	r3, [sp, #0]
 800385c:	d14a      	bne.n	80038f4 <f_open.constprop.7+0x384>
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
#endif

	if (res == FR_OK) {				/* Set SFN entry */
		res = move_window(dp->fs, dp->sect);
 800385e:	980d      	ldr	r0, [sp, #52]	; 0x34
 8003860:	9911      	ldr	r1, [sp, #68]	; 0x44
 8003862:	f7fe f95d 	bl	8001b20 <move_window.lto_priv.55>
		if (res == FR_OK) {
 8003866:	4682      	mov	sl, r0
 8003868:	2800      	cmp	r0, #0
 800386a:	f47f aef2 	bne.w	8003652 <f_open.constprop.7+0xe2>
			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
 800386e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8003870:	f103 0220 	add.w	r2, r3, #32
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
 8003874:	f803 ab01 	strb.w	sl, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 8003878:	4293      	cmp	r3, r2
 800387a:	d1fb      	bne.n	8003874 <f_open.constprop.7+0x304>

	if (res == FR_OK) {				/* Set SFN entry */
		res = move_window(dp->fs, dp->sect);
		if (res == FR_OK) {
			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
 800387c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800387e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8003880:	f102 010b 	add.w	r1, r2, #11
 8003884:	3b01      	subs	r3, #1
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
 8003886:	f812 0b01 	ldrb.w	r0, [r2], #1
 800388a:	f803 0f01 	strb.w	r0, [r3, #1]!
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 800388e:	428a      	cmp	r2, r1
 8003890:	d1f9      	bne.n	8003886 <f_open.constprop.7+0x316>
		res = move_window(dp->fs, dp->sect);
		if (res == FR_OK) {
			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NS] & (NS_BODY | NS_EXT);	/* Put NT flag */
 8003892:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8003894:	9912      	ldr	r1, [sp, #72]	; 0x48
 8003896:	7adb      	ldrb	r3, [r3, #11]
#endif
			dp->fs->wflag = 1;
 8003898:	9f0d      	ldr	r7, [sp, #52]	; 0x34
		res = move_window(dp->fs, dp->sect);
		if (res == FR_OK) {
			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NS] & (NS_BODY | NS_EXT);	/* Put NT flag */
 800389a:	f003 0318 	and.w	r3, r3, #24
#endif
			dp->fs->wflag = 1;
 800389e:	2201      	movs	r2, #1
		res = move_window(dp->fs, dp->sect);
		if (res == FR_OK) {
			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NS] & (NS_BODY | NS_EXT);	/* Put NT flag */
 80038a0:	730b      	strb	r3, [r1, #12]
#endif
			dp->fs->wflag = 1;
 80038a2:	713a      	strb	r2, [r7, #4]
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
 80038a4:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 80038a8:	f046 0608 	orr.w	r6, r6, #8
 80038ac:	e698      	b.n	80035e0 <f_open.constprop.7+0x70>
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32)
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 80038ae:	f898 2015 	ldrb.w	r2, [r8, #21]
 80038b2:	f898 3014 	ldrb.w	r3, [r8, #20]
 80038b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80038ba:	ea49 4903 	orr.w	r9, r9, r3, lsl #16
 80038be:	e6b0      	b.n	8003622 <f_open.constprop.7+0xb2>
 80038c0:	469a      	mov	sl, r3
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
		} while (res == FR_OK);
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 80038c2:	f1ba 0f04 	cmp.w	sl, #4
 80038c6:	bf08      	it	eq
 80038c8:	f04f 0a07 	moveq.w	sl, #7
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
 80038cc:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 80038d0:	f1ba 0f00 	cmp.w	sl, #0
 80038d4:	f47f aebd 	bne.w	8003652 <f_open.constprop.7+0xe2>
 80038d8:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 80038da:	e7e5      	b.n	80038a8 <f_open.constprop.7+0x338>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dp->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
 80038dc:	2300      	movs	r3, #0
 80038de:	e000      	b.n	80038e2 <f_open.constprop.7+0x372>
		for (n = 0; lfn[n]; n++) ;
 80038e0:	3301      	adds	r3, #1
 80038e2:	f838 2013 	ldrh.w	r2, [r8, r3, lsl #1]
 80038e6:	2a00      	cmp	r2, #0
 80038e8:	d1fa      	bne.n	80038e0 <f_open.constprop.7+0x370>
		nent = (n + 25) / 13;
 80038ea:	3319      	adds	r3, #25
 80038ec:	270d      	movs	r7, #13
 80038ee:	fbb3 f7f7 	udiv	r7, r3, r7
 80038f2:	e78e      	b.n	8003812 <f_open.constprop.7+0x2a2>
		nent = 1;
	}
	res = dir_alloc(dp, nent);		/* Allocate entries */

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
		res = dir_sdi(dp, dp->index - nent);
 80038f4:	f8bd 103a 	ldrh.w	r1, [sp, #58]	; 0x3a
 80038f8:	9b00      	ldr	r3, [sp, #0]
 80038fa:	a80d      	add	r0, sp, #52	; 0x34
 80038fc:	1ac9      	subs	r1, r1, r3
 80038fe:	f7fd ff47 	bl	8001790 <dir_sdi.lto_priv.60>
		if (res == FR_OK) {
 8003902:	4682      	mov	sl, r0
 8003904:	2800      	cmp	r0, #0
 8003906:	d1e1      	bne.n	80038cc <f_open.constprop.7+0x35c>
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
 8003908:	9913      	ldr	r1, [sp, #76]	; 0x4c
static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
	BYTE sum = 0;
 800390a:	4603      	mov	r3, r0
 800390c:	f101 000b 	add.w	r0, r1, #11
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
 8003910:	f811 7b01 	ldrb.w	r7, [r1], #1
 8003914:	01da      	lsls	r2, r3, #7
 8003916:	ea42 0353 	orr.w	r3, r2, r3, lsr #1
 800391a:	fa57 f383 	uxtab	r3, r7, r3
 800391e:	4281      	cmp	r1, r0
 8003920:	b2db      	uxtb	r3, r3
 8003922:	d1f5      	bne.n	8003910 <f_open.constprop.7+0x3a0>
 8003924:	f8df b134 	ldr.w	fp, [pc, #308]	; 8003a5c <f_open.constprop.7+0x4ec>
 8003928:	9302      	str	r3, [sp, #8]
 800392a:	9601      	str	r6, [sp, #4]
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
		res = dir_sdi(dp, dp->index - nent);
		if (res == FR_OK) {
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
 800392c:	980d      	ldr	r0, [sp, #52]	; 0x34
 800392e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8003930:	f7fe f8f6 	bl	8001b20 <move_window.lto_priv.55>
 8003934:	4602      	mov	r2, r0
				if (res != FR_OK) break;
 8003936:	2a00      	cmp	r2, #0
 8003938:	d14e      	bne.n	80039d8 <f_open.constprop.7+0x468>
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
 800393a:	f89d 9000 	ldrb.w	r9, [sp]
 800393e:	9f12      	ldr	r7, [sp, #72]	; 0x48
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
 8003940:	f89d 3008 	ldrb.w	r3, [sp, #8]
		if (res == FR_OK) {
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
				if (res != FR_OK) break;
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
 8003944:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
 8003948:	737b      	strb	r3, [r7, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 800394a:	210f      	movs	r1, #15
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
 800394c:	f109 30ff 	add.w	r0, r9, #4294967295
 8003950:	260d      	movs	r6, #13
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 8003952:	72f9      	strb	r1, [r7, #11]
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
 8003954:	4613      	mov	r3, r2
	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
 8003956:	fb06 f600 	mul.w	r6, r6, r0
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
 800395a:	733a      	strb	r2, [r7, #12]
	ST_WORD(dir+LDIR_FstClusLO, 0);
 800395c:	76ba      	strb	r2, [r7, #26]
 800395e:	76fa      	strb	r2, [r7, #27]

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
 8003960:	4611      	mov	r1, r2
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8003962:	f64f 7cff 	movw	ip, #65535	; 0xffff
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8003966:	f04f 0aff 	mov.w	sl, #255	; 0xff
 800396a:	e00f      	b.n	800398c <f_open.constprop.7+0x41c>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 800396c:	f838 3016 	ldrh.w	r3, [r8, r6, lsl #1]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8003970:	54bb      	strb	r3, [r7, r2]
 8003972:	443a      	add	r2, r7
 8003974:	ea4f 2e13 	mov.w	lr, r3, lsr #8
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8003978:	1c70      	adds	r0, r6, #1
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 800397a:	f882 e001 	strb.w	lr, [r2, #1]
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
 800397e:	b983      	cbnz	r3, 80039a2 <f_open.constprop.7+0x432>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8003980:	4606      	mov	r6, r0
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
 8003982:	f64f 73ff 	movw	r3, #65535	; 0xffff
	} while (++s < 13);
 8003986:	3101      	adds	r1, #1
 8003988:	290d      	cmp	r1, #13
 800398a:	d00c      	beq.n	80039a6 <f_open.constprop.7+0x436>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 800398c:	4563      	cmp	r3, ip
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 800398e:	f81b 2001 	ldrb.w	r2, [fp, r1]
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8003992:	d1eb      	bne.n	800396c <f_open.constprop.7+0x3fc>
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8003994:	eb07 0e02 	add.w	lr, r7, r2
 8003998:	f807 a002 	strb.w	sl, [r7, r2]
 800399c:	4630      	mov	r0, r6
 800399e:	f88e a001 	strb.w	sl, [lr, #1]
 80039a2:	4606      	mov	r6, r0
 80039a4:	e7ef      	b.n	8003986 <f_open.constprop.7+0x416>
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
	} while (++s < 13);
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
 80039a6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80039aa:	4293      	cmp	r3, r2
 80039ac:	d002      	beq.n	80039b4 <f_open.constprop.7+0x444>
 80039ae:	f838 3010 	ldrh.w	r3, [r8, r0, lsl #1]
 80039b2:	b90b      	cbnz	r3, 80039b8 <f_open.constprop.7+0x448>
 80039b4:	f049 0940 	orr.w	r9, r9, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 80039b8:	f887 9000 	strb.w	r9, [r7]
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
				if (res != FR_OK) break;
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
				dp->fs->wflag = 1;
 80039bc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80039be:	2201      	movs	r2, #1
 80039c0:	711a      	strb	r2, [r3, #4]
				res = dir_next(dp, 0);	/* Next entry */
 80039c2:	a80d      	add	r0, sp, #52	; 0x34
 80039c4:	2100      	movs	r1, #0
 80039c6:	f7fd fddb 	bl	8001580 <dir_next.lto_priv.59>
			} while (res == FR_OK && --nent);
 80039ca:	b928      	cbnz	r0, 80039d8 <f_open.constprop.7+0x468>
 80039cc:	9b00      	ldr	r3, [sp, #0]
 80039ce:	3b01      	subs	r3, #1
 80039d0:	9300      	str	r3, [sp, #0]
 80039d2:	d1ab      	bne.n	800392c <f_open.constprop.7+0x3bc>
 80039d4:	9e01      	ldr	r6, [sp, #4]
 80039d6:	e742      	b.n	800385e <f_open.constprop.7+0x2ee>
 80039d8:	9e01      	ldr	r6, [sp, #4]
 80039da:	4682      	mov	sl, r0
 80039dc:	e776      	b.n	80038cc <f_open.constprop.7+0x35c>
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 80039de:	46ca      	mov	sl, r9
 80039e0:	e021      	b.n	8003a26 <f_open.constprop.7+0x4b6>
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 80039e2:	2801      	cmp	r0, #1
 80039e4:	f43f ae33 	beq.w	800364e <f_open.constprop.7+0xde>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 80039e8:	f1b0 3fff 	cmp.w	r0, #4294967295
 80039ec:	d02e      	beq.n	8003a4c <f_open.constprop.7+0x4dc>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 80039ee:	f1ba 0f01 	cmp.w	sl, #1
 80039f2:	f67f ae2c 	bls.w	800364e <f_open.constprop.7+0xde>
 80039f6:	697b      	ldr	r3, [r7, #20]
 80039f8:	459a      	cmp	sl, r3
 80039fa:	f4bf ae28 	bcs.w	800364e <f_open.constprop.7+0xde>
 80039fe:	4651      	mov	r1, sl
 8003a00:	4638      	mov	r0, r7
 8003a02:	2200      	movs	r2, #0
 8003a04:	f000 f99c 	bl	8003d40 <put_fat.part.6.lto_priv.63>
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
 8003a08:	bb28      	cbnz	r0, 8003a56 <f_open.constprop.7+0x4e6>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
 8003a0a:	693b      	ldr	r3, [r7, #16]
 8003a0c:	1c5a      	adds	r2, r3, #1
				fs->free_clust++;
 8003a0e:	f103 0301 	add.w	r3, r3, #1
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
 8003a12:	d004      	beq.n	8003a1e <f_open.constprop.7+0x4ae>
				fs->free_clust++;
				fs->fsi_flag |= 1;
 8003a14:	797a      	ldrb	r2, [r7, #5]
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
				fs->free_clust++;
 8003a16:	613b      	str	r3, [r7, #16]
				fs->fsi_flag |= 1;
 8003a18:	f042 0301 	orr.w	r3, r2, #1
 8003a1c:	717b      	strb	r3, [r7, #5]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
 8003a1e:	697b      	ldr	r3, [r7, #20]
 8003a20:	455b      	cmp	r3, fp
 8003a22:	46da      	mov	sl, fp
 8003a24:	d906      	bls.n	8003a34 <f_open.constprop.7+0x4c4>
 8003a26:	4638      	mov	r0, r7
 8003a28:	4651      	mov	r1, sl
 8003a2a:	f000 fa01 	bl	8003e30 <get_fat.part.5.lto_priv.62>
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
 8003a2e:	4683      	mov	fp, r0
 8003a30:	2800      	cmp	r0, #0
 8003a32:	d1d6      	bne.n	80039e2 <f_open.constprop.7+0x472>
				dj.fs->wflag = 1;
				if (cl) {						/* Remove the cluster chain if exist */
					dw = dj.fs->winsect;
					res = remove_chain(dj.fs, cl);
					if (res == FR_OK) {
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 8003a34:	980d      	ldr	r0, [sp, #52]	; 0x34
						res = move_window(dj.fs, dw);
 8003a36:	9900      	ldr	r1, [sp, #0]
				dj.fs->wflag = 1;
				if (cl) {						/* Remove the cluster chain if exist */
					dw = dj.fs->winsect;
					res = remove_chain(dj.fs, cl);
					if (res == FR_OK) {
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 8003a38:	f109 33ff 	add.w	r3, r9, #4294967295
 8003a3c:	60c3      	str	r3, [r0, #12]
						res = move_window(dj.fs, dw);
 8003a3e:	f7fe f86f 	bl	8001b20 <move_window.lto_priv.55>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
 8003a42:	4682      	mov	sl, r0
 8003a44:	2800      	cmp	r0, #0
 8003a46:	f43f ae57 	beq.w	80036f8 <f_open.constprop.7+0x188>
 8003a4a:	e602      	b.n	8003652 <f_open.constprop.7+0xe2>
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8003a4c:	f04f 0a01 	mov.w	sl, #1
 8003a50:	e5ff      	b.n	8003652 <f_open.constprop.7+0xe2>
 8003a52:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 8003a54:	e653      	b.n	80036fe <f_open.constprop.7+0x18e>
 8003a56:	4682      	mov	sl, r0
 8003a58:	e5fb      	b.n	8003652 <f_open.constprop.7+0xe2>
 8003a5a:	bf00      	nop
 8003a5c:	080045d0 	.word	0x080045d0

08003a60 <check_fs>:
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 8003a60:	2200      	movs	r2, #0
 8003a62:	f04f 33ff 	mov.w	r3, #4294967295
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 8003a66:	b570      	push	{r4, r5, r6, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 8003a68:	7102      	strb	r2, [r0, #4]
 8003a6a:	62c3      	str	r3, [r0, #44]	; 0x2c
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 8003a6c:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
 8003a6e:	f7fe f857 	bl	8001b20 <move_window.lto_priv.55>
 8003a72:	b108      	cbz	r0, 8003a78 <check_fs+0x18>
		return 3;
 8003a74:	2003      	movs	r0, #3
 8003a76:	bd70      	pop	{r4, r5, r6, pc}

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
 8003a78:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
 8003a7c:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
 8003a80:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8003a84:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8003a88:	4293      	cmp	r3, r2
 8003a8a:	d001      	beq.n	8003a90 <check_fs+0x30>
		return 2;
 8003a8c:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
 8003a8e:	bd70      	pop	{r4, r5, r6, pc}
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
 8003a90:	f894 1068 	ldrb.w	r1, [r4, #104]	; 0x68
 8003a94:	f894 3069 	ldrb.w	r3, [r4, #105]	; 0x69
 8003a98:	f894 2066 	ldrb.w	r2, [r4, #102]	; 0x66
 8003a9c:	f894 6067 	ldrb.w	r6, [r4, #103]	; 0x67
 8003aa0:	4d0f      	ldr	r5, [pc, #60]	; (8003ae0 <check_fs+0x80>)
 8003aa2:	0409      	lsls	r1, r1, #16
 8003aa4:	ea41 6303 	orr.w	r3, r1, r3, lsl #24
 8003aa8:	4313      	orrs	r3, r2
 8003aaa:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 8003aae:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8003ab2:	42ab      	cmp	r3, r5
 8003ab4:	d0eb      	beq.n	8003a8e <check_fs+0x2e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8003ab6:	f894 1084 	ldrb.w	r1, [r4, #132]	; 0x84
 8003aba:	f894 3085 	ldrb.w	r3, [r4, #133]	; 0x85
 8003abe:	f894 2082 	ldrb.w	r2, [r4, #130]	; 0x82
 8003ac2:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
 8003ac6:	0409      	lsls	r1, r1, #16
 8003ac8:	ea41 6303 	orr.w	r3, r1, r3, lsl #24
 8003acc:	4313      	orrs	r3, r2
 8003ace:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8003ad2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
		return 3;
 8003ad6:	1b58      	subs	r0, r3, r5
 8003ad8:	bf18      	it	ne
 8003ada:	2001      	movne	r0, #1
 8003adc:	bd70      	pop	{r4, r5, r6, pc}
 8003ade:	bf00      	nop
 8003ae0:	00544146 	.word	0x00544146
	...

08003af0 <codec_writeReg>:
	// Now Enable I2S
	CODEC_I2S->I2SCFGR|=SPI_I2SCFGR_I2SE;
}

void codec_writeReg(uint8_t addr, uint8_t data)
{
 8003af0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	txbuf[0]=addr;
 8003af2:	4f2b      	ldr	r7, [pc, #172]	; (8003ba0 <codec_writeReg+0xb0>)
 8003af4:	2320      	movs	r3, #32
 8003af6:	7038      	strb	r0, [r7, #0]
	txbuf[1]=data;
 8003af8:	7079      	strb	r1, [r7, #1]
 8003afa:	f383 8811 	msr	BASEPRI, r3
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8003afe:	4d29      	ldr	r5, [pc, #164]	; (8003ba4 <codec_writeReg+0xb4>)
  i2cp->state = I2C_ACTIVE_TX;
 8003b00:	2003      	movs	r0, #3

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8003b02:	2294      	movs	r2, #148	; 0x94
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8003b04:	2100      	movs	r1, #0
 8003b06:	842a      	strh	r2, [r5, #32]
  i2cp->state = I2C_ACTIVE_TX;
 8003b08:	7028      	strb	r0, [r5, #0]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8003b0a:	60a9      	str	r1, [r5, #8]
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
  I2C_TypeDef *dp = i2cp->i2c;
 8003b0c:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8003b0e:	f381 8811 	msr	BASEPRI, r1

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8003b12:	6b2c      	ldr	r4, [r5, #48]	; 0x30
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8003b14:	6ae8      	ldr	r0, [r5, #44]	; 0x2c

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8003b16:	6826      	ldr	r6, [r4, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8003b18:	6800      	ldr	r0, [r0, #0]

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8003b1a:	6aac      	ldr	r4, [r5, #40]	; 0x28
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8003b1c:	f8d5 e024 	ldr.w	lr, [r5, #36]	; 0x24

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8003b20:	6034      	str	r4, [r6, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8003b22:	f04f 0c02 	mov.w	ip, #2
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003b26:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 8003b2a:	60f7      	str	r7, [r6, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8003b2c:	f8c6 c004 	str.w	ip, [r6, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8003b30:	f8c0 e000 	str.w	lr, [r0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8003b34:	60c1      	str	r1, [r0, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8003b36:	6041      	str	r1, [r0, #4]
 8003b38:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8003b3a:	4618      	mov	r0, r3
 8003b3c:	e001      	b.n	8003b42 <codec_writeReg+0x52>
 8003b3e:	f381 8811 	msr	BASEPRI, r1
 8003b42:	f380 8811 	msr	BASEPRI, r0
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8003b46:	6993      	ldr	r3, [r2, #24]
 8003b48:	079f      	lsls	r7, r3, #30
 8003b4a:	d402      	bmi.n	8003b52 <codec_writeReg+0x62>
 8003b4c:	6813      	ldr	r3, [r2, #0]
 8003b4e:	059b      	lsls	r3, r3, #22
 8003b50:	d50a      	bpl.n	8003b68 <codec_writeReg+0x78>
 8003b52:	6a63      	ldr	r3, [r4, #36]	; 0x24
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((time - start) < (end - start));
 8003b54:	1b9b      	subs	r3, r3, r6
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 8003b56:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8003b5a:	d3f0      	bcc.n	8003b3e <codec_writeReg+0x4e>
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 8003b5c:	2305      	movs	r3, #5
 8003b5e:	702b      	strb	r3, [r5, #0]
 8003b60:	2300      	movs	r3, #0
 8003b62:	f383 8811 	msr	BASEPRI, r3
 8003b66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8003b68:	6853      	ldr	r3, [r2, #4]
 8003b6a:	490f      	ldr	r1, [pc, #60]	; (8003ba8 <codec_writeReg+0xb8>)

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8003b6c:	4c0d      	ldr	r4, [pc, #52]	; (8003ba4 <codec_writeReg+0xb4>)
 8003b6e:	698e      	ldr	r6, [r1, #24]
 8003b70:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8003b74:	6053      	str	r3, [r2, #4]
  dp->CR1 |= I2C_CR1_START;
 8003b76:	6813      	ldr	r3, [r2, #0]
  tp->p_u.wttrp = trp;
 8003b78:	f104 011c 	add.w	r1, r4, #28
 8003b7c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003b80:	6013      	str	r3, [r2, #0]

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8003b82:	2003      	movs	r0, #3
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->p_u.wttrp = trp;
 8003b84:	6231      	str	r1, [r6, #32]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8003b86:	61ee      	str	r6, [r5, #28]
  tp->p_u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8003b88:	2128      	movs	r1, #40	; 0x28
 8003b8a:	f7fc fd91 	bl	80006b0 <chSchGoSleepTimeoutS>
  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 8003b8e:	3001      	adds	r0, #1
 8003b90:	d0e4      	beq.n	8003b5c <codec_writeReg+0x6c>
    i2cp->state = I2C_LOCKED;
  }
  else {
    i2cp->state = I2C_READY;
 8003b92:	2302      	movs	r3, #2
 8003b94:	7023      	strb	r3, [r4, #0]
 8003b96:	2300      	movs	r3, #0
 8003b98:	f383 8811 	msr	BASEPRI, r3
 8003b9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003b9e:	bf00      	nop
 8003ba0:	200014d8 	.word	0x200014d8
 8003ba4:	2000103c 	.word	0x2000103c
 8003ba8:	20001140 	.word	0x20001140
 8003bac:	00000000 	.word	0x00000000

08003bb0 <dir_find.part.7.lto_priv.61>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
 8003bb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	res = dir_sdi(dp, 0);			/* Rewind directory object */
	if (res != FR_OK) return res;

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8003bb4:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8003bb8:	27ff      	movs	r7, #255	; 0xff
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
 8003bba:	b083      	sub	sp, #12
 8003bbc:	4604      	mov	r4, r0
 8003bbe:	f8df 9174 	ldr.w	r9, [pc, #372]	; 8003d34 <dir_find.part.7.lto_priv.61+0x184>
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;

	return tbl_lower[i] ? tbl_upper[i] : chr;
 8003bc2:	f8df b174 	ldr.w	fp, [pc, #372]	; 8003d38 <dir_find.part.7.lto_priv.61+0x188>

	res = dir_sdi(dp, 0);			/* Rewind directory object */
	if (res != FR_OK) return res;

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8003bc6:	8406      	strh	r6, [r0, #32]
 8003bc8:	463d      	mov	r5, r7
 8003bca:	e009      	b.n	8003be0 <dir_find.part.7.lto_priv.61+0x30>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8003bcc:	290f      	cmp	r1, #15
 8003bce:	d041      	beq.n	8003c54 <dir_find.part.7.lto_priv.61+0xa4>
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				if (!(dp->fn[NS] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8003bd0:	8426      	strh	r6, [r4, #32]
 8003bd2:	25ff      	movs	r5, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
 8003bd4:	4620      	mov	r0, r4
 8003bd6:	2100      	movs	r1, #0
 8003bd8:	f7fd fcd2 	bl	8001580 <dir_next.lto_priv.59>
	} while (res == FR_OK);
 8003bdc:	2800      	cmp	r0, #0
 8003bde:	d136      	bne.n	8003c4e <dir_find.part.7.lto_priv.61+0x9e>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
 8003be0:	6820      	ldr	r0, [r4, #0]
 8003be2:	6921      	ldr	r1, [r4, #16]
 8003be4:	f7fd ff9c 	bl	8001b20 <move_window.lto_priv.55>
		if (res != FR_OK) break;
 8003be8:	bb88      	cbnz	r0, 8003c4e <dir_find.part.7.lto_priv.61+0x9e>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
 8003bea:	6963      	ldr	r3, [r4, #20]
		c = dir[DIR_Name];
 8003bec:	f893 e000 	ldrb.w	lr, [r3]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8003bf0:	f1be 0f00 	cmp.w	lr, #0
 8003bf4:	d043      	beq.n	8003c7e <dir_find.part.7.lto_priv.61+0xce>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8003bf6:	f1be 0fe5 	cmp.w	lr, #229	; 0xe5
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 8003bfa:	7ada      	ldrb	r2, [r3, #11]
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8003bfc:	d0e8      	beq.n	8003bd0 <dir_find.part.7.lto_priv.61+0x20>
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 8003bfe:	f002 013f 	and.w	r1, r2, #63	; 0x3f
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8003c02:	0712      	lsls	r2, r2, #28
 8003c04:	d4e2      	bmi.n	8003bcc <dir_find.part.7.lto_priv.61+0x1c>
			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
 8003c06:	290f      	cmp	r1, #15
 8003c08:	d024      	beq.n	8003c54 <dir_find.part.7.lto_priv.61+0xa4>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
 8003c0a:	b98d      	cbnz	r5, 8003c30 <dir_find.part.7.lto_priv.61+0x80>
 8003c0c:	461d      	mov	r5, r3
 8003c0e:	f103 0c0a 	add.w	ip, r3, #10
 8003c12:	46f0      	mov	r8, lr
 8003c14:	4602      	mov	r2, r0
 8003c16:	e001      	b.n	8003c1c <dir_find.part.7.lto_priv.61+0x6c>
 8003c18:	f815 8f01 	ldrb.w	r8, [r5, #1]!
)
{
	BYTE sum = 0;
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
 8003c1c:	01d1      	lsls	r1, r2, #7
 8003c1e:	ea41 0252 	orr.w	r2, r1, r2, lsr #1
 8003c22:	fa58 f282 	uxtab	r2, r8, r2
 8003c26:	4565      	cmp	r5, ip
 8003c28:	b2d2      	uxtb	r2, r2
 8003c2a:	d1f5      	bne.n	8003c18 <dir_find.part.7.lto_priv.61+0x68>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
 8003c2c:	4297      	cmp	r7, r2
 8003c2e:	d00e      	beq.n	8003c4e <dir_find.part.7.lto_priv.61+0x9e>
				if (!(dp->fn[NS] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
 8003c30:	69a2      	ldr	r2, [r4, #24]
 8003c32:	7ad1      	ldrb	r1, [r2, #11]
 8003c34:	07c9      	lsls	r1, r1, #31
 8003c36:	d4cb      	bmi.n	8003bd0 <dir_find.part.7.lto_priv.61+0x20>
 8003c38:	f102 050b 	add.w	r5, r2, #11
 8003c3c:	e001      	b.n	8003c42 <dir_find.part.7.lto_priv.61+0x92>
 8003c3e:	f813 ef01 	ldrb.w	lr, [r3, #1]!
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 8003c42:	f812 1b01 	ldrb.w	r1, [r2], #1
 8003c46:	458e      	cmp	lr, r1
 8003c48:	d1c2      	bne.n	8003bd0 <dir_find.part.7.lto_priv.61+0x20>
 8003c4a:	42aa      	cmp	r2, r5
 8003c4c:	d1f7      	bne.n	8003c3e <dir_find.part.7.lto_priv.61+0x8e>
#endif
		res = dir_next(dp, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
 8003c4e:	b003      	add	sp, #12
 8003c50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dp->lfn) {
 8003c54:	69e0      	ldr	r0, [r4, #28]
 8003c56:	2800      	cmp	r0, #0
 8003c58:	d0bc      	beq.n	8003bd4 <dir_find.part.7.lto_priv.61+0x24>
					if (c & LLE) {		/* Is it start of LFN sequence? */
 8003c5a:	f01e 0f40 	tst.w	lr, #64	; 0x40
 8003c5e:	d00a      	beq.n	8003c76 <dir_find.part.7.lto_priv.61+0xc6>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dp->lfn_idx = dp->index;	/* Start index of LFN */
 8003c60:	88e2      	ldrh	r2, [r4, #6]
			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dp->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
 8003c62:	7b5f      	ldrb	r7, [r3, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
						dp->lfn_idx = dp->index;	/* Start index of LFN */
 8003c64:	8422      	strh	r2, [r4, #32]
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dp->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
 8003c66:	f00e 05bf 	and.w	r5, lr, #191	; 0xbf
						dp->lfn_idx = dp->index;	/* Start index of LFN */
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8003c6a:	f893 a00d 	ldrb.w	sl, [r3, #13]
 8003c6e:	45ba      	cmp	sl, r7
 8003c70:	d009      	beq.n	8003c86 <dir_find.part.7.lto_priv.61+0xd6>
 8003c72:	25ff      	movs	r5, #255	; 0xff
 8003c74:	e7ae      	b.n	8003bd4 <dir_find.part.7.lto_priv.61+0x24>
 8003c76:	45ae      	cmp	lr, r5
 8003c78:	d0f7      	beq.n	8003c6a <dir_find.part.7.lto_priv.61+0xba>
 8003c7a:	25ff      	movs	r5, #255	; 0xff
 8003c7c:	e7aa      	b.n	8003bd4 <dir_find.part.7.lto_priv.61+0x24>
	do {
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8003c7e:	2004      	movs	r0, #4
#endif
		res = dir_next(dp, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
 8003c80:	b003      	add	sp, #12
 8003c82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
 8003c86:	781a      	ldrb	r2, [r3, #0]
 8003c88:	9200      	str	r2, [sp, #0]
 8003c8a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003c8e:	3a01      	subs	r2, #1
 8003c90:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 8003c94:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8003c98:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 8003d3c <dir_find.part.7.lto_priv.61+0x18c>
	s = 0; wc = 1;
 8003c9c:	9501      	str	r5, [sp, #4]
 8003c9e:	2101      	movs	r1, #1
 8003ca0:	4694      	mov	ip, r2
 8003ca2:	e003      	b.n	8003cac <dir_find.part.7.lto_priv.61+0xfc>
		if (wc) {	/* Last character has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
 8003ca4:	42b5      	cmp	r5, r6
 8003ca6:	d141      	bne.n	8003d2c <dir_find.part.7.lto_priv.61+0x17c>
		}
	} while (++s < 13);				/* Repeat until all characters in the entry are checked */
 8003ca8:	45c8      	cmp	r8, r9
 8003caa:	d02e      	beq.n	8003d0a <dir_find.part.7.lto_priv.61+0x15a>


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
 8003cac:	f818 2b01 	ldrb.w	r2, [r8], #1
 8003cb0:	189d      	adds	r5, r3, r2
 8003cb2:	5c9a      	ldrb	r2, [r3, r2]
 8003cb4:	786d      	ldrb	r5, [r5, #1]
 8003cb6:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
		if (wc) {	/* Last character has not been processed */
 8003cba:	2900      	cmp	r1, #0
 8003cbc:	d0f2      	beq.n	8003ca4 <dir_find.part.7.lto_priv.61+0xf4>
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
 8003cbe:	2d61      	cmp	r5, #97	; 0x61
 8003cc0:	d01f      	beq.n	8003d02 <dir_find.part.7.lto_priv.61+0x152>
 8003cc2:	4f1b      	ldr	r7, [pc, #108]	; (8003d30 <dir_find.part.7.lto_priv.61+0x180>)
 8003cc4:	2100      	movs	r1, #0
 8003cc6:	e001      	b.n	8003ccc <dir_find.part.7.lto_priv.61+0x11c>
 8003cc8:	4295      	cmp	r5, r2
 8003cca:	d01b      	beq.n	8003d04 <dir_find.part.7.lto_priv.61+0x154>
 8003ccc:	f837 2f02 	ldrh.w	r2, [r7, #2]!
 8003cd0:	3101      	adds	r1, #1
 8003cd2:	2a00      	cmp	r2, #0
 8003cd4:	d1f8      	bne.n	8003cc8 <dir_find.part.7.lto_priv.61+0x118>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 8003cd6:	f1bc 0ffe 	cmp.w	ip, #254	; 0xfe
 8003cda:	d827      	bhi.n	8003d2c <dir_find.part.7.lto_priv.61+0x17c>
 8003cdc:	f830 e01c 	ldrh.w	lr, [r0, ip, lsl #1]
 8003ce0:	f1be 0f61 	cmp.w	lr, #97	; 0x61
 8003ce4:	f10c 0c01 	add.w	ip, ip, #1
 8003ce8:	d01b      	beq.n	8003d22 <dir_find.part.7.lto_priv.61+0x172>
 8003cea:	4f11      	ldr	r7, [pc, #68]	; (8003d30 <dir_find.part.7.lto_priv.61+0x180>)
 8003cec:	2100      	movs	r1, #0
 8003cee:	e001      	b.n	8003cf4 <dir_find.part.7.lto_priv.61+0x144>
 8003cf0:	4596      	cmp	lr, r2
 8003cf2:	d017      	beq.n	8003d24 <dir_find.part.7.lto_priv.61+0x174>
 8003cf4:	f837 2f02 	ldrh.w	r2, [r7, #2]!
 8003cf8:	3101      	adds	r1, #1
 8003cfa:	2a00      	cmp	r2, #0
 8003cfc:	d1f8      	bne.n	8003cf0 <dir_find.part.7.lto_priv.61+0x140>
 8003cfe:	4671      	mov	r1, lr
 8003d00:	e012      	b.n	8003d28 <dir_find.part.7.lto_priv.61+0x178>
 8003d02:	2100      	movs	r1, #0

	return tbl_lower[i] ? tbl_upper[i] : chr;
 8003d04:	f83b 5011 	ldrh.w	r5, [fp, r1, lsl #1]
 8003d08:	e7e5      	b.n	8003cd6 <dir_find.part.7.lto_priv.61+0x126>
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
		}
	} while (++s < 13);				/* Repeat until all characters in the entry are checked */

	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
 8003d0a:	9b00      	ldr	r3, [sp, #0]
 8003d0c:	9d01      	ldr	r5, [sp, #4]
 8003d0e:	065f      	lsls	r7, r3, #25
 8003d10:	d503      	bpl.n	8003d1a <dir_find.part.7.lto_priv.61+0x16a>
 8003d12:	b111      	cbz	r1, 8003d1a <dir_find.part.7.lto_priv.61+0x16a>
 8003d14:	f830 301c 	ldrh.w	r3, [r0, ip, lsl #1]
 8003d18:	b943      	cbnz	r3, 8003d2c <dir_find.part.7.lto_priv.61+0x17c>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dp->lfn_idx = dp->index;	/* Start index of LFN */
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8003d1a:	3d01      	subs	r5, #1
 8003d1c:	b2ed      	uxtb	r5, r5
 8003d1e:	4657      	mov	r7, sl
 8003d20:	e758      	b.n	8003bd4 <dir_find.part.7.lto_priv.61+0x24>
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
 8003d22:	2100      	movs	r1, #0

	return tbl_lower[i] ? tbl_upper[i] : chr;
 8003d24:	f83b 1011 	ldrh.w	r1, [fp, r1, lsl #1]
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last character has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 8003d28:	428d      	cmp	r5, r1
 8003d2a:	d0bd      	beq.n	8003ca8 <dir_find.part.7.lto_priv.61+0xf8>
 8003d2c:	4657      	mov	r7, sl
 8003d2e:	e7a0      	b.n	8003c72 <dir_find.part.7.lto_priv.61+0xc2>
 8003d30:	080047c0 	.word	0x080047c0
 8003d34:	080045dd 	.word	0x080045dd
 8003d38:	080045e0 	.word	0x080045e0
 8003d3c:	080045d0 	.word	0x080045d0

08003d40 <put_fat.part.6.lto_priv.63>:
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

FRESULT put_fat (
 8003d40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
 8003d42:	7803      	ldrb	r3, [r0, #0]
 8003d44:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

FRESULT put_fat (
 8003d46:	4604      	mov	r4, r0
 8003d48:	460d      	mov	r5, r1
 8003d4a:	4616      	mov	r6, r2

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
 8003d4c:	d038      	beq.n	8003dc0 <put_fat.part.6.lto_priv.63+0x80>
 8003d4e:	2b03      	cmp	r3, #3
 8003d50:	d047      	beq.n	8003de2 <put_fat.part.6.lto_priv.63+0xa2>
 8003d52:	2b01      	cmp	r3, #1
 8003d54:	d161      	bne.n	8003e1a <put_fat.part.6.lto_priv.63+0xda>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003d56:	6a01      	ldr	r1, [r0, #32]
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8003d58:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003d5c:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 8003d60:	f7fd fede 	bl	8001b20 <move_window.lto_priv.55>
			if (res != FR_OK) break;
 8003d64:	2800      	cmp	r0, #0
 8003d66:	d159      	bne.n	8003e1c <put_fat.part.6.lto_priv.63+0xdc>
			p = &fs->win[bc % SS(fs)];
 8003d68:	f3c7 0308 	ubfx	r3, r7, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8003d6c:	f015 0501 	ands.w	r5, r5, #1
 8003d70:	4423      	add	r3, r4
 8003d72:	b2f2      	uxtb	r2, r6
 8003d74:	d006      	beq.n	8003d84 <put_fat.part.6.lto_priv.63+0x44>
 8003d76:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
 8003d7a:	f001 010f 	and.w	r1, r1, #15
 8003d7e:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
 8003d82:	b2d2      	uxtb	r2, r2
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003d84:	6a21      	ldr	r1, [r4, #32]
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8003d86:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
			bc++;
 8003d8a:	3701      	adds	r7, #1
			fs->wflag = 1;
 8003d8c:	2301      	movs	r3, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003d8e:	eb01 2157 	add.w	r1, r1, r7, lsr #9
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
 8003d92:	7123      	strb	r3, [r4, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003d94:	4620      	mov	r0, r4
 8003d96:	f7fd fec3 	bl	8001b20 <move_window.lto_priv.55>
			if (res != FR_OK) break;
 8003d9a:	2800      	cmp	r0, #0
 8003d9c:	d13e      	bne.n	8003e1c <put_fat.part.6.lto_priv.63+0xdc>
			p = &fs->win[bc % SS(fs)];
 8003d9e:	f3c7 0708 	ubfx	r7, r7, #0, #9
 8003da2:	4427      	add	r7, r4
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8003da4:	b115      	cbz	r5, 8003dac <put_fat.part.6.lto_priv.63+0x6c>
 8003da6:	f3c6 1607 	ubfx	r6, r6, #4, #8
 8003daa:	e006      	b.n	8003dba <put_fat.part.6.lto_priv.63+0x7a>
 8003dac:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8003db0:	f3c6 2603 	ubfx	r6, r6, #8, #4
 8003db4:	f022 020f 	bic.w	r2, r2, #15
 8003db8:	4316      	orrs	r6, r2
 8003dba:	f887 6030 	strb.w	r6, [r7, #48]	; 0x30
 8003dbe:	e02d      	b.n	8003e1c <put_fat.part.6.lto_priv.63+0xdc>
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8003dc0:	6a01      	ldr	r1, [r0, #32]
 8003dc2:	eb01 2115 	add.w	r1, r1, r5, lsr #8
 8003dc6:	f7fd feab 	bl	8001b20 <move_window.lto_priv.55>
			if (res != FR_OK) break;
 8003dca:	bb38      	cbnz	r0, 8003e1c <put_fat.part.6.lto_priv.63+0xdc>
			p = &fs->win[clst * 2 % SS(fs)];
 8003dcc:	006d      	lsls	r5, r5, #1
 8003dce:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
 8003dd2:	1962      	adds	r2, r4, r5
 8003dd4:	f3c6 2307 	ubfx	r3, r6, #8, #8
 8003dd8:	f882 6030 	strb.w	r6, [r2, #48]	; 0x30
 8003ddc:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
 8003de0:	e01c      	b.n	8003e1c <put_fat.part.6.lto_priv.63+0xdc>
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8003de2:	6a01      	ldr	r1, [r0, #32]
 8003de4:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
 8003de8:	f7fd fe9a 	bl	8001b20 <move_window.lto_priv.55>
			if (res != FR_OK) break;
 8003dec:	b9b0      	cbnz	r0, 8003e1c <put_fat.part.6.lto_priv.63+0xdc>
			p = &fs->win[clst * 4 % SS(fs)];
 8003dee:	00ad      	lsls	r5, r5, #2
 8003df0:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 8003df4:	f105 0330 	add.w	r3, r5, #48	; 0x30
 8003df8:	4423      	add	r3, r4
			val |= LD_DWORD(p) & 0xF0000000;
 8003dfa:	4425      	add	r5, r4
 8003dfc:	78da      	ldrb	r2, [r3, #3]
 8003dfe:	0612      	lsls	r2, r2, #24
 8003e00:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 8003e04:	4316      	orrs	r6, r2
			ST_DWORD(p, val);
 8003e06:	f3c6 2707 	ubfx	r7, r6, #8, #8
 8003e0a:	0c31      	lsrs	r1, r6, #16
 8003e0c:	0e32      	lsrs	r2, r6, #24
 8003e0e:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
 8003e12:	705f      	strb	r7, [r3, #1]
 8003e14:	7099      	strb	r1, [r3, #2]
 8003e16:	70da      	strb	r2, [r3, #3]
 8003e18:	e000      	b.n	8003e1c <put_fat.part.6.lto_priv.63+0xdc>
			break;

		default :
			res = FR_INT_ERR;
 8003e1a:	2002      	movs	r0, #2
		}
		fs->wflag = 1;
 8003e1c:	2301      	movs	r3, #1
 8003e1e:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
 8003e20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003e22:	bf00      	nop
	...

08003e30 <get_fat.part.5.lto_priv.62>:
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
 8003e30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;

	switch (fs->fs_type) {
 8003e32:	7803      	ldrb	r3, [r0, #0]
 8003e34:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
 8003e36:	4607      	mov	r7, r0
 8003e38:	460c      	mov	r4, r1


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;

	switch (fs->fs_type) {
 8003e3a:	d02c      	beq.n	8003e96 <get_fat.part.5.lto_priv.62+0x66>
 8003e3c:	2b03      	cmp	r3, #3
 8003e3e:	d00e      	beq.n	8003e5e <get_fat.part.5.lto_priv.62+0x2e>
 8003e40:	2b01      	cmp	r3, #1
 8003e42:	d001      	beq.n	8003e48 <get_fat.part.5.lto_priv.62+0x18>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;

	default:
		return 1;
 8003e44:	2001      	movs	r0, #1
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
}
 8003e46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003e48:	6a01      	ldr	r1, [r0, #32]
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
 8003e4a:	eb04 0554 	add.w	r5, r4, r4, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003e4e:	eb01 2155 	add.w	r1, r1, r5, lsr #9
 8003e52:	f7fd fe65 	bl	8001b20 <move_window.lto_priv.55>
 8003e56:	b388      	cbz	r0, 8003ebc <get_fat.part.5.lto_priv.62+0x8c>

	default:
		return 1;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 8003e58:	f04f 30ff 	mov.w	r0, #4294967295
 8003e5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 8003e5e:	6a01      	ldr	r1, [r0, #32]
 8003e60:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 8003e64:	f7fd fe5c 	bl	8001b20 <move_window.lto_priv.55>
 8003e68:	2800      	cmp	r0, #0
 8003e6a:	d1f5      	bne.n	8003e58 <get_fat.part.5.lto_priv.62+0x28>
		p = &fs->win[clst * 4 % SS(fs)];
 8003e6c:	00a3      	lsls	r3, r4, #2
 8003e6e:	f403 74fe 	and.w	r4, r3, #508	; 0x1fc
 8003e72:	f104 0330 	add.w	r3, r4, #48	; 0x30
 8003e76:	443b      	add	r3, r7
		return LD_DWORD(p) & 0x0FFFFFFF;
 8003e78:	443c      	add	r4, r7
 8003e7a:	78da      	ldrb	r2, [r3, #3]
 8003e7c:	7899      	ldrb	r1, [r3, #2]
 8003e7e:	7858      	ldrb	r0, [r3, #1]
 8003e80:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8003e84:	0612      	lsls	r2, r2, #24
 8003e86:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8003e8a:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 8003e8e:	4318      	orrs	r0, r3
 8003e90:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
 8003e94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return clst & 1 ? wc >> 4 : (wc & 0xFFF);

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 8003e96:	6a01      	ldr	r1, [r0, #32]
 8003e98:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 8003e9c:	f7fd fe40 	bl	8001b20 <move_window.lto_priv.55>
 8003ea0:	2800      	cmp	r0, #0
 8003ea2:	d1d9      	bne.n	8003e58 <get_fat.part.5.lto_priv.62+0x28>
		p = &fs->win[clst * 2 % SS(fs)];
 8003ea4:	0061      	lsls	r1, r4, #1
 8003ea6:	f401 72ff 	and.w	r2, r1, #510	; 0x1fe
		return LD_WORD(p);
 8003eaa:	18bb      	adds	r3, r7, r2
 8003eac:	461a      	mov	r2, r3
 8003eae:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8003eb2:	f892 0031 	ldrb.w	r0, [r2, #49]	; 0x31
 8003eb6:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8003eba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 8003ebc:	f3c5 0308 	ubfx	r3, r5, #0, #9
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003ec0:	6a39      	ldr	r1, [r7, #32]

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 8003ec2:	1c6e      	adds	r6, r5, #1
 8003ec4:	443b      	add	r3, r7
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003ec6:	eb01 2156 	add.w	r1, r1, r6, lsr #9
 8003eca:	4638      	mov	r0, r7

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 8003ecc:	f893 5030 	ldrb.w	r5, [r3, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003ed0:	f7fd fe26 	bl	8001b20 <move_window.lto_priv.55>
 8003ed4:	2800      	cmp	r0, #0
 8003ed6:	d1bf      	bne.n	8003e58 <get_fat.part.5.lto_priv.62+0x28>
		wc |= fs->win[bc % SS(fs)] << 8;
 8003ed8:	f3c6 0608 	ubfx	r6, r6, #0, #9
 8003edc:	19bb      	adds	r3, r7, r6
 8003ede:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
		return clst & 1 ? wc >> 4 : (wc & 0xFFF);
 8003ee2:	07e3      	lsls	r3, r4, #31
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
 8003ee4:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
		return clst & 1 ? wc >> 4 : (wc & 0xFFF);
 8003ee8:	bf4c      	ite	mi
 8003eea:	0900      	lsrmi	r0, r0, #4
 8003eec:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 8003ef0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003ef2:	bf00      	nop
	...

08003f00 <sync_window.part.1.lto_priv.56>:
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
 8003f00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	DWORD wsect;
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
 8003f04:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1))
 8003f06:	f100 0730 	add.w	r7, r0, #48	; 0x30
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
 8003f0a:	4605      	mov	r5, r0
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
 8003f0c:	4622      	mov	r2, r4
 8003f0e:	7840      	ldrb	r0, [r0, #1]
 8003f10:	4639      	mov	r1, r7
 8003f12:	f7ff fa55 	bl	80033c0 <disk_write.constprop.16>
 8003f16:	4680      	mov	r8, r0
 8003f18:	b9b0      	cbnz	r0, 8003f48 <sync_window.part.1.lto_priv.56+0x48>
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003f1a:	6a2a      	ldr	r2, [r5, #32]
 8003f1c:	69ab      	ldr	r3, [r5, #24]

	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
 8003f1e:	7128      	strb	r0, [r5, #4]
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003f20:	1aa2      	subs	r2, r4, r2
 8003f22:	429a      	cmp	r2, r3
 8003f24:	d20d      	bcs.n	8003f42 <sync_window.part.1.lto_priv.56+0x42>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003f26:	78ee      	ldrb	r6, [r5, #3]
 8003f28:	2e01      	cmp	r6, #1
 8003f2a:	d801      	bhi.n	8003f30 <sync_window.part.1.lto_priv.56+0x30>
 8003f2c:	e009      	b.n	8003f42 <sync_window.part.1.lto_priv.56+0x42>
 8003f2e:	69ab      	ldr	r3, [r5, #24]
				wsect += fs->fsize;
				disk_write(fs->drv, fs->win, wsect, 1);
 8003f30:	7868      	ldrb	r0, [r5, #1]
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
				wsect += fs->fsize;
 8003f32:	441c      	add	r4, r3
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003f34:	3e01      	subs	r6, #1
				wsect += fs->fsize;
				disk_write(fs->drv, fs->win, wsect, 1);
 8003f36:	4622      	mov	r2, r4
 8003f38:	4639      	mov	r1, r7
 8003f3a:	f7ff fa41 	bl	80033c0 <disk_write.constprop.16>
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003f3e:	2e01      	cmp	r6, #1
 8003f40:	d1f5      	bne.n	8003f2e <sync_window.part.1.lto_priv.56+0x2e>
				disk_write(fs->drv, fs->win, wsect, 1);
			}
		}
	}
	return FR_OK;
}
 8003f42:	4640      	mov	r0, r8
 8003f44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
 8003f48:	f04f 0801 	mov.w	r8, #1
				disk_write(fs->drv, fs->win, wsect, 1);
			}
		}
	}
	return FR_OK;
}
 8003f4c:	4640      	mov	r0, r8
 8003f4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003f52:	bf00      	nop
	...

08003f60 <find_volume.lto_priv.57>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003f60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003f62:	4607      	mov	r7, r0
	WORD nrsv;
	FATFS *fs;


	/* Get logical drive number from the path name */
	*rfs = 0;
 8003f64:	2300      	movs	r3, #0
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003f66:	b085      	sub	sp, #20
	FATFS *fs;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 8003f68:	4608      	mov	r0, r1
	WORD nrsv;
	FATFS *fs;


	/* Get logical drive number from the path name */
	*rfs = 0;
 8003f6a:	603b      	str	r3, [r7, #0]
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003f6c:	4615      	mov	r5, r2
	FATFS *fs;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 8003f6e:	f7fd fadf 	bl	8001530 <get_ldnumber.lto_priv.77>
	if (vol < 0) return FR_INVALID_DRIVE;
 8003f72:	1e04      	subs	r4, r0, #0
 8003f74:	db2a      	blt.n	8003fcc <find_volume.lto_priv.57+0x6c>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8003f76:	4bba      	ldr	r3, [pc, #744]	; (8004260 <find_volume.lto_priv.57+0x300>)
 8003f78:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8003f7c:	b346      	cbz	r6, 8003fd0 <find_volume.lto_priv.57+0x70>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 8003f7e:	603e      	str	r6, [r7, #0]

	if (fs->fs_type) {					/* If the volume has been mounted */
 8003f80:	7833      	ldrb	r3, [r6, #0]
 8003f82:	b163      	cbz	r3, 8003f9e <find_volume.lto_priv.57+0x3e>
		stat = disk_status(fs->drv);
 8003f84:	7870      	ldrb	r0, [r6, #1]
 8003f86:	f7fd fdf3 	bl	8001b70 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8003f8a:	07c1      	lsls	r1, r0, #31
 8003f8c:	d407      	bmi.n	8003f9e <find_volume.lto_priv.57+0x3e>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 8003f8e:	2d00      	cmp	r5, #0
 8003f90:	d044      	beq.n	800401c <find_volume.lto_priv.57+0xbc>
				return FR_WRITE_PROTECTED;
 8003f92:	f010 0f04 	tst.w	r0, #4
 8003f96:	bf0c      	ite	eq
 8003f98:	2000      	moveq	r0, #0
 8003f9a:	200a      	movne	r0, #10
 8003f9c:	e014      	b.n	8003fc8 <find_volume.lto_priv.57+0x68>

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8003f9e:	b2e4      	uxtb	r4, r4
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 8003fa0:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8003fa2:	7074      	strb	r4, [r6, #1]
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 8003fa4:	7033      	strb	r3, [r6, #0]
    BYTE pdrv                /* Physical drive nmuber (0..) */
)
{
  DSTATUS stat;

  switch (pdrv) {
 8003fa6:	b974      	cbnz	r4, 8003fc6 <find_volume.lto_priv.57+0x66>
    return stat;
#else
  case SDC:
    stat = 0;
    /* It is initialized externally, just reads the status.*/
    if (blkGetDriverState(&SDCD1) != BLK_READY)
 8003fa8:	4bae      	ldr	r3, [pc, #696]	; (8004264 <find_volume.lto_priv.57+0x304>)
 8003faa:	791b      	ldrb	r3, [r3, #4]
 8003fac:	2b05      	cmp	r3, #5
 8003fae:	d10a      	bne.n	8003fc6 <find_volume.lto_priv.57+0x66>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
 8003fb0:	4630      	mov	r0, r6
 8003fb2:	4621      	mov	r1, r4
 8003fb4:	f7ff fd54 	bl	8003a60 <check_fs>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
 8003fb8:	2801      	cmp	r0, #1
 8003fba:	d00b      	beq.n	8003fd4 <find_volume.lto_priv.57+0x74>
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
		} while (!LD2PT(vol) && fmt && ++i < 4);
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003fbc:	2803      	cmp	r0, #3
 8003fbe:	d02b      	beq.n	8004018 <find_volume.lto_priv.57+0xb8>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8003fc0:	b3a0      	cbz	r0, 800402c <find_volume.lto_priv.57+0xcc>
 8003fc2:	200d      	movs	r0, #13
 8003fc4:	e000      	b.n	8003fc8 <find_volume.lto_priv.57+0x68>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8003fc6:	2003      	movs	r0, #3
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
 8003fc8:	b005      	add	sp, #20
 8003fca:	bdf0      	pop	{r4, r5, r6, r7, pc}


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
 8003fcc:	200b      	movs	r0, #11
 8003fce:	e7fb      	b.n	8003fc8 <find_volume.lto_priv.57+0x68>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8003fd0:	200c      	movs	r0, #12
 8003fd2:	e7f9      	b.n	8003fc8 <find_volume.lto_priv.57+0x68>
 8003fd4:	4631      	mov	r1, r6
		UINT i;
		DWORD br[4];

		for (i = 0; i < 4; i++) {			/* Get partition offset */
			BYTE *pt = fs->win+MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
 8003fd6:	f891 31f2 	ldrb.w	r3, [r1, #498]	; 0x1f2
 8003fda:	b16b      	cbz	r3, 8003ff8 <find_volume.lto_priv.57+0x98>
 8003fdc:	f891 01f8 	ldrb.w	r0, [r1, #504]	; 0x1f8
 8003fe0:	f891 31f9 	ldrb.w	r3, [r1, #505]	; 0x1f9
 8003fe4:	f891 21f6 	ldrb.w	r2, [r1, #502]	; 0x1f6
 8003fe8:	f891 51f7 	ldrb.w	r5, [r1, #503]	; 0x1f7
 8003fec:	0400      	lsls	r0, r0, #16
 8003fee:	ea40 6303 	orr.w	r3, r0, r3, lsl #24
 8003ff2:	4313      	orrs	r3, r2
 8003ff4:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8003ff8:	f84d 3024 	str.w	r3, [sp, r4, lsl #2]
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		UINT i;
		DWORD br[4];

		for (i = 0; i < 4; i++) {			/* Get partition offset */
 8003ffc:	3401      	adds	r4, #1
 8003ffe:	2c04      	cmp	r4, #4
 8004000:	f101 0110 	add.w	r1, r1, #16
 8004004:	d1e7      	bne.n	8003fd6 <find_volume.lto_priv.57+0x76>
 8004006:	2500      	movs	r5, #0
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
 8004008:	f85d 4025 	ldr.w	r4, [sp, r5, lsl #2]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
		} while (!LD2PT(vol) && fmt && ++i < 4);
 800400c:	3501      	adds	r5, #1
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 800400e:	b93c      	cbnz	r4, 8004020 <find_volume.lto_priv.57+0xc0>
 8004010:	2002      	movs	r0, #2
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8004012:	2d04      	cmp	r5, #4
 8004014:	d1f8      	bne.n	8004008 <find_volume.lto_priv.57+0xa8>
 8004016:	e7d1      	b.n	8003fbc <find_volume.lto_priv.57+0x5c>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8004018:	2001      	movs	r0, #1
 800401a:	e7d5      	b.n	8003fc8 <find_volume.lto_priv.57+0x68>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
 800401c:	4628      	mov	r0, r5
 800401e:	e7d3      	b.n	8003fc8 <find_volume.lto_priv.57+0x68>
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8004020:	4630      	mov	r0, r6
 8004022:	4621      	mov	r1, r4
 8004024:	f7ff fd1c 	bl	8003a60 <check_fs>
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8004028:	2800      	cmp	r0, #0
 800402a:	d1f2      	bne.n	8004012 <find_volume.lto_priv.57+0xb2>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 800402c:	f896 203c 	ldrb.w	r2, [r6, #60]	; 0x3c
 8004030:	f896 303b 	ldrb.w	r3, [r6, #59]	; 0x3b
 8004034:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004038:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800403c:	d1c1      	bne.n	8003fc2 <find_volume.lto_priv.57+0x62>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 800403e:	f896 1047 	ldrb.w	r1, [r6, #71]	; 0x47
 8004042:	f896 3046 	ldrb.w	r3, [r6, #70]	; 0x46
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8004046:	ea53 2301 	orrs.w	r3, r3, r1, lsl #8
 800404a:	f000 8088 	beq.w	800415e <find_volume.lto_priv.57+0x1fe>
	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 800404e:	4619      	mov	r1, r3
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 8004050:	f896 c040 	ldrb.w	ip, [r6, #64]	; 0x40
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;
 8004054:	61b1      	str	r1, [r6, #24]

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8004056:	f10c 33ff 	add.w	r3, ip, #4294967295
 800405a:	2b01      	cmp	r3, #1

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 800405c:	f886 c003 	strb.w	ip, [r6, #3]
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8004060:	d8af      	bhi.n	8003fc2 <find_volume.lto_priv.57+0x62>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 8004062:	f896 303d 	ldrb.w	r3, [r6, #61]	; 0x3d
 8004066:	70b3      	strb	r3, [r6, #2]
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
 8004068:	2b00      	cmp	r3, #0
 800406a:	d0aa      	beq.n	8003fc2 <find_volume.lto_priv.57+0x62>
 800406c:	1e5a      	subs	r2, r3, #1
 800406e:	421a      	tst	r2, r3
 8004070:	d1a7      	bne.n	8003fc2 <find_volume.lto_priv.57+0x62>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8004072:	f896 2041 	ldrb.w	r2, [r6, #65]	; 0x41
 8004076:	f896 5042 	ldrb.w	r5, [r6, #66]	; 0x42
 800407a:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
 800407e:	072a      	lsls	r2, r5, #28

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8004080:	8135      	strh	r5, [r6, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
 8004082:	d19e      	bne.n	8003fc2 <find_volume.lto_priv.57+0x62>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8004084:	f896 0044 	ldrb.w	r0, [r6, #68]	; 0x44
 8004088:	f896 2043 	ldrb.w	r2, [r6, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 800408c:	ea52 2200 	orrs.w	r2, r2, r0, lsl #8
 8004090:	d10d      	bne.n	80040ae <find_volume.lto_priv.57+0x14e>
 8004092:	f896 7052 	ldrb.w	r7, [r6, #82]	; 0x52
 8004096:	f896 2053 	ldrb.w	r2, [r6, #83]	; 0x53
 800409a:	f896 0050 	ldrb.w	r0, [r6, #80]	; 0x50
 800409e:	f896 e051 	ldrb.w	lr, [r6, #81]	; 0x51
 80040a2:	043f      	lsls	r7, r7, #16
 80040a4:	ea47 6202 	orr.w	r2, r7, r2, lsl #24
 80040a8:	4302      	orrs	r2, r0
 80040aa:	ea42 220e 	orr.w	r2, r2, lr, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 80040ae:	f896 e03f 	ldrb.w	lr, [r6, #63]	; 0x3f
 80040b2:	f896 003e 	ldrb.w	r0, [r6, #62]	; 0x3e
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
 80040b6:	ea50 2e0e 	orrs.w	lr, r0, lr, lsl #8
 80040ba:	d082      	beq.n	8003fc2 <find_volume.lto_priv.57+0x62>
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
 80040bc:	fb0c f001 	mul.w	r0, ip, r1
 80040c0:	eb0e 1715 	add.w	r7, lr, r5, lsr #4

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 80040c4:	4407      	add	r7, r0
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 80040c6:	42ba      	cmp	r2, r7
 80040c8:	f4ff af7b 	bcc.w	8003fc2 <find_volume.lto_priv.57+0x62>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 80040cc:	1bd2      	subs	r2, r2, r7
 80040ce:	fbb2 f3f3 	udiv	r3, r2, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 80040d2:	2b00      	cmp	r3, #0
 80040d4:	f43f af75 	beq.w	8003fc2 <find_volume.lto_priv.57+0x62>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 80040d8:	f640 72f5 	movw	r2, #4085	; 0xff5
 80040dc:	4293      	cmp	r3, r2
 80040de:	f240 80c7 	bls.w	8004270 <find_volume.lto_priv.57+0x310>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 80040e2:	f64f 72f5 	movw	r2, #65525	; 0xfff5
 80040e6:	4293      	cmp	r3, r2
 80040e8:	f240 809e 	bls.w	8004228 <find_volume.lto_priv.57+0x2c8>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 80040ec:	3302      	adds	r3, #2
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 80040ee:	eb04 020e 	add.w	r2, r4, lr
	fs->database = bsect + sysect;						/* Data start sector */
 80040f2:	4427      	add	r7, r4
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 80040f4:	6173      	str	r3, [r6, #20]
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 80040f6:	6232      	str	r2, [r6, #32]
	fs->database = bsect + sysect;						/* Data start sector */
 80040f8:	62b7      	str	r7, [r6, #40]	; 0x28
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->volbase = bsect;								/* Volume start sector */
 80040fa:	61f4      	str	r4, [r6, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	fs->database = bsect + sysect;						/* Data start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 80040fc:	2d00      	cmp	r5, #0
 80040fe:	f47f af60 	bne.w	8003fc2 <find_volume.lto_priv.57+0x62>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 8004102:	f896 005e 	ldrb.w	r0, [r6, #94]	; 0x5e
 8004106:	f896 e05f 	ldrb.w	lr, [r6, #95]	; 0x5f
 800410a:	f896 205c 	ldrb.w	r2, [r6, #92]	; 0x5c
 800410e:	f896 705d 	ldrb.w	r7, [r6, #93]	; 0x5d
 8004112:	0400      	lsls	r0, r0, #16
 8004114:	ea40 600e 	orr.w	r0, r0, lr, lsl #24
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
 8004118:	009b      	lsls	r3, r3, #2
 800411a:	4302      	orrs	r2, r0
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 800411c:	f203 10ff 	addw	r0, r3, #511	; 0x1ff
 8004120:	ebb1 2f50 	cmp.w	r1, r0, lsr #9
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	fs->database = bsect + sysect;						/* Data start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 8004124:	ea42 2307 	orr.w	r3, r2, r7, lsl #8
 8004128:	6273      	str	r3, [r6, #36]	; 0x24
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 800412a:	f4ff af4a 	bcc.w	8003fc2 <find_volume.lto_priv.57+0x62>

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
 800412e:	f896 1061 	ldrb.w	r1, [r6, #97]	; 0x61
 8004132:	f896 3060 	ldrb.w	r3, [r6, #96]	; 0x60
 8004136:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 800413a:	f04f 32ff 	mov.w	r2, #4294967295

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 800413e:	2180      	movs	r1, #128	; 0x80
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
 8004140:	2b01      	cmp	r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8004142:	6132      	str	r2, [r6, #16]
 8004144:	60f2      	str	r2, [r6, #12]

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8004146:	7171      	strb	r1, [r6, #5]
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
 8004148:	d018      	beq.n	800417c <find_volume.lto_priv.57+0x21c>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 800414a:	2303      	movs	r3, #3
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
	fs->id = ++Fsid;	/* File system mount ID */
 800414c:	4a46      	ldr	r2, [pc, #280]	; (8004268 <find_volume.lto_priv.57+0x308>)
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
 800414e:	7033      	strb	r3, [r6, #0]
	fs->id = ++Fsid;	/* File system mount ID */
 8004150:	8813      	ldrh	r3, [r2, #0]
 8004152:	3301      	adds	r3, #1
 8004154:	b29b      	uxth	r3, r3
 8004156:	8013      	strh	r3, [r2, #0]
 8004158:	80f3      	strh	r3, [r6, #6]
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
 800415a:	2000      	movs	r0, #0
 800415c:	e734      	b.n	8003fc8 <find_volume.lto_priv.57+0x68>

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 800415e:	f896 3056 	ldrb.w	r3, [r6, #86]	; 0x56
 8004162:	f896 0057 	ldrb.w	r0, [r6, #87]	; 0x57
 8004166:	f896 2054 	ldrb.w	r2, [r6, #84]	; 0x54
 800416a:	f896 1055 	ldrb.w	r1, [r6, #85]	; 0x55
 800416e:	041b      	lsls	r3, r3, #16
 8004170:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8004174:	4313      	orrs	r3, r2
 8004176:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 800417a:	e769      	b.n	8004050 <find_volume.lto_priv.57+0xf0>
	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
 800417c:	1c61      	adds	r1, r4, #1
 800417e:	4630      	mov	r0, r6
 8004180:	f7fd fcce 	bl	8001b20 <move_window.lto_priv.55>
 8004184:	2800      	cmp	r0, #0
 8004186:	d1e0      	bne.n	800414a <find_volume.lto_priv.57+0x1ea>
	{
		fs->fsi_flag = 0;
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8004188:	f896 222f 	ldrb.w	r2, [r6, #559]	; 0x22f
 800418c:	f896 322e 	ldrb.w	r3, [r6, #558]	; 0x22e
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
 8004190:	7175      	strb	r5, [r6, #5]
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8004192:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004196:	f64a 2255 	movw	r2, #43605	; 0xaa55
 800419a:	4293      	cmp	r3, r2
 800419c:	d1d5      	bne.n	800414a <find_volume.lto_priv.57+0x1ea>
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
 800419e:	f896 1032 	ldrb.w	r1, [r6, #50]	; 0x32
 80041a2:	f896 3033 	ldrb.w	r3, [r6, #51]	; 0x33
 80041a6:	f896 2030 	ldrb.w	r2, [r6, #48]	; 0x30
 80041aa:	f896 4031 	ldrb.w	r4, [r6, #49]	; 0x31
 80041ae:	482f      	ldr	r0, [pc, #188]	; (800426c <find_volume.lto_priv.57+0x30c>)
 80041b0:	0409      	lsls	r1, r1, #16
 80041b2:	ea41 6303 	orr.w	r3, r1, r3, lsl #24
 80041b6:	4313      	orrs	r3, r2
 80041b8:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 80041bc:	4283      	cmp	r3, r0
 80041be:	d1c4      	bne.n	800414a <find_volume.lto_priv.57+0x1ea>
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
 80041c0:	f896 1216 	ldrb.w	r1, [r6, #534]	; 0x216
 80041c4:	f896 3217 	ldrb.w	r3, [r6, #535]	; 0x217
 80041c8:	f896 2214 	ldrb.w	r2, [r6, #532]	; 0x214
 80041cc:	f896 4215 	ldrb.w	r4, [r6, #533]	; 0x215
 80041d0:	0409      	lsls	r1, r1, #16
 80041d2:	f100 50ff 	add.w	r0, r0, #534773760	; 0x1fe00000
 80041d6:	ea41 6303 	orr.w	r3, r1, r3, lsl #24
 80041da:	f500 5000 	add.w	r0, r0, #8192	; 0x2000
 80041de:	4313      	orrs	r3, r2
 80041e0:	3020      	adds	r0, #32
 80041e2:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 80041e6:	4283      	cmp	r3, r0
 80041e8:	d1af      	bne.n	800414a <find_volume.lto_priv.57+0x1ea>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80041ea:	f896 421a 	ldrb.w	r4, [r6, #538]	; 0x21a
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 80041ee:	f896 021e 	ldrb.w	r0, [r6, #542]	; 0x21e
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80041f2:	f896 e21b 	ldrb.w	lr, [r6, #539]	; 0x21b
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 80041f6:	f896 321f 	ldrb.w	r3, [r6, #543]	; 0x21f
 80041fa:	f896 221c 	ldrb.w	r2, [r6, #540]	; 0x21c
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80041fe:	f896 1218 	ldrb.w	r1, [r6, #536]	; 0x218
 8004202:	f896 7219 	ldrb.w	r7, [r6, #537]	; 0x219
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8004206:	f896 521d 	ldrb.w	r5, [r6, #541]	; 0x21d
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 800420a:	0424      	lsls	r4, r4, #16
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 800420c:	0400      	lsls	r0, r0, #16
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 800420e:	ea44 640e 	orr.w	r4, r4, lr, lsl #24
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8004212:	ea40 6303 	orr.w	r3, r0, r3, lsl #24
 8004216:	4313      	orrs	r3, r2
 8004218:	4321      	orrs	r1, r4
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 800421a:	ea41 2207 	orr.w	r2, r1, r7, lsl #8
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 800421e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8004222:	6132      	str	r2, [r6, #16]
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8004224:	60f3      	str	r3, [r6, #12]
 8004226:	e790      	b.n	800414a <find_volume.lto_priv.57+0x1ea>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8004228:	3302      	adds	r3, #2
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800422a:	eb04 020e 	add.w	r2, r4, lr
	fs->database = bsect + sysect;						/* Data start sector */
 800422e:	4427      	add	r7, r4
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8004230:	6173      	str	r3, [r6, #20]
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8004232:	6232      	str	r2, [r6, #32]
	fs->database = bsect + sysect;						/* Data start sector */
 8004234:	62b7      	str	r7, [r6, #40]	; 0x28
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->volbase = bsect;								/* Volume start sector */
 8004236:	61f4      	str	r4, [r6, #28]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8004238:	2d00      	cmp	r5, #0
 800423a:	f43f aec2 	beq.w	8003fc2 <find_volume.lto_priv.57+0x62>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800423e:	005b      	lsls	r3, r3, #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 8004240:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8004244:	4402      	add	r2, r0
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 8004246:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800424a:	6272      	str	r2, [r6, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 800424c:	f4ff aeb9 	bcc.w	8003fc2 <find_volume.lto_priv.57+0x62>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8004250:	f04f 33ff 	mov.w	r3, #4294967295

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8004254:	2280      	movs	r2, #128	; 0x80
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8004256:	6133      	str	r3, [r6, #16]
 8004258:	60f3      	str	r3, [r6, #12]

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 800425a:	7172      	strb	r2, [r6, #5]
 800425c:	2302      	movs	r3, #2
 800425e:	e775      	b.n	800414c <find_volume.lto_priv.57+0x1ec>
 8004260:	20000e38 	.word	0x20000e38
 8004264:	20001078 	.word	0x20001078
 8004268:	200014d4 	.word	0x200014d4
 800426c:	41615252 	.word	0x41615252
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8004270:	3302      	adds	r3, #2
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8004272:	eb04 020e 	add.w	r2, r4, lr
	fs->database = bsect + sysect;						/* Data start sector */
 8004276:	4427      	add	r7, r4
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8004278:	6173      	str	r3, [r6, #20]
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800427a:	6232      	str	r2, [r6, #32]
	fs->database = bsect + sysect;						/* Data start sector */
 800427c:	62b7      	str	r7, [r6, #40]	; 0x28
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->volbase = bsect;								/* Volume start sector */
 800427e:	61f4      	str	r4, [r6, #28]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8004280:	2d00      	cmp	r5, #0
 8004282:	f43f ae9e 	beq.w	8003fc2 <find_volume.lto_priv.57+0x62>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8004286:	f003 0401 	and.w	r4, r3, #1
 800428a:	f204 14ff 	addw	r4, r4, #511	; 0x1ff
 800428e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 8004292:	eb04 0353 	add.w	r3, r4, r3, lsr #1
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8004296:	4402      	add	r2, r0
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 8004298:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800429c:	6272      	str	r2, [r6, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 800429e:	f4ff ae90 	bcc.w	8003fc2 <find_volume.lto_priv.57+0x62>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 80042a2:	f04f 33ff 	mov.w	r3, #4294967295

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 80042a6:	2280      	movs	r2, #128	; 0x80
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 80042a8:	6133      	str	r3, [r6, #16]
 80042aa:	60f3      	str	r3, [r6, #12]

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 80042ac:	7172      	strb	r2, [r6, #5]
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
 80042ae:	2301      	movs	r3, #1
 80042b0:	e74c      	b.n	800414c <find_volume.lto_priv.57+0x1ec>
 80042b2:	bf00      	nop
	...

080042c0 <Tbl>:
 80042c0:	20ac 0000 201a 0192 201e 2026 2020 2021     . ... ... &   ! 
 80042d0:	02c6 2030 0160 2039 0152 0000 017d 0000     ..0 `.9 R...}...
 80042e0:	0000 2018 2019 201c 201d 2022 2013 2014     ... . . . " . . 
 80042f0:	02dc 2122 0161 203a 0153 0000 017e 0178     .."!a.: S...~.x.
 8004300:	00a0 00a1 00a2 00a3 00a4 00a5 00a6 00a7     ................
 8004310:	00a8 00a9 00aa 00ab 00ac 00ad 00ae 00af     ................
 8004320:	00b0 00b1 00b2 00b3 00b4 00b5 00b6 00b7     ................
 8004330:	00b8 00b9 00ba 00bb 00bc 00bd 00be 00bf     ................
 8004340:	00c0 00c1 00c2 00c3 00c4 00c5 00c6 00c7     ................
 8004350:	00c8 00c9 00ca 00cb 00cc 00cd 00ce 00cf     ................
 8004360:	00d0 00d1 00d2 00d3 00d4 00d5 00d6 00d7     ................
 8004370:	00d8 00d9 00da 00db 00dc 00dd 00de 00df     ................
 8004380:	00e0 00e1 00e2 00e3 00e4 00e5 00e6 00e7     ................
 8004390:	00e8 00e9 00ea 00eb 00ec 00ed 00ee 00ef     ................
 80043a0:	00f0 00f1 00f2 00f3 00f4 00f5 00f6 00f7     ................
 80043b0:	00f8 00f9 00fa 00fb 00fc 00fd 00fe 00ff     ................

080043c0 <ExCvt>:
 80043c0:	8180 8382 8584 8786 8988 8b8a 8d8c 8f8e     ................
 80043d0:	9190 9392 9594 9796 9998 9bad 9d8c 9fae     ................
 80043e0:	21a0 a3a2 a5a4 a7a6 a9a8 abaa adac afae     .!..............
 80043f0:	b1b0 b3b2 b5b4 b7b6 b9b8 bbba bdbc bfbe     ................
 8004400:	c1c0 c3c2 c5c4 c7c6 c9c8 cbca cdcc cfce     ................
 8004410:	d1d0 d3d2 d5d4 d7d6 d9d8 dbda dddc dfde     ................
 8004420:	c1c0 c3c2 c5c4 c7c6 c9c8 cbca cdcc cfce     ................
 8004430:	d1d0 d3d2 d5d4 f7d6 d9d8 dbda dddc 9fde     ................
 8004440:	4d44 2041 6166 6c69 7275 0065 2a22 3c3a     DMA failure."*:<
 8004450:	3f3e 7f7c 0000 0000 2c2b 3d3b 5d5b 0000     >?|.....+,;=[]..

08004460 <ch_debug>:
 8004460:	616d 6e69 1600 1801 0404 0844 100c 1814     main......D.....
 8004470:	1c00 1e1d 0000 0000 0000 0000 0000 0000     ................

08004480 <sdc_vmt>:
 8004480:	10b1 0800 10a1 0800 09d1 0800 1c81 0800     ................
 8004490:	24c1 0800 2371 0800 1c71 0800 1c51 0800     .$..q#..q...Q...

080044a0 <sdccfg>:
 80044a0:	0c34 2000 0000 0000 0000 0000 0000 0000     4.. ............

080044b0 <_stm32_dma_streams>:
 80044b0:	6010 4002 6008 4002 0000 000b 6028 4002     .`.@.`.@....(`.@
 80044c0:	6008 4002 0106 000c 6040 4002 6008 4002     .`.@....@`.@.`.@
 80044d0:	0210 000d 6058 4002 6008 4002 0316 000e     ....X`.@.`.@....
 80044e0:	6070 4002 600c 4002 0400 000f 6088 4002     p`.@.`.@.....`.@
 80044f0:	600c 4002 0506 0010 60a0 4002 600c 4002     .`.@.....`.@.`.@
 8004500:	0610 0011 60b8 4002 600c 4002 0716 002f     .....`.@.`.@../.
 8004510:	6410 4002 6408 4002 0800 0038 6428 4002     .d.@.d.@..8.(d.@
 8004520:	6408 4002 0906 0039 6440 4002 6408 4002     .d.@..9.@d.@.d.@
 8004530:	0a10 003a 6458 4002 6408 4002 0b16 003b     ..:.Xd.@.d.@..;.
 8004540:	6470 4002 640c 4002 0c00 003c 6488 4002     pd.@.d.@..<..d.@
 8004550:	640c 4002 0d06 0044 64a0 4002 640c 4002     .d.@..D..d.@.d.@
 8004560:	0e10 0045 64b8 4002 640c 4002 0f16 0046     ..E..d.@.d.@..F.
 8004570:	6c62 6e69 656b 0072 6469 656c 0000 0000     blinker.idle....
 8004580:	3a30 0000 3a30 6966 656c 742e 7478 0000     0:..0:file.txt..
 8004590:	3a30 6966 656c 6573 742e 7478 0000 0000     0:filese.txt....

080045a0 <vmt>:
 80045a0:	20c1 0800 20a1 0800 2101 0800 20e1 0800     . ... ...!... ..
 80045b0:	20f1 0800 20d1 0800 20b1 0800 2091 0800     . ... ... ... ..

080045c0 <i2cfg>:
 80045c0:	0001 0000 86a0 0001 0003 0000 0000 0000     ................

080045d0 <LfnOfs.lto_priv.78>:
 80045d0:	0301 0705 0e09 1210 1614 1c18 001e 0000     ................

080045e0 <tbl_upper.6513>:
 80045e0:	0041 0042 0043 0044 0045 0046 0047 0048     A.B.C.D.E.F.G.H.
 80045f0:	0049 004a 004b 004c 004d 004e 004f 0050     I.J.K.L.M.N.O.P.
 8004600:	0051 0052 0053 0054 0055 0056 0057 0058     Q.R.S.T.U.V.W.X.
 8004610:	0059 005a 0021 ffe0 ffe1 ffe5 ffe2 ffe3     Y.Z.!...........
 8004620:	00c0 00c1 00c2 00c3 00c4 00c5 00c6 00c7     ................
 8004630:	00c8 00c9 00ca 00cb 00cc 00cd 00ce 00cf     ................
 8004640:	00d0 00d1 00d2 00d3 00d4 00d5 00d6 00d8     ................
 8004650:	00d9 00da 00db 00dc 00dd 00de 0178 0100     ............x...
 8004660:	0102 0104 0106 0108 010a 010c 010e 0110     ................
 8004670:	0112 0114 0116 0118 011a 011c 011e 0120     .............. .
 8004680:	0122 0124 0126 0128 012a 012c 012e 0130     ".$.&.(.*.,...0.
 8004690:	0132 0134 0136 0139 013b 013d 013f 0141     2.4.6.9.;.=.?.A.
 80046a0:	0143 0145 0147 014a 014c 014e 0150 0152     C.E.G.J.L.N.P.R.
 80046b0:	0154 0156 0158 015a 015c 015e 0160 0162     T.V.X.Z.\.^.`.b.
 80046c0:	0164 0166 0168 016a 016c 016e 0170 0172     d.f.h.j.l.n.p.r.
 80046d0:	0174 0176 0179 017b 017d 0191 0391 0392     t.v.y.{.}.......
 80046e0:	0393 0394 0395 0396 0397 0398 0399 039a     ................
 80046f0:	039b 039c 039d 039e 039f 03a0 03a1 03a3     ................
 8004700:	03a4 03a5 03a6 03a7 03a8 03a9 03aa 0410     ................
 8004710:	0411 0412 0413 0414 0415 0416 0417 0418     ................
 8004720:	0419 041a 041b 041c 041d 041e 041f 0420     .............. .
 8004730:	0421 0422 0423 0424 0425 0426 0427 0428     !.".#.$.%.&.'.(.
 8004740:	0429 042a 042b 042c 042d 042e 042f 0401     ).*.+.,.-.../...
 8004750:	0402 0403 0404 0405 0406 0407 0408 0409     ................
 8004760:	040a 040b 040c 040e 040f 2160 2161 2162     ..........`!a!b!
 8004770:	2163 2164 2165 2166 2167 2168 2169 216a     c!d!e!f!g!h!i!j!
 8004780:	216b 216c 216d 216e 216f ff21 ff22 ff23     k!l!m!n!o!!.".#.
 8004790:	ff24 ff25 ff26 ff27 ff28 ff29 ff2a ff2b     $.%.&.'.(.).*.+.
 80047a0:	ff2c ff2d ff2e ff2f ff30 ff31 ff32 ff33     ,.-.../.0.1.2.3.
 80047b0:	ff34 ff35 ff36 ff37 ff38 ff39 ff3a 0000     4.5.6.7.8.9.:...

080047c0 <tbl_lower.6512>:
 80047c0:	0061 0062 0063 0064 0065 0066 0067 0068     a.b.c.d.e.f.g.h.
 80047d0:	0069 006a 006b 006c 006d 006e 006f 0070     i.j.k.l.m.n.o.p.
 80047e0:	0071 0072 0073 0074 0075 0076 0077 0078     q.r.s.t.u.v.w.x.
 80047f0:	0079 007a 00a1 00a2 00a3 00a5 00ac 00af     y.z.............
 8004800:	00e0 00e1 00e2 00e3 00e4 00e5 00e6 00e7     ................
 8004810:	00e8 00e9 00ea 00eb 00ec 00ed 00ee 00ef     ................
 8004820:	00f0 00f1 00f2 00f3 00f4 00f5 00f6 00f8     ................
 8004830:	00f9 00fa 00fb 00fc 00fd 00fe 00ff 0101     ................
 8004840:	0103 0105 0107 0109 010b 010d 010f 0111     ................
 8004850:	0113 0115 0117 0119 011b 011d 011f 0121     ..............!.
 8004860:	0123 0125 0127 0129 012b 012d 012f 0131     #.%.'.).+.-./.1.
 8004870:	0133 0135 0137 013a 013c 013e 0140 0142     3.5.7.:.<.>.@.B.
 8004880:	0144 0146 0148 014b 014d 014f 0151 0153     D.F.H.K.M.O.Q.S.
 8004890:	0155 0157 0159 015b 015d 015f 0161 0163     U.W.Y.[.]._.a.c.
 80048a0:	0165 0167 0169 016b 016d 016f 0171 0173     e.g.i.k.m.o.q.s.
 80048b0:	0175 0177 017a 017c 017e 0192 03b1 03b2     u.w.z.|.~.......
 80048c0:	03b3 03b4 03b5 03b6 03b7 03b8 03b9 03ba     ................
 80048d0:	03bb 03bc 03bd 03be 03bf 03c0 03c1 03c3     ................
 80048e0:	03c4 03c5 03c6 03c7 03c8 03c9 03ca 0430     ..............0.
 80048f0:	0431 0432 0433 0434 0435 0436 0437 0438     1.2.3.4.5.6.7.8.
 8004900:	0439 043a 043b 043c 043d 043e 043f 0440     9.:.;.<.=.>.?.@.
 8004910:	0441 0442 0443 0444 0445 0446 0447 0448     A.B.C.D.E.F.G.H.
 8004920:	0449 044a 044b 044c 044d 044e 044f 0451     I.J.K.L.M.N.O.Q.
 8004930:	0452 0453 0454 0455 0456 0457 0458 0459     R.S.T.U.V.W.X.Y.
 8004940:	045a 045b 045c 045e 045f 2170 2171 2172     Z.[.\.^._.p!q!r!
 8004950:	2173 2174 2175 2176 2177 2178 2179 217a     s!t!u!v!w!x!y!z!
 8004960:	217b 217c 217d 217e 217f ff41 ff42 ff43     {!|!}!~!.!A.B.C.
 8004970:	ff44 ff45 ff46 ff47 ff48 ff49 ff4a ff4b     D.E.F.G.H.I.J.K.
 8004980:	ff4c ff4d ff4e ff4f ff50 ff51 ff52 ff53     L.M.N.O.P.Q.R.S.
 8004990:	ff54 ff55 ff56 ff57 ff58 ff59 ff5a 0000     T.U.V.W.X.Y.Z...
